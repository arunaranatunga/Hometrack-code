trace on

expression:(= tran_flg, "Y")
evaluates to f 
let l_new_sim_usage = Y 
let l_new_nt_cn_plan = N 
let l_sim_id = NULL. 
let l_sim_link_start = NULL. 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"ServiceId": "PD161470","ActivationDatetime": "2025-03-26T02:03:41","PlanCode": 999,"SIM": null,"PUK": null,"PIN": null,"Password": "test@333","Mailbox": "UserLabel","PlanMandatory": true} ,  p_name = ServiceId ,  p_data_type = STRING ,  p_raise_exception = t ,  p_errorcode = 24009 ,  p_validations = LIST{'NOT_NULL'} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"ServiceId": "PD161470","ActivationDatetime": "2025-03-26T02:03:41","PlanCode": 999,"SIM": null,"PUK": null,"PIN": null,"Password": "test@333","Mailbox": "UserLabel","PlanMandatory": true} ,  p_attrib_name = ServiceId ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "ServiceId" 
let p_attrib_name = "ServiceId" 
expression:(<procedure> length, p_attrib_name)
evaluates to 11 
let l_attrib_name_len = 11 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 2 
let l_pos = 2 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 12 
let l_pos = 12 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 13 
let l_pos = 13 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 14 
let l_pos = 14 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 15 
let l_pos = 15 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = "PD1 ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to f 
expression:(<unknown op>: 87 p_quoted)
evaluates to t 
expression:(= l_char, """)
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 16 
let l_attrib_start_pos = 16 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 16 
let l_pos = 16 
expression:(substring p_json, l_pos, 1)
evaluates to P 
let l_char = P 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 17 
let l_pos = 17 
expression:(substring p_json, l_pos, 1)
evaluates to D 
let l_char = D 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 18 
let l_pos = 18 
expression:(substring p_json, l_pos, 1)
evaluates to 1 
let l_char = 1 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 19 
let l_pos = 19 
expression:(substring p_json, l_pos, 1)
evaluates to 6 
let l_char = 6 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 20 
let l_pos = 20 
expression:(substring p_json, l_pos, 1)
evaluates to 1 
let l_char = 1 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 21 
let l_pos = 21 
expression:(substring p_json, l_pos, 1)
evaluates to 4 
let l_char = 4 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 22 
let l_pos = 22 
expression:(substring p_json, l_pos, 1)
evaluates to 7 
let l_char = 7 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 23 
let l_pos = 23 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 24 
let l_pos = 24 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to t 
expression:(null l_attrib_str)
evaluates to t 
expression:(substring p_json, l_attrib_start_pos, (- l_pos, l_attrib_start_pos))
evaluates to PD161470 
let l_attrib_str = PD161470 
expression:TRIM ( BOTH ' ' FROM l_attrib_str)
evaluates to PD161470 
procedure sf_json_get_attrib returns PD161470 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to PD161470 
let l_property_value = PD161470 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 

execute function informix.equal[procid=-114] (   = PD161470 ,    =  )
expression:(= l_property_value, "")
evaluates to f 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to t 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns NOT_NULL 
expression:(= l_value, "MIN_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_min_length)
evaluates to f 
expression:(= l_value, "MAX_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_max_length)
evaluates to f 
select cursor iteration.
end cursor
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to PD161470 
procedure sf_get_property returns PD161470 

expression:(<procedure> sf_get_property, p_request_body, "ServiceId", "STRING", "t", 24009,  LIST{"NOT_NULL"})
evaluates to PD161470 
let p_phone_num = PD161470 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"ServiceId": "PD161470","ActivationDatetime": "2025-03-26T02:03:41","PlanCode": 999,"SIM": null,"PUK": null,"PIN": null,"Password": "test@333","Mailbox": "UserLabel","PlanMandatory": true} ,  p_name = ActivationDatetime ,  p_data_type = DATETIME ,  p_raise_exception = t ,  p_errorcode = 24012 ,  p_validations = LIST{'NOT_NULL'} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"ServiceId": "PD161470","ActivationDatetime": "2025-03-26T02:03:41","PlanCode": 999,"SIM": null,"PUK": null,"PIN": null,"Password": "test@333","Mailbox": "UserLabel","PlanMandatory": true} ,  p_attrib_name = ActivationDatetime ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "ActivationDatetime" 
let p_attrib_name = "ActivationDatetime" 
expression:(<procedure> length, p_attrib_name)
evaluates to 20 
let l_attrib_name_len = 20 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 26 
let l_pos = 26 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 45 
let l_pos = 45 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 46 
let l_pos = 46 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 47 
let l_pos = 47 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 48 
let l_pos = 48 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = "202 ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to f 
expression:(<unknown op>: 87 p_quoted)
evaluates to t 
expression:(= l_char, """)
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 49 
let l_attrib_start_pos = 49 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 49 
let l_pos = 49 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 50 
let l_pos = 50 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 51 
let l_pos = 51 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 52 
let l_pos = 52 
expression:(substring p_json, l_pos, 1)
evaluates to 5 
let l_char = 5 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 53 
let l_pos = 53 
expression:(substring p_json, l_pos, 1)
evaluates to - 
let l_char = - 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 54 
let l_pos = 54 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 55 
let l_pos = 55 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 56 
let l_pos = 56 
expression:(substring p_json, l_pos, 1)
evaluates to - 
let l_char = - 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 57 
let l_pos = 57 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 58 
let l_pos = 58 
expression:(substring p_json, l_pos, 1)
evaluates to 6 
let l_char = 6 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 59 
let l_pos = 59 
expression:(substring p_json, l_pos, 1)
evaluates to T 
let l_char = T 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 60 
let l_pos = 60 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 61 
let l_pos = 61 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 62 
let l_pos = 62 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 63 
let l_pos = 63 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 64 
let l_pos = 64 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 65 
let l_pos = 65 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 66 
let l_pos = 66 
expression:(substring p_json, l_pos, 1)
evaluates to 4 
let l_char = 4 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 67 
let l_pos = 67 
expression:(substring p_json, l_pos, 1)
evaluates to 1 
let l_char = 1 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 68 
let l_pos = 68 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to t 
expression:(null l_attrib_str)
evaluates to t 
expression:(substring p_json, l_attrib_start_pos, (- l_pos, l_attrib_start_pos))
evaluates to 2025-03-26T02:03:41 
let l_attrib_str = 2025-03-26T02:03:41 
expression:TRIM ( BOTH ' ' FROM l_attrib_str)
evaluates to 2025-03-26T02:03:41 
procedure sf_json_get_attrib returns 2025-03-26T02:03:41 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to 2025-03-26T02:03:41 
let l_property_value = 2025-03-26T02:03:41 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to t 
expression:(> (<procedure> length, l_property_value), 19)
evaluates to f 
expression:(<procedure> replace, l_property_value, "T", " ")
evaluates to 2025-03-26 02:03:41 
let l_dt = 2025-03-26 02:03:41 
expression:(in p_data_type, "DATE")
evaluates to f 
expression:l_dt
evaluates to 2025-03-26 02:03:41 
let l_property_value = 2025-03-26 02:03:41 

execute function informix.equal[procid=-114] (   = 2025-03-26 02:03:41 ,    =  )
expression:(= l_property_value, "")
evaluates to f 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to 2025-03-26 02:03:41 
procedure sf_get_property returns 2025-03-26 02:03:41 

expression:(<procedure> sf_get_property, p_request_body, "ActivationDatetime", "DATETIME", "t", 24012,  LIST{"NOT_NULL"})
evaluates to 2025-03-26 02:03:41 
let p_connect_dt = 2025-03-26 02:03:41 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"ServiceId": "PD161470","ActivationDatetime": "2025-03-26T02:03:41","PlanCode": 999,"SIM": null,"PUK": null,"PIN": null,"Password": "test@333","Mailbox": "UserLabel","PlanMandatory": true} ,  p_name = PlanCode ,  p_data_type = NUMBER ,  p_raise_exception = t ,  p_errorcode = 24267 ,  p_validations = LIST{'NOT_NULL'} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to f 
expression:(= p_data_type, "BOOLEAN")
evaluates to f 
expression:(= p_data_type, "BOOLEAN_YN")
evaluates to f 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"ServiceId": "PD161470","ActivationDatetime": "2025-03-26T02:03:41","PlanCode": 999,"SIM": null,"PUK": null,"PIN": null,"Password": "test@333","Mailbox": "UserLabel","PlanMandatory": true} ,  p_attrib_name = PlanCode ,  p_quoted = f )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "PlanCode" 
let p_attrib_name = "PlanCode" 
expression:(<procedure> length, p_attrib_name)
evaluates to 10 
let l_attrib_name_len = 10 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 70 
let l_pos = 70 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 79 
let l_pos = 79 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 80 
let l_pos = 80 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 81 
let l_pos = 81 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 82 
let l_pos = 82 
expression:(substring p_json, l_pos, 1)
evaluates to 9 
let l_char = 9 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = 999, ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to f 
expression:(<unknown op>: 87 p_quoted)
evaluates to f 
expression:(<> l_char, " ")
evaluates to t 
expression:l_pos
evaluates to 82 
let l_attrib_start_pos = 82 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 83 
let l_pos = 83 
expression:(substring p_json, l_pos, 1)
evaluates to 9 
let l_char = 9 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 84 
let l_pos = 84 
expression:(substring p_json, l_pos, 1)
evaluates to 9 
let l_char = 9 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 85 
let l_pos = 85 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to t 
expression:(substring p_json, l_attrib_start_pos, (- l_pos, l_attrib_start_pos))
evaluates to 999 
let l_attrib_str = 999 

execute function informix.equal[procid=-114] (   = 999 ,    = NULL )
expression:(= (<procedure> upper, TRIM ( BOTH ' ' FROM l_attrib_str)), "NULL")
evaluates to f 
expression:TRIM ( BOTH ' ' FROM l_attrib_str)
evaluates to 999 
procedure sf_json_get_attrib returns 999 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "f")
evaluates to 999 
let l_property_value = 999 

execute function informix.equal[procid=-114] (   = 999 ,    =  )
expression:(= l_property_value, "")
evaluates to f 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to t 
expression:(in p_data_type, "INTEGER")
evaluates to f 
expression:(in p_data_type, "DECIMAL", "NUMBER")
evaluates to t 
expression:l_property_value
evaluates to 999.0000000000 
let l_decimal = 999.0000000000 
expression:(not-null p_validations)
evaluates to t 
let l_min_value = f 
let l_max_value = f 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns NOT_NULL 
expression:(= l_value, "MIN_VALUE")
evaluates to f 
expression:(<unknown op>: 87 l_min_value)
evaluates to f 
expression:(= l_value, "MAX_VALUE")
evaluates to f 
expression:(<unknown op>: 87 l_max_value)
evaluates to f 
select cursor iteration.
end cursor
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to 999 
procedure sf_get_property returns 999 

expression:(<procedure> sf_get_property, p_request_body, "PlanCode", "NUMBER", "t", 24267,  LIST{"NOT_NULL"})
evaluates to 999 
let p_plan_code = 999 

execute function informix.sf_get_property[procid=9798] ( p_json = {"ServiceId": "PD161470","ActivationDatetime": "2025-03-26T02:03:41","PlanCode": 999,"SIM": null,"PUK": null,"PIN": null,"Password": "test@333","Mailbox": "UserLabel","PlanMandatory": true} ,  p_name = SIM ,  p_data_type = STRING ,  p_raise_exception = t ,  p_errorcode = 24268 ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"ServiceId": "PD161470","ActivationDatetime": "2025-03-26T02:03:41","PlanCode": 999,"SIM": null,"PUK": null,"PIN": null,"Password": "test@333","Mailbox": "UserLabel","PlanMandatory": true} ,  p_attrib_name = SIM ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "SIM" 
let p_attrib_name = "SIM" 
expression:(<procedure> length, p_attrib_name)
evaluates to 5 
let l_attrib_name_len = 5 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 86 
let l_pos = 86 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 90 
let l_pos = 90 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 91 
let l_pos = 91 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 92 
let l_pos = 92 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 93 
let l_pos = 93 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = NULL ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to NULL. 
procedure sf_get_property returns NULL. 

expression:(<procedure> sf_get_property, p_request_body, "SIM", "STRING", "t", 24268)
evaluates to NULL. 
let p_sim_num = NULL. 

execute function informix.sf_get_property[procid=9798] ( p_json = {"ServiceId": "PD161470","ActivationDatetime": "2025-03-26T02:03:41","PlanCode": 999,"SIM": null,"PUK": null,"PIN": null,"Password": "test@333","Mailbox": "UserLabel","PlanMandatory": true} ,  p_name = PUK ,  p_data_type = STRING ,  p_raise_exception = t ,  p_errorcode = 24269 ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"ServiceId": "PD161470","ActivationDatetime": "2025-03-26T02:03:41","PlanCode": 999,"SIM": null,"PUK": null,"PIN": null,"Password": "test@333","Mailbox": "UserLabel","PlanMandatory": true} ,  p_attrib_name = PUK ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "PUK" 
let p_attrib_name = "PUK" 
expression:(<procedure> length, p_attrib_name)
evaluates to 5 
let l_attrib_name_len = 5 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 98 
let l_pos = 98 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 102 
let l_pos = 102 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 103 
let l_pos = 103 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 104 
let l_pos = 104 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 105 
let l_pos = 105 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = NULL ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to NULL. 
procedure sf_get_property returns NULL. 

expression:(<procedure> sf_get_property, p_request_body, "PUK", "STRING", "t", 24269)
evaluates to NULL. 
let p_puk = NULL. 

execute function informix.sf_get_property[procid=9798] ( p_json = {"ServiceId": "PD161470","ActivationDatetime": "2025-03-26T02:03:41","PlanCode": 999,"SIM": null,"PUK": null,"PIN": null,"Password": "test@333","Mailbox": "UserLabel","PlanMandatory": true} ,  p_name = PIN ,  p_data_type = STRING ,  p_raise_exception = t ,  p_errorcode = 24294 ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"ServiceId": "PD161470","ActivationDatetime": "2025-03-26T02:03:41","PlanCode": 999,"SIM": null,"PUK": null,"PIN": null,"Password": "test@333","Mailbox": "UserLabel","PlanMandatory": true} ,  p_attrib_name = PIN ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "PIN" 
let p_attrib_name = "PIN" 
expression:(<procedure> length, p_attrib_name)
evaluates to 5 
let l_attrib_name_len = 5 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 110 
let l_pos = 110 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 114 
let l_pos = 114 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 115 
let l_pos = 115 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 116 
let l_pos = 116 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 117 
let l_pos = 117 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = NULL ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to NULL. 
procedure sf_get_property returns NULL. 

expression:(<procedure> sf_get_property, p_request_body, "PIN", "STRING", "t", 24294)
evaluates to NULL. 
let p_pin = NULL. 

execute function informix.sf_get_property[procid=9798] ( p_json = {"ServiceId": "PD161470","ActivationDatetime": "2025-03-26T02:03:41","PlanCode": 999,"SIM": null,"PUK": null,"PIN": null,"Password": "test@333","Mailbox": "UserLabel","PlanMandatory": true} ,  p_name = Password ,  p_data_type = STRING ,  p_raise_exception = t ,  p_errorcode = 24021 ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"ServiceId": "PD161470","ActivationDatetime": "2025-03-26T02:03:41","PlanCode": 999,"SIM": null,"PUK": null,"PIN": null,"Password": "test@333","Mailbox": "UserLabel","PlanMandatory": true} ,  p_attrib_name = Password ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "Password" 
let p_attrib_name = "Password" 
expression:(<procedure> length, p_attrib_name)
evaluates to 10 
let l_attrib_name_len = 10 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 122 
let l_pos = 122 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 131 
let l_pos = 131 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 132 
let l_pos = 132 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 133 
let l_pos = 133 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 134 
let l_pos = 134 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = "TES ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to f 
expression:(<unknown op>: 87 p_quoted)
evaluates to t 
expression:(= l_char, """)
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 135 
let l_attrib_start_pos = 135 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 135 
let l_pos = 135 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 136 
let l_pos = 136 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 137 
let l_pos = 137 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 138 
let l_pos = 138 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 139 
let l_pos = 139 
expression:(substring p_json, l_pos, 1)
evaluates to @ 
let l_char = @ 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 140 
let l_pos = 140 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 141 
let l_pos = 141 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 142 
let l_pos = 142 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 143 
let l_pos = 143 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to t 
expression:(null l_attrib_str)
evaluates to t 
expression:(substring p_json, l_attrib_start_pos, (- l_pos, l_attrib_start_pos))
evaluates to test@333 
let l_attrib_str = test@333 
expression:TRIM ( BOTH ' ' FROM l_attrib_str)
evaluates to test@333 
procedure sf_json_get_attrib returns test@333 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to test@333 
let l_property_value = test@333 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 

execute function informix.equal[procid=-114] (   = test@333 ,    =  )
expression:(= l_property_value, "")
evaluates to f 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to test@333 
procedure sf_get_property returns test@333 

expression:(<procedure> sf_get_property, p_request_body, "Password", "STRING", "t", 24021)
evaluates to test@333                         
let p_enq_password = test@333                         

execute function informix.sf_get_property[procid=9798] ( p_json = {"ServiceId": "PD161470","ActivationDatetime": "2025-03-26T02:03:41","PlanCode": 999,"SIM": null,"PUK": null,"PIN": null,"Password": "test@333","Mailbox": "UserLabel","PlanMandatory": true} ,  p_name = Mailbox ,  p_data_type = STRING ,  p_raise_exception = t ,  p_errorcode = 24270 ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"ServiceId": "PD161470","ActivationDatetime": "2025-03-26T02:03:41","PlanCode": 999,"SIM": null,"PUK": null,"PIN": null,"Password": "test@333","Mailbox": "UserLabel","PlanMandatory": true} ,  p_attrib_name = Mailbox ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "Mailbox" 
let p_attrib_name = "Mailbox" 
expression:(<procedure> length, p_attrib_name)
evaluates to 9 
let l_attrib_name_len = 9 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 145 
let l_pos = 145 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 153 
let l_pos = 153 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 154 
let l_pos = 154 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 155 
let l_pos = 155 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 156 
let l_pos = 156 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = "USE ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to f 
expression:(<unknown op>: 87 p_quoted)
evaluates to t 
expression:(= l_char, """)
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 157 
let l_attrib_start_pos = 157 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 157 
let l_pos = 157 
expression:(substring p_json, l_pos, 1)
evaluates to U 
let l_char = U 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 158 
let l_pos = 158 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 159 
let l_pos = 159 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 160 
let l_pos = 160 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 161 
let l_pos = 161 
expression:(substring p_json, l_pos, 1)
evaluates to L 
let l_char = L 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 162 
let l_pos = 162 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 163 
let l_pos = 163 
expression:(substring p_json, l_pos, 1)
evaluates to b 
let l_char = b 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 164 
let l_pos = 164 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 165 
let l_pos = 165 
expression:(substring p_json, l_pos, 1)
evaluates to l 
let l_char = l 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 166 
let l_pos = 166 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to t 
expression:(null l_attrib_str)
evaluates to t 
expression:(substring p_json, l_attrib_start_pos, (- l_pos, l_attrib_start_pos))
evaluates to UserLabel 
let l_attrib_str = UserLabel 
expression:TRIM ( BOTH ' ' FROM l_attrib_str)
evaluates to UserLabel 
procedure sf_json_get_attrib returns UserLabel 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to UserLabel 
let l_property_value = UserLabel 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 

execute function informix.equal[procid=-114] (   = UserLabel ,    =  )
expression:(= l_property_value, "")
evaluates to f 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to UserLabel 
procedure sf_get_property returns UserLabel 

expression:(<procedure> sf_get_property, p_request_body, "Mailbox", "STRING", "t", 24270)
evaluates to UserLabel  
let p_mailbox_num = UserLabel  

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"ServiceId": "PD161470","ActivationDatetime": "2025-03-26T02:03:41","PlanCode": 999,"SIM": null,"PUK": null,"PIN": null,"Password": "test@333","Mailbox": "UserLabel","PlanMandatory": true} ,  p_name = PlanMandatory ,  p_data_type = BOOLEAN_YN ,  p_raise_exception = t ,  p_errorcode = 24271 ,  p_validations = LIST{'DEFAULT','Y'} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to f 
expression:(= p_data_type, "BOOLEAN")
evaluates to f 
expression:(= p_data_type, "BOOLEAN_YN")
evaluates to t 

execute function informix.sf_json_get_attrib_bool_yn[procid=9541] ( p_json = {"ServiceId": "PD161470","ActivationDatetime": "2025-03-26T02:03:41","PlanCode": 999,"SIM": null,"PUK": null,"PIN": null,"Password": "test@333","Mailbox": "UserLabel","PlanMandatory": true} ,  p_attrib_name = PlanMandatory ,  p_raise_exception = t ,  p_errorcode = 24271 )
default value  p_raise_exception = t
default value  p_errorcode = 0
set_state: owner is informix - utype = 'D'
execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"ServiceId": "PD161470","ActivationDatetime": "2025-03-26T02:03:41","PlanCode": 999,"SIM": null,"PUK": null,"PIN": null,"Password": "test@333","Mailbox": "UserLabel","PlanMandatory": true} ,  p_attrib_name = PlanMandatory ,  p_quoted = f )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "PlanMandatory" 
let p_attrib_name = "PlanMandatory" 
expression:(<procedure> length, p_attrib_name)
evaluates to 15 
let l_attrib_name_len = 15 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 168 
let l_pos = 168 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 182 
let l_pos = 182 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 183 
let l_pos = 183 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 184 
let l_pos = 184 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 185 
let l_pos = 185 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = TRUE ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to f 
expression:(<unknown op>: 87 p_quoted)
evaluates to f 
expression:(<> l_char, " ")
evaluates to t 
expression:l_pos
evaluates to 185 
let l_attrib_start_pos = 185 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 186 
let l_pos = 186 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 187 
let l_pos = 187 
expression:(substring p_json, l_pos, 1)
evaluates to u 
let l_char = u 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 188 
let l_pos = 188 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 189 
let l_pos = 189 
expression:(substring p_json, l_pos, 1)
evaluates to } 
let l_char = } 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to t 
expression:(substring p_json, l_attrib_start_pos, (- l_pos, l_attrib_start_pos))
evaluates to true 
let l_attrib_str = true 

execute function informix.equal[procid=-114] (   = TRUE ,    = NULL )
expression:(= (<procedure> upper, TRIM ( BOTH ' ' FROM l_attrib_str)), "NULL")
evaluates to f 
expression:TRIM ( BOTH ' ' FROM l_attrib_str)
evaluates to true 
procedure sf_json_get_attrib returns true 

expression:(<procedure> sf_json_get_attrib, p_json, p_attrib_name, "f")
evaluates to true 
let l_attrib_str = true 
expression:(null l_attrib_str)
evaluates to f 

execute function informix.equal[procid=-114] (   = TRUE ,    = TRUE )
expression:(= (<procedure> upper, TRIM ( BOTH ' ' FROM l_attrib_str)), "TRUE")
evaluates to t 
procedure sf_json_get_attrib_bool_yn returns Y 

expression:(<procedure> sf_json_get_attrib_bool_yn, p_json, p_name, "t", p_errorcode)
evaluates to Y 
let l_property_value = Y 

execute function informix.equal[procid=-114] (   = Y ,    =  )
expression:(= l_property_value, "")
evaluates to f 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to Y 
procedure sf_get_property returns Y 

expression:(<procedure> sf_get_property, p_request_body, "PlanMandatory", "BOOLEAN_YN", "t", 24271,  LIST{"DEFAULT", "Y"})
evaluates to Y 
let p_plan_mandatory = Y 
expression:
  (select attrnarr
    from srvctypecnfg
    where (and (= attrname, "SIM"), (= srvctypecode, "ALL")))
evaluates to NULL. ; 
let l_sim_narr = NULL. 
expression:(nvl l_sim_narr, "SIM")
evaluates to SIM 
let l_sim_narr = SIM 
expression:(null p_sim_num)
evaluates to t 
let l_new_sim_usage = N 
let l_count = 0 
start select cursor.
select nt_connected, nt_cn_ref, mailbox_num, enq_password, last_updated
  from nt_connection
  where (and (= phone_num, p_phone_num), (>= nt_disconnected, p_connect_dt))
  order by nt_connected
select cursor iteration.
end cursor
expression:(> l_count, 1)
evaluates to f 
expression:(= l_count, 1)
evaluates to f 
expression:p_connect_dt
evaluates to 2025-03-26 02:03:41 
let l_nt_connected = 2025-03-26 02:03:41 

execute function informix.sint_connection[procid=2746] ( p_nt_cn_ref = 0 ,  p_phone_num = PD161470 ,  p_nt_connected = 2025-03-26 02:03:41 ,  p_nt_disconnected = 9999-01-01 00:00:00 ,  p_enq_password = test@333                         ,  p_mailbox_num = UserLabel  ,  tran_flg = N )
default value  p_nt_cn_ref = 0
default value  p_mailbox_num = NULL.
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 

insert into nt_connection(nt_cn_ref, phone_num, nt_connected, nt_disconnected, enq_password, mailbox_num)
  values (p_nt_cn_ref, p_phone_num, p_nt_connected, p_nt_disconnected, p_enq_password, p_mailbox_num);

before actions:

end before actions

for each row actions: 

end for each row actions

after actions:

end after actions
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
let return_status = 0 
expression:(dbinfo-sqlca.sqlerrd1 )
evaluates to 168093 
let ser_num = 168093 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
expression:ser_num
evaluates to 168093 
expression:return_status
evaluates to 0 
procedure sint_connection returns 0 , 168093 

expression:(<procedure> sint_connection, 0 as p_nt_cn_ref, p_phone_num as p_phone_num, l_nt_connected as p_nt_connected, "9999-01-01 00:00:00" as p_nt_disconnected, p_enq_password as p_enq_password, p_mailbox_num as p_mailbox_num, "N" as tran_flg)
evaluates to 168093 ; 0 ; 
let l_return = 0 
let l_nt_cn_ref = 168093 

execute function informix.sint_cn_ref[procid=1255] ( p_nt_cn_ref = 168093 ,  p_phone_num = PD161470 ,  p_nt_connected = 2025-03-26 02:03:41 ,  tran_flg = N )
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 

insert into nt_cn_ref(nt_cn_ref, phone_num, nt_connected)
  values (p_nt_cn_ref, p_phone_num, p_nt_connected);

before actions:

end before actions

for each row actions: 

end for each row actions

after actions:

end after actions
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
let return_status = 0 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
expression:return_status
evaluates to 0 
procedure sint_cn_ref returns 0 

expression:(<procedure> sint_cn_ref, l_nt_cn_ref as p_nt_cn_ref, p_phone_num as p_phone_num, l_nt_connected as p_nt_connected, "N" as tran_flg)
evaluates to 0 
let l_return = 0 
let l_new_nt_cn_plan = Y 
expression:(= l_new_nt_cn_plan, "Y")
evaluates to t 
expression:p_connect_dt
evaluates to 2025-03-26 02:03:41 
let l_nt_plan_start = 2025-03-26 02:03:41 

execute function informix.sint_cn_plan[procid=2559] ( p_nt_cn_ref = 168093 ,  p_plan_code = 999 ,  p_nt_plan_start = 2025-03-26 02:03:41 ,  p_nt_connected = 2025-03-26 02:03:41 ,  p_phone_num = PD161470 ,  p_nt_plan_stop = 9999-01-01 00:00:00 ,  tran_flg = N )
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 

insert into nt_cn_plan(nt_cn_ref, plan_code, nt_plan_start, nt_connected, phone_num, nt_plan_stop)
  values (p_nt_cn_ref, p_plan_code, p_nt_plan_start, p_nt_connected, p_phone_num, p_nt_plan_stop);

before actions:

end before actions

for each row actions: 

end for each row actions

after actions:

end after actions
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
let return_status = 0 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
expression:return_status
evaluates to 0 
procedure sint_cn_plan returns 0 

expression:(<procedure> sint_cn_plan, p_phone_num as p_phone_num, l_nt_connected as p_nt_connected, l_nt_cn_ref as p_nt_cn_ref, p_plan_code as p_plan_code, l_nt_plan_start as p_nt_plan_start, "9999-01-01 00:00:00" as p_nt_plan_stop, "N" as tran_flg)
evaluates to 0 
let l_return = 0 
expression:(= l_new_sim_usage, "Y")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 

execute function informix.sf_json_attrib[procid=9095] ( p_name = Id ,  p_value = 168093 ,  p_type = INTEGER ,  p_first = t ,  p_last = f ,  p_escape = t )
default value  p_type = STRING
default value  p_first = f
default value  p_last = f
default value  p_escape = t
set_state: owner is informix - utype = 'D'expression:(<procedure> chr, 9)
evaluates to 	 
let l_ascii = 	 
let l_json =  
expression:(or (or (= (<procedure> upper, p_type), "STRING"), (= (<procedure> upper, p_type), "DATETIME")), (= (<procedure> upper, p_type), "DATE"))
evaluates to f 
expression:(or (= (<procedure> upper, p_type), "NUMBER"), (= (<procedure> upper, p_type), "INTEGER"))
evaluates to t 
expression:(null p_value)
evaluates to f 
expression:(|| (|| (|| (|| TRIM ( BOTH ' ' FROM l_json), """), TRIM ( BOTH ' ' FROM p_name)), "": "), p_value)
evaluates to "Id": 168093 
let l_json = "Id": 168093 
expression:(not (<unknown op>: 87 p_last))
evaluates to t 
expression:(|| TRIM ( BOTH ' ' FROM l_json), ",")
evaluates to "Id": 168093, 
let l_json = "Id": 168093, 
expression:(<unknown op>: 87 p_first)
evaluates to t 
expression:(|| "{", TRIM ( BOTH ' ' FROM l_json))
evaluates to {"Id": 168093, 
let l_json = {"Id": 168093, 
expression:TRIM ( BOTH ' ' FROM l_json)
evaluates to {"Id": 168093, 
procedure sf_json_attrib returns {"Id": 168093, 


execute function informix.sf_json_attrib[procid=9095] ( p_name = NTConnected ,  p_value = 2025-03-26 02:03:41 ,  p_type = DATETIME ,  p_first = f ,  p_last = f ,  p_escape = t )
default value  p_type = STRING
default value  p_first = f
default value  p_last = f
default value  p_escape = t
set_state: owner is informix - utype = 'D'expression:(<procedure> chr, 9)
evaluates to 	 
let l_ascii = 	 
let l_json =  
expression:(or (or (= (<procedure> upper, p_type), "STRING"), (= (<procedure> upper, p_type), "DATETIME")), (= (<procedure> upper, p_type), "DATE"))
evaluates to t 
expression:(null p_value)
evaluates to f 
expression:(<unknown op>: 87 p_escape)
evaluates to t 
expression:(= (<procedure> upper, p_type), "STRING")
evaluates to f 
expression:(= (<procedure> upper, p_type), "STRING")
evaluates to f 
expression:(= (<procedure> upper, p_type), "STRING")
evaluates to f 
expression:(= (<procedure> upper, p_type), "DATETIME")
evaluates to t 
expression:(<procedure> replace, p_value, " ", "T")
evaluates to 2025-03-26T02:03:41 
let p_value = 2025-03-26T02:03:41 
expression:(|| (|| (|| (|| (|| TRIM ( BOTH ' ' FROM l_json), """), TRIM ( BOTH ' ' FROM p_name)), "": ""), TRIM ( BOTH ' ' FROM p_value)), """)
evaluates to "NTConnected": "2025-03-26T02:03:41" 
let l_json = "NTConnected": "2025-03-26T02:03:41" 
expression:(not (<unknown op>: 87 p_last))
evaluates to t 
expression:(|| TRIM ( BOTH ' ' FROM l_json), ",")
evaluates to "NTConnected": "2025-03-26T02:03:41", 
let l_json = "NTConnected": "2025-03-26T02:03:41", 
expression:(<unknown op>: 87 p_first)
evaluates to f 
expression:TRIM ( BOTH ' ' FROM l_json)
evaluates to "NTConnected": "2025-03-26T02:03:41", 
procedure sf_json_attrib returns "NTConnected": "2025-03-26T02:03:41", 


execute function informix.sf_json_attrib[procid=9095] ( p_name = NTPlanStart ,  p_value = 2025-03-26 02:03:41 ,  p_type = DATETIME ,  p_first = f ,  p_last = f ,  p_escape = t )
default value  p_type = STRING
default value  p_first = f
default value  p_last = f
default value  p_escape = t
set_state: owner is informix - utype = 'D'expression:(<procedure> chr, 9)
evaluates to 	 
let l_ascii = 	 
let l_json =  
expression:(or (or (= (<procedure> upper, p_type), "STRING"), (= (<procedure> upper, p_type), "DATETIME")), (= (<procedure> upper, p_type), "DATE"))
evaluates to t 
expression:(null p_value)
evaluates to f 
expression:(<unknown op>: 87 p_escape)
evaluates to t 
expression:(= (<procedure> upper, p_type), "STRING")
evaluates to f 
expression:(= (<procedure> upper, p_type), "STRING")
evaluates to f 
expression:(= (<procedure> upper, p_type), "STRING")
evaluates to f 
expression:(= (<procedure> upper, p_type), "DATETIME")
evaluates to t 
expression:(<procedure> replace, p_value, " ", "T")
evaluates to 2025-03-26T02:03:41 
let p_value = 2025-03-26T02:03:41 
expression:(|| (|| (|| (|| (|| TRIM ( BOTH ' ' FROM l_json), """), TRIM ( BOTH ' ' FROM p_name)), "": ""), TRIM ( BOTH ' ' FROM p_value)), """)
evaluates to "NTPlanStart": "2025-03-26T02:03:41" 
let l_json = "NTPlanStart": "2025-03-26T02:03:41" 
expression:(not (<unknown op>: 87 p_last))
evaluates to t 
expression:(|| TRIM ( BOTH ' ' FROM l_json), ",")
evaluates to "NTPlanStart": "2025-03-26T02:03:41", 
let l_json = "NTPlanStart": "2025-03-26T02:03:41", 
expression:(<unknown op>: 87 p_first)
evaluates to f 
expression:TRIM ( BOTH ' ' FROM l_json)
evaluates to "NTPlanStart": "2025-03-26T02:03:41", 
procedure sf_json_attrib returns "NTPlanStart": "2025-03-26T02:03:41", 


execute function informix.sf_json_attrib[procid=9095] ( p_name = SIMId ,  p_value = NULL. ,  p_type = INTEGER ,  p_first = f ,  p_last = f ,  p_escape = t )
default value  p_type = STRING
default value  p_first = f
default value  p_last = f
default value  p_escape = t
set_state: owner is informix - utype = 'D'expression:(<procedure> chr, 9)
evaluates to 	 
let l_ascii = 	 
let l_json =  
expression:(or (or (= (<procedure> upper, p_type), "STRING"), (= (<procedure> upper, p_type), "DATETIME")), (= (<procedure> upper, p_type), "DATE"))
evaluates to f 
expression:(or (= (<procedure> upper, p_type), "NUMBER"), (= (<procedure> upper, p_type), "INTEGER"))
evaluates to t 
expression:(null p_value)
evaluates to t 
expression:(|| (|| (|| TRIM ( BOTH ' ' FROM l_json), """), TRIM ( BOTH ' ' FROM p_name)), "": null")
evaluates to "SIMId": null 
let l_json = "SIMId": null 
expression:(not (<unknown op>: 87 p_last))
evaluates to t 
expression:(|| TRIM ( BOTH ' ' FROM l_json), ",")
evaluates to "SIMId": null, 
let l_json = "SIMId": null, 
expression:(<unknown op>: 87 p_first)
evaluates to f 
expression:TRIM ( BOTH ' ' FROM l_json)
evaluates to "SIMId": null, 
procedure sf_json_attrib returns "SIMId": null, 


execute function informix.sf_json_attrib[procid=9095] ( p_name = SIMLinkStart ,  p_value = NULL. ,  p_type = DATETIME ,  p_first = f ,  p_last = t ,  p_escape = t )
default value  p_type = STRING
default value  p_first = f
default value  p_last = f
default value  p_escape = t
set_state: owner is informix - utype = 'D'expression:(<procedure> chr, 9)
evaluates to 	 
let l_ascii = 	 
let l_json =  
expression:(or (or (= (<procedure> upper, p_type), "STRING"), (= (<procedure> upper, p_type), "DATETIME")), (= (<procedure> upper, p_type), "DATE"))
evaluates to t 
expression:(null p_value)
evaluates to t 
expression:(|| (|| (|| TRIM ( BOTH ' ' FROM l_json), """), TRIM ( BOTH ' ' FROM p_name)), "": null")
evaluates to "SIMLinkStart": null 
let l_json = "SIMLinkStart": null 
expression:(not (<unknown op>: 87 p_last))
evaluates to f 
expression:(|| TRIM ( BOTH ' ' FROM l_json), "}")
evaluates to "SIMLinkStart": null} 
let l_json = "SIMLinkStart": null} 
expression:(<unknown op>: 87 p_first)
evaluates to f 
expression:TRIM ( BOTH ' ' FROM l_json)
evaluates to "SIMLinkStart": null} 
procedure sf_json_attrib returns "SIMLinkStart": null} 

expression:(|| (|| (|| (|| (<procedure> sf_json_attrib, "Id", l_nt_cn_ref, "INTEGER", "t"), (<procedure> sf_json_attrib, "NTConnected", l_nt_connected, "DATETIME")), (<procedure> sf_json_attrib, "NTPlanStart", l_nt_plan_start, "DATETIME")), (<procedure> sf_json_attrib, "SIMId", l_sim_id, "INTEGER")), (<procedure> sf_json_attrib, "SIMLinkStart", l_sim_link_start, "DATETIME", "f", "t"))
evaluates to {"Id": 168093,"NTConnected": "2025-03-26T02:03:41","NTPlanStart": "2025-03-26T02:03:41","SIMId": null,"SIMLinkStart": null} 
let l_json = {"Id": 168093,"NTConnected": "2025-03-26T02:03:41","NTPlanStart": "2025-03-26T02:03:41","SIMId": null,"SIMLinkStart": null} 
expression:l_json
evaluates to {"Id": 168093,"NTConnected": "2025-03-26T02:03:41","NTPlanStart": "2025-03-26T02:03:41","SIMId": null,"SIMLinkStart": null} 
procedure sp_new_nt_cn_api returns 201 , {"Id": 168093,"NTConnected": "2025-03-26T02:03:41","NTPlanStart": "2025-03-26T02:03:41","SIMId": null,"SIMLinkStart": null} , NULL. , NULL. 

expression:(<procedure> sp_new_nt_cn_api, l_request_body as p_request_body, p_user_code as p_user_code, p_role_narr as p_role_narr, p_operation_id as p_operation_id, "N" as tran_flg, trace_flg as trace_flg)
evaluates to NULL. ; NULL. ; {"Id": 168093,"NTConnected": "2025-03-26T02:03:41","NTPlanStart": "2025-03-26T02:03:41","SIMId": null,"SIMLinkStart": null} ; 201 ; 
let l_return = 201 
let l_json = {"Id": 168093,"NTConnected": "2025-03-26T02:03:41","NTPlanStart": "2025-03-26T02:03:41","SIMId": null,"SIMLinkStart": null} 
let l_errcode = NULL. 
let l_msg = NULL. 
expression:(<> l_return, 201)
evaluates to f 

execute function informix.sf_get_property[procid=9798] ( p_json = {"Id": 168093,"NTConnected": "2025-03-26T02:03:41","NTPlanStart": "2025-03-26T02:03:41","SIMId": null,"SIMLinkStart": null} ,  p_name = Id ,  p_data_type = INTEGER ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to f 
expression:(= p_data_type, "BOOLEAN")
evaluates to f 
expression:(= p_data_type, "BOOLEAN_YN")
evaluates to f 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"Id": 168093,"NTConnected": "2025-03-26T02:03:41","NTPlanStart": "2025-03-26T02:03:41","SIMId": null,"SIMLinkStart": null} ,  p_attrib_name = Id ,  p_quoted = f )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "Id" 
let p_attrib_name = "Id" 
expression:(<procedure> length, p_attrib_name)
evaluates to 4 
let l_attrib_name_len = 4 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 2 
let l_pos = 2 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 5 
let l_pos = 5 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 6 
let l_pos = 6 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 7 
let l_pos = 7 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 8 
let l_pos = 8 
expression:(substring p_json, l_pos, 1)
evaluates to 1 
let l_char = 1 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = 1680 ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to f 
expression:(<unknown op>: 87 p_quoted)
evaluates to f 
expression:(<> l_char, " ")
evaluates to t 
expression:l_pos
evaluates to 8 
let l_attrib_start_pos = 8 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 9 
let l_pos = 9 
expression:(substring p_json, l_pos, 1)
evaluates to 6 
let l_char = 6 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 10 
let l_pos = 10 
expression:(substring p_json, l_pos, 1)
evaluates to 8 
let l_char = 8 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 11 
let l_pos = 11 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 12 
let l_pos = 12 
expression:(substring p_json, l_pos, 1)
evaluates to 9 
let l_char = 9 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 13 
let l_pos = 13 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 14 
let l_pos = 14 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to t 
expression:(substring p_json, l_attrib_start_pos, (- l_pos, l_attrib_start_pos))
evaluates to 168093 
let l_attrib_str = 168093 

execute function informix.equal[procid=-114] (   = 168093 ,    = NULL )
expression:(= (<procedure> upper, TRIM ( BOTH ' ' FROM l_attrib_str)), "NULL")
evaluates to f 
expression:TRIM ( BOTH ' ' FROM l_attrib_str)
evaluates to 168093 
procedure sf_json_get_attrib returns 168093 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "f")
evaluates to 168093 
let l_property_value = 168093 

execute function informix.equal[procid=-114] (   = 168093 ,    =  )
expression:(= l_property_value, "")
evaluates to f 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to t 
expression:(in p_data_type, "INTEGER")
evaluates to t 
expression:l_property_value
evaluates to 168093 
let l_integer = 168093 
expression:(not-null p_validations)
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to 168093 
procedure sf_get_property returns 168093 

expression:(<procedure> sf_get_property, l_json, "Id", "INTEGER")
evaluates to 168093 
let l_nt_cn_ref = 168093 

execute function informix.sf_get_property[procid=9798] ( p_json = {"Id": 168093,"NTConnected": "2025-03-26T02:03:41","NTPlanStart": "2025-03-26T02:03:41","SIMId": null,"SIMLinkStart": null} ,  p_name = NTConnected ,  p_data_type = DATETIME ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"Id": 168093,"NTConnected": "2025-03-26T02:03:41","NTPlanStart": "2025-03-26T02:03:41","SIMId": null,"SIMLinkStart": null} ,  p_attrib_name = NTConnected ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "NTConnected" 
let p_attrib_name = "NTConnected" 
expression:(<procedure> length, p_attrib_name)
evaluates to 13 
let l_attrib_name_len = 13 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 15 
let l_pos = 15 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 27 
let l_pos = 27 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 28 
let l_pos = 28 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 29 
let l_pos = 29 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 30 
let l_pos = 30 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = "202 ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to f 
expression:(<unknown op>: 87 p_quoted)
evaluates to t 
expression:(= l_char, """)
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 31 
let l_attrib_start_pos = 31 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 31 
let l_pos = 31 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 32 
let l_pos = 32 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 33 
let l_pos = 33 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 34 
let l_pos = 34 
expression:(substring p_json, l_pos, 1)
evaluates to 5 
let l_char = 5 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 35 
let l_pos = 35 
expression:(substring p_json, l_pos, 1)
evaluates to - 
let l_char = - 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 36 
let l_pos = 36 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 37 
let l_pos = 37 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 38 
let l_pos = 38 
expression:(substring p_json, l_pos, 1)
evaluates to - 
let l_char = - 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 39 
let l_pos = 39 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 40 
let l_pos = 40 
expression:(substring p_json, l_pos, 1)
evaluates to 6 
let l_char = 6 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 41 
let l_pos = 41 
expression:(substring p_json, l_pos, 1)
evaluates to T 
let l_char = T 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 42 
let l_pos = 42 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 43 
let l_pos = 43 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 44 
let l_pos = 44 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 45 
let l_pos = 45 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 46 
let l_pos = 46 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 47 
let l_pos = 47 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 48 
let l_pos = 48 
expression:(substring p_json, l_pos, 1)
evaluates to 4 
let l_char = 4 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 49 
let l_pos = 49 
expression:(substring p_json, l_pos, 1)
evaluates to 1 
let l_char = 1 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 50 
let l_pos = 50 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to t 
expression:(null l_attrib_str)
evaluates to t 
expression:(substring p_json, l_attrib_start_pos, (- l_pos, l_attrib_start_pos))
evaluates to 2025-03-26T02:03:41 
let l_attrib_str = 2025-03-26T02:03:41 
expression:TRIM ( BOTH ' ' FROM l_attrib_str)
evaluates to 2025-03-26T02:03:41 
procedure sf_json_get_attrib returns 2025-03-26T02:03:41 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to 2025-03-26T02:03:41 
let l_property_value = 2025-03-26T02:03:41 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to t 
expression:(> (<procedure> length, l_property_value), 19)
evaluates to f 
expression:(<procedure> replace, l_property_value, "T", " ")
evaluates to 2025-03-26 02:03:41 
let l_dt = 2025-03-26 02:03:41 
expression:(in p_data_type, "DATE")
evaluates to f 
expression:l_dt
evaluates to 2025-03-26 02:03:41 
let l_property_value = 2025-03-26 02:03:41 

execute function informix.equal[procid=-114] (   = 2025-03-26 02:03:41 ,    =  )
expression:(= l_property_value, "")
evaluates to f 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to 2025-03-26 02:03:41 
procedure sf_get_property returns 2025-03-26 02:03:41 

expression:(<procedure> sf_get_property, l_json, "NTConnected", "DATETIME")
evaluates to 2025-03-26 02:03:41 
let l_nt_connected = 2025-03-26 02:03:41 

execute function informix.sf_get_property[procid=9798] ( p_json = {"Id": 168093,"NTConnected": "2025-03-26T02:03:41","NTPlanStart": "2025-03-26T02:03:41","SIMId": null,"SIMLinkStart": null} ,  p_name = NTPlanStart ,  p_data_type = DATETIME ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"Id": 168093,"NTConnected": "2025-03-26T02:03:41","NTPlanStart": "2025-03-26T02:03:41","SIMId": null,"SIMLinkStart": null} ,  p_attrib_name = NTPlanStart ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "NTPlanStart" 
let p_attrib_name = "NTPlanStart" 
expression:(<procedure> length, p_attrib_name)
evaluates to 13 
let l_attrib_name_len = 13 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 52 
let l_pos = 52 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 64 
let l_pos = 64 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 65 
let l_pos = 65 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 66 
let l_pos = 66 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 67 
let l_pos = 67 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = "202 ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to f 
expression:(<unknown op>: 87 p_quoted)
evaluates to t 
expression:(= l_char, """)
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 68 
let l_attrib_start_pos = 68 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 68 
let l_pos = 68 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 69 
let l_pos = 69 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 70 
let l_pos = 70 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 71 
let l_pos = 71 
expression:(substring p_json, l_pos, 1)
evaluates to 5 
let l_char = 5 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 72 
let l_pos = 72 
expression:(substring p_json, l_pos, 1)
evaluates to - 
let l_char = - 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 73 
let l_pos = 73 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 74 
let l_pos = 74 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 75 
let l_pos = 75 
expression:(substring p_json, l_pos, 1)
evaluates to - 
let l_char = - 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 76 
let l_pos = 76 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 77 
let l_pos = 77 
expression:(substring p_json, l_pos, 1)
evaluates to 6 
let l_char = 6 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 78 
let l_pos = 78 
expression:(substring p_json, l_pos, 1)
evaluates to T 
let l_char = T 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 79 
let l_pos = 79 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 80 
let l_pos = 80 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 81 
let l_pos = 81 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 82 
let l_pos = 82 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 83 
let l_pos = 83 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 84 
let l_pos = 84 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 85 
let l_pos = 85 
expression:(substring p_json, l_pos, 1)
evaluates to 4 
let l_char = 4 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 86 
let l_pos = 86 
expression:(substring p_json, l_pos, 1)
evaluates to 1 
let l_char = 1 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 87 
let l_pos = 87 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to t 
expression:(null l_attrib_str)
evaluates to t 
expression:(substring p_json, l_attrib_start_pos, (- l_pos, l_attrib_start_pos))
evaluates to 2025-03-26T02:03:41 
let l_attrib_str = 2025-03-26T02:03:41 
expression:TRIM ( BOTH ' ' FROM l_attrib_str)
evaluates to 2025-03-26T02:03:41 
procedure sf_json_get_attrib returns 2025-03-26T02:03:41 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to 2025-03-26T02:03:41 
let l_property_value = 2025-03-26T02:03:41 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to t 
expression:(> (<procedure> length, l_property_value), 19)
evaluates to f 
expression:(<procedure> replace, l_property_value, "T", " ")
evaluates to 2025-03-26 02:03:41 
let l_dt = 2025-03-26 02:03:41 
expression:(in p_data_type, "DATE")
evaluates to f 
expression:l_dt
evaluates to 2025-03-26 02:03:41 
let l_property_value = 2025-03-26 02:03:41 

execute function informix.equal[procid=-114] (   = 2025-03-26 02:03:41 ,    =  )
expression:(= l_property_value, "")
evaluates to f 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to 2025-03-26 02:03:41 
procedure sf_get_property returns 2025-03-26 02:03:41 

expression:(<procedure> sf_get_property, l_json, "NTPlanStart", "DATETIME")
evaluates to 2025-03-26 02:03:41 
let l_nt_plan_start = 2025-03-26 02:03:41 

execute function informix.sf_get_property[procid=9798] ( p_json = {"Id": 168093,"NTConnected": "2025-03-26T02:03:41","NTPlanStart": "2025-03-26T02:03:41","SIMId": null,"SIMLinkStart": null} ,  p_name = SIMId ,  p_data_type = INTEGER ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to f 
expression:(= p_data_type, "BOOLEAN")
evaluates to f 
expression:(= p_data_type, "BOOLEAN_YN")
evaluates to f 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"Id": 168093,"NTConnected": "2025-03-26T02:03:41","NTPlanStart": "2025-03-26T02:03:41","SIMId": null,"SIMLinkStart": null} ,  p_attrib_name = SIMId ,  p_quoted = f )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "SIMId" 
let p_attrib_name = "SIMId" 
expression:(<procedure> length, p_attrib_name)
evaluates to 7 
let l_attrib_name_len = 7 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 89 
let l_pos = 89 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 95 
let l_pos = 95 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 96 
let l_pos = 96 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 97 
let l_pos = 97 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 98 
let l_pos = 98 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = NULL ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "f")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to t 
expression:(in p_data_type, "INTEGER")
evaluates to t 
expression:l_property_value
evaluates to NULL. 
let l_integer = NULL. 
expression:(not-null p_validations)
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to NULL. 
procedure sf_get_property returns NULL. 

expression:(<procedure> sf_get_property, l_json, "SIMId", "INTEGER")
evaluates to NULL. 
let l_sim_id = NULL. 

execute function informix.sf_get_property[procid=9798] ( p_json = {"Id": 168093,"NTConnected": "2025-03-26T02:03:41","NTPlanStart": "2025-03-26T02:03:41","SIMId": null,"SIMLinkStart": null} ,  p_name = SIMLinkStart ,  p_data_type = DATETIME ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"Id": 168093,"NTConnected": "2025-03-26T02:03:41","NTPlanStart": "2025-03-26T02:03:41","SIMId": null,"SIMLinkStart": null} ,  p_attrib_name = SIMLinkStart ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "SIMLinkStart" 
let p_attrib_name = "SIMLinkStart" 
expression:(<procedure> length, p_attrib_name)
evaluates to 14 
let l_attrib_name_len = 14 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 103 
let l_pos = 103 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 116 
let l_pos = 116 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 117 
let l_pos = 117 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 118 
let l_pos = 118 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 119 
let l_pos = 119 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = NULL ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to t 
expression:(> (<procedure> length, l_property_value), 19)
evaluates to NULL. 
expression:(<procedure> replace, l_property_value, "T", " ")
evaluates to NULL. 
let l_dt = NULL. 
expression:(in p_data_type, "DATE")
evaluates to f 
expression:l_dt
evaluates to NULL. 
let l_property_value = NULL. 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to NULL. 
procedure sf_get_property returns NULL. 

expression:(<procedure> sf_get_property, l_json, "SIMLinkStart", "DATETIME")
evaluates to NULL. 
let l_sim_link_start = NULL. 

execute function informix.ss_flex_code[procid=1382] ( p_sys_table = sp_cn_status ,  p_sys_hard_group = IDS ,  p_sys_hard_code = IDS ,  p_multiple_rows = N ,  p_msg = No initial despatch status defined. ,  resume_flg = Z )
default value  p_multiple_rows = N
default value  p_msg = NULL.
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(not-in resume_flg, "Y", "N", "Z")
evaluates to f 
let l_found = N 
let l_tmp_key1 = NULL. 
expression:(not-null p_msg)
evaluates to t 
expression:p_msg
evaluates to No initial despatch status defined. 
let l_msg = No initial despatch status defined. 
start select cursor.
select flex_key1, flex_key2
  from sys_code
  where (and (and (= sys_table, p_sys_table), (or (= sys_hard_group, p_sys_hard_group), (null p_sys_hard_group))), (or (= sys_hard_code, p_sys_hard_code), (null p_sys_hard_code)))
  order by flex_key2
select cursor iteration.
select cursor returns IDS , IDS 
expression:(= l_found, "N")
evaluates to t 
expression:l_flex_key1
evaluates to IDS 
let l_tmp_key1 = IDS 
expression:l_flex_key2
evaluates to IDS 
let l_tmp_key2 = IDS 
let l_found = Y 
select cursor iteration.
end cursor
expression:(not-null l_tmp_key1)
evaluates to t 
expression:l_tmp_key2
evaluates to IDS 
expression:l_tmp_key1
evaluates to IDS 
procedure ss_flex_code returns 0 , IDS , IDS 

expression:(<procedure> ss_flex_code, "sp_cn_status" as p_sys_table, "IDS" as p_sys_hard_group, "IDS" as p_sys_hard_code, "No initial despatch status defined." as p_msg, "Z" as resume_flg)
evaluates to IDS                              ; IDS                              ; 0 ; 
let l_return = 0 
let l_sp_cn_status = IDS                              
let l_flex_key2 = IDS                              

execute function informix.sisp_connection[procid=4694] ( p_sp_cn_ref = 0 ,  p_phone_num = PD161470                                                         ,  p_sp_cn_narr = Test New Service Post Ar 1 ,  p_nt_connected = NULL. ,  p_nt_cn_ref = 168093 ,  p_srvctypecode = PID  ,  p_subscriber_code = UAT0341352 ,  p_sp_connected = 2025-03-26 02:03:41 ,  p_sp_disconnected = 2025-03-26 02:03:41 ,  p_cred_limit = 300 ,  p_cred_limit_actn = NULL. ,  p_sp_cn_status = IDS ,  p_sys_status = IDS ,  p_sp_enq_passwd = test@333                         ,  p_sp_mailbox_num = NULL. ,  p_ipnd_listed = UL ,  p_ipnd_usage_code = N ,  p_ipnd_alt_flag = F ,  p_invoice_interval = NULL. ,  tran_flg = N )
default value  p_sp_cn_ref = 0
default value  p_sp_cn_narr = NULL.
default value  p_nt_connected = NULL.
default value  p_nt_cn_ref = NULL.
default value  p_cred_limit = NULL.
default value  p_cred_limit_actn = NULL.
default value  p_sp_mailbox_num = NULL.
default value  p_ipnd_listed = UL
default value  p_ipnd_usage_code = N
default value  p_ipnd_alt_flag = F
default value  p_invoice_interval = NULL.
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 

insert into sp_connection(sp_cn_ref, phone_num, sp_cn_narr, nt_connected, nt_cn_ref, srvctypecode, subscriber_code, sp_connected, sp_disconnected, cred_limit, cred_limit_actn, sp_cn_status, sys_status, sp_enq_passwd, sp_mailbox_num, ipnd_listed, ipnd_usage_code, ipnd_alt_flag, invoice_interval)
  values (p_sp_cn_ref, p_phone_num, p_sp_cn_narr, p_nt_connected, p_nt_cn_ref, p_srvctypecode, p_subscriber_code, p_sp_connected, p_sp_disconnected, p_cred_limit, p_cred_limit_actn, p_sp_cn_status, p_sys_status, p_sp_enq_passwd, p_sp_mailbox_num, p_ipnd_listed, p_ipnd_usage_code, p_ipnd_alt_flag, p_invoice_interval);

before actions:

end before actions

execute function informix.fn_lastnine[procid=5200] ( str =  )
set_state: owner is informix - utype = 'D'expression:(substring str, (- (<procedure> length, str), 8))
evaluates to PD161470                       
procedure fn_lastnine returns PD161470                       


for each row actions: 

end for each row actions

after actions:

end after actions
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
let return_status = 0 
expression:(dbinfo-sqlca.sqlerrd1 )
evaluates to 239091 
let ser_num = 239091 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
expression:ser_num
evaluates to 239091 
expression:return_status
evaluates to 0 
procedure sisp_connection returns 0 , 239091 

expression:(<procedure> sisp_connection, 0 as p_sp_cn_ref, p_phone_num as p_phone_num, p_sp_cn_narr as p_sp_cn_narr, l_nt_cn_ref as p_nt_cn_ref,  <NULL>  as p_nt_connected, p_srvctypecode as p_srvctypecode, p_subscriber_code as p_subscriber_code, p_connect_dt as p_sp_connected, p_connect_dt as p_sp_disconnected, 300 as p_cred_limit,  <NULL>  as p_cred_limit_actn, p_enq_passwd as p_sp_enq_passwd, p_mailbox_num as p_sp_mailbox_num, l_sp_cn_status as p_sp_cn_status, l_sp_cn_status as p_sys_status, "N" as tran_flg)
evaluates to 239091 ; 0 ; 
let l_return = 0 
let p_sp_cn_ref = 239091 

execute function informix.sisp_cn_plan[procid=9525] ( p_sp_plan_ref = 0 ,  p_pkg_code = 4401 ,  p_sp_cn_ref = 239091 ,  p_option = 1 ,  p_sp_plan_start = 2025-03-26 02:03:41 ,  p_sp_plan_stop = 2025-03-26 02:03:41 ,  p_sched_ref = NULL. ,  p_sched_flags = NYP ,  p_sp_plan_ntwk_id = NULL. ,  p_fee = NULL. ,  p_last_updated = 2025-03-26 15:26:32 ,  p_updated_by = webuser ,  tran_flg = N )
default value  p_sp_plan_ref = 0
default value  p_sched_ref = NULL.
default value  p_sched_flags = NYP
default value  p_sp_plan_ntwk_id = NULL.
default value  p_fee = NULL.
default value  p_last_updated = 2025-03-26 15:26:32
default value  p_updated_by = webuser
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 

insert into sp_cn_plan(sp_plan_ref, pkg_code, sp_cn_ref, option, sp_plan_start, sp_plan_stop, sched_ref, sched_flags, sp_plan_ntwk_id, fee, last_updated, updated_by)
  values (p_sp_plan_ref, p_pkg_code, p_sp_cn_ref, p_option, p_sp_plan_start, p_sp_plan_stop, p_sched_ref, p_sched_flags, p_sp_plan_ntwk_id, p_fee, p_last_updated, p_updated_by);

before actions:

end before actions

for each row actions: 

end for each row actions

after actions:

end after actions
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
let return_status = 0 
expression:(dbinfo-sqlca.sqlerrd1 )
evaluates to 385186 
let ser_num = 385186 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
expression:ser_num
evaluates to 385186 
expression:return_status
evaluates to 0 
procedure sisp_cn_plan returns 0 , 385186 

expression:(<procedure> sisp_cn_plan, 0 as p_sp_plan_ref, p_sp_cn_ref as p_sp_cn_ref, p_sp_pkg_code as p_pkg_code, p_option as p_option, p_connect_dt as p_sp_plan_start, p_connect_dt as p_sp_plan_stop, "N" as tran_flg,  <NULL>  as p_sched_ref)
evaluates to 385186 ; 0 ; 
let l_return = 0 
let l_sp_plan_ref = 385186 

execute function informix.sp_ins_subsdisc[procid=5621] ( p_sp_plan_ref = 385186 ,  p_pkg_code = 4401 ,  p_sp_plan_start = 2025-03-26 02:03:41 ,  p_sp_plan_stop = 2025-03-26 02:03:41 ,  p_option = 1 ,  resume_flg = N ,  tran_flg = N )
default value  p_option = 0
default value  resume_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'let l_sp_cn_ref = NULL. 
expression:
  (select sp_cn_ref
    from sp_cn_plan
    where (= sp_plan_ref, p_sp_plan_ref))
evaluates to 239091 ; 
let l_sp_cn_ref = 239091 
expression:(null l_sp_cn_ref)
evaluates to f 
start select cursor.
select disc.discid, chlddiscid, dfltuseramnt
  from disc, packdisc, outer(packdiscdfltamnt)
  where (and (and (and (and (and (and (and (and (= disc.discid, packdisc.discid), (= packdisc.packdiscid, packdiscdfltamnt.packdiscid)), (= pkg_code, p_pkg_code)), (= packdiscauto, "Y")), (<= packdiscwefr, p_sp_plan_start)), (>= packdiscweto, p_sp_plan_start)), (<= packdiscdfltamnt.wefr, p_sp_plan_start)), (>= packdiscdfltamnt.weto, p_sp_plan_start)), (or (= option, p_option), (= option, 0)))
select cursor iteration.
end cursor
expression:(<> p_sp_plan_start, p_sp_plan_stop)
evaluates to f 
procedure sp_ins_subsdisc returns 0 , NULL. 

expression:(<procedure> sp_ins_subsdisc, l_sp_plan_ref as p_sp_plan_ref, p_sp_pkg_code as p_pkg_code, p_connect_dt as p_sp_plan_start, p_connect_dt as p_sp_plan_stop, p_option as p_option, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_return = 0 
let l_msg = NULL. 
expression:(> (nvl l_sim_id, 0), 0)
evaluates to f 
let l_contract_code = NULL. 
expression:
  (select contract_code
    from pkg_option
    where (and (= pkg_code, p_sp_pkg_code), (= option, p_option)))
evaluates to NULL. ; 
let l_contract_code = NULL. 
expression:(null l_contract_code)
evaluates to t 
expression:
  (select contract_code
    from package
    where (= pkg_code, p_sp_pkg_code))
evaluates to NONE ; 
let l_contract_code = NONE 
expression:(null l_contract_code)
evaluates to f 

execute function informix.sisp_cn_contract[procid=8295] ( p_spcncontract_ref = 0 ,  p_sp_cn_ref = 239091 ,  p_start_date = 2025-03-26 02:03:41 ,  p_contract_code = NONE ,  p_contract_num = NULL. ,  p_end_date = 2025-03-26 02:03:41 ,  p_salesperson = NULL. ,  p_status_id = 0 ,  p_note = NULL. ,  p_created_tm = 2025-03-26 15:26:32 ,  p_created_by = webuser ,  p_last_updated = 2025-03-26 15:26:32 ,  p_updated_by = webuser ,  tran_flg = N )
default value  p_spcncontract_ref = 0
default value  p_contract_num = NULL.
default value  p_salesperson = NULL.
default value  p_status_id = 0
default value  p_note = NULL.
default value  p_created_tm = 2025-03-26 15:26:32
default value  p_created_by = webuser
default value  p_last_updated = 2025-03-26 15:26:32
default value  p_updated_by = webuser
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 

insert into sp_cn_contract(spcncontract_ref, sp_cn_ref, start_date, contract_code, contract_num, end_date, salesperson, status_id, note, created_tm, created_by, last_updated, updated_by)
  values (p_spcncontract_ref, p_sp_cn_ref, p_start_date, p_contract_code, p_contract_num, p_end_date, p_salesperson, p_status_id, p_note, p_created_tm, p_created_by, p_last_updated, p_updated_by);

before actions:

end before actions

for each row actions: 

end for each row actions

after actions:

end after actions
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
let return_status = 0 
expression:(dbinfo-sqlca.sqlerrd1 )
evaluates to 239089 
let ser_num = 239089 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
expression:ser_num
evaluates to 239089 
expression:return_status
evaluates to 0 
procedure sisp_cn_contract returns 0 , 239089 

expression:(<procedure> sisp_cn_contract, p_sp_cn_ref as p_sp_cn_ref, l_contract_code as p_contract_code, p_connect_dt as p_start_date, p_connect_dt as p_end_date)
evaluates to 239089 ; 0 ; 
let l_return = 0 
let l_spcncontract_ref = 239089 

execute function informix.sp_apply_auto_comm[procid=7714] ( p_debtor_code = NULL. ,  p_sp_cn_ref = 239091 ,  p_autocommid = NULL. ,  p_dt = 2025-03-26 15:26:32 ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_debtor_code = NULL.
default value  p_sp_cn_ref = NULL.
default value  p_autocommid = NULL.
default value  p_dt = 2025-03-26 15:26:32
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
expression:(and (and (null p_debtor_code), (null p_sp_cn_ref)), (null p_autocommid))
evaluates to f 
let l_auto_comm_dealer_id = NULL. 
expression:(date p_dt)
evaluates to 26/03/2025 
let l_date = 26/03/2025 
expression:(not-null p_autocommid)
evaluates to f 
expression:(not-null p_sp_cn_ref)
evaluates to t 
expression:(not-null p_debtor_code)
evaluates to f 
expression:
  (select subscriber_code
    from sp_connection
    where (= sp_cn_ref, p_sp_cn_ref))
evaluates to UAT0341352 ; 
let p_debtor_code = UAT0341352 
expression:(null p_debtor_code)
evaluates to f 
expression:
  (select dealer_id
    from sp_add_info
    where (= sp_cn_ref, p_sp_cn_ref))
evaluates to NULL. ; 
let l_auto_comm_dealer_id = NULL. 
expression:(null l_auto_comm_dealer_id)
evaluates to t 
expression:
  (select dealer_id
    from contact
    where (= contact_code, p_debtor_code))
evaluates to NULL. ; 
let l_auto_comm_dealer_id = NULL. 
expression:(nvl l_auto_comm_dealer_id, "n/a")
evaluates to n/a        
let l_auto_comm_dealer_id = n/a        
expression:(= tran_flg, "Y")
evaluates to f 
let l_term_count = 0 
let l_ins_count = 0 
start select cursor.
select account.debtor_code, contact.dealer_id
  from account, contact
  where (and (= account.debtor_code, contact.contact_code), (or (= debtor_code, p_debtor_code), (null p_debtor_code)))
  order by debtor_code
select cursor iteration.
select cursor returns UAT0341352 , NULL. 
start select cursor.
select commrateid, autocommid, dealer_id, sp_cn_ref, commratewefr, commrateweto
  from commrate
  where (and (and (and (= debtor_code, l_debtor_code), (>= commrateweto, l_date)), (not-null autocommid)), (or (null p_autocommid), (= autocommid, p_autocommid)))
select cursor iteration.
end cursor
start select cursor.
select autocommid, autocommlevl, autocommcommtype, invoice_grp, sp_cl_group_code, autocommwefr, autocommweto, autocommratetype, autocommrate
  from autocomm
  where (and (and (= dealer_id, l_auto_comm_dealer_id), (between l_date, autocommwefr, autocommweto)), (or (null p_autocommid), (= autocommid, p_autocommid)))
select cursor iteration.
end cursor
select cursor iteration.
end cursor
expression:(= tran_flg, "Y")
evaluates to f 
expression:(and (= l_term_count, 0), (= l_ins_count, 0))
evaluates to t 
procedure sp_apply_auto_comm returns 100 , Nothing to do 

expression:(<procedure> sp_apply_auto_comm, p_sp_cn_ref as p_sp_cn_ref, "N" as tran_flg)
evaluates to Nothing to do ; 100 ; 
let l_return = 100 
let l_msg = Nothing to do 

execute function informix.ss_flex_code[procid=1382] ( p_sys_table = network ,  p_sys_hard_group = SET ,  p_sys_hard_code = CONNECT ,  p_multiple_rows = N ,  p_msg = NULL. ,  resume_flg = N )
default value  p_multiple_rows = N
default value  p_msg = NULL.
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(not-in resume_flg, "Y", "N", "Z")
evaluates to f 
let l_found = N 
let l_tmp_key1 = NULL. 
expression:(not-null p_msg)
evaluates to f 
expression:(|| (|| "Flex key not found: ", TRIM ( BOTH ' ' FROM p_sys_table)), " | ")
evaluates to Flex key not found: network |  
let l_msg = Flex key not found: network |  
expression:(not-null p_sys_hard_group)
evaluates to t 
expression:(|| (|| l_msg, TRIM ( BOTH ' ' FROM p_sys_hard_group)), " | ")
evaluates to Flex key not found: network | SET |  
let l_msg = Flex key not found: network | SET |  
expression:(not-null p_sys_hard_code)
evaluates to t 
expression:(|| (|| l_msg, TRIM ( BOTH ' ' FROM p_sys_hard_code)), ". ")
evaluates to Flex key not found: network | SET | CONNECT.  
let l_msg = Flex key not found: network | SET | CONNECT.  
start select cursor.
select flex_key1, flex_key2
  from sys_code
  where (and (and (= sys_table, p_sys_table), (or (= sys_hard_group, p_sys_hard_group), (null p_sys_hard_group))), (or (= sys_hard_code, p_sys_hard_code), (null p_sys_hard_code)))
  order by flex_key2
select cursor iteration.
select cursor returns X , n/a 
expression:(= l_found, "N")
evaluates to t 
expression:l_flex_key1
evaluates to X 
let l_tmp_key1 = X 
expression:l_flex_key2
evaluates to n/a 
let l_tmp_key2 = n/a 
let l_found = Y 
select cursor iteration.
end cursor
expression:(not-null l_tmp_key1)
evaluates to t 
expression:l_tmp_key2
evaluates to n/a 
expression:l_tmp_key1
evaluates to X 
procedure ss_flex_code returns 0 , X , n/a 

expression:(<procedure> ss_flex_code, "network" as p_sys_table, "SET" as p_sys_hard_group, "CONNECT" as p_sys_hard_code)
evaluates to n/a                              ; X                                ; 0 ; 
let l_return = 0 
let l_flex_key1 = X                                
let l_flex_key2 = n/a                              
expression:(= l_return, 0)
evaluates to t 
expression:(in l_flex_key1, "Y", "N", "E")
evaluates to f 
expression:(or (null p_networkid), (= p_networkid, ""))
evaluates to t 
start select cursor.
select case  when (= dfltntw, "Y") then 0 else 1 end, networks.network_id, network_narr
  from ntwsrvctypes, networks
  where (and (= ntwsrvctypes.srvctypecode, p_srvctypecode), (= ntwsrvctypes.network_id, networks.network_id))
  order by 1
select cursor iteration.
select cursor returns 1 , RP , RPData 
select cursor iteration.
end cursor
expression:(or (null p_networkid), (= p_networkid, ""))
evaluates to f 
let l_event_code = NULL. 
let l_event_type = NULL. 
start select cursor.
select event_type, event_code
  from srvcactionevents
  where (and (and (= srvctypecode, p_srvctypecode), (= network_id, p_networkid)), (= actionid, l_action_id))
select cursor iteration.
select cursor returns CM , SC 
end cursor
expression:(and (not-null l_event_type), (not-null l_event_code))
evaluates to t 
expression:
  (select event_code_ref
    from evnt_code
    where (and (= event_type, l_event_type), (= event_code, l_event_code)))
evaluates to 6148 ; 
let l_event_code_ref = 6148 

execute function informix.sf_json_attrib[procid=9095] ( p_name = DefinitionId ,  p_value = 6148 ,  p_type = INTEGER ,  p_first = t ,  p_last = f ,  p_escape = t )
default value  p_type = STRING
default value  p_first = f
default value  p_last = f
default value  p_escape = t
set_state: owner is informix - utype = 'D'expression:(<procedure> chr, 9)
evaluates to 	 
let l_ascii = 	 
let l_json =  
expression:(or (or (= (<procedure> upper, p_type), "STRING"), (= (<procedure> upper, p_type), "DATETIME")), (= (<procedure> upper, p_type), "DATE"))
evaluates to f 
expression:(or (= (<procedure> upper, p_type), "NUMBER"), (= (<procedure> upper, p_type), "INTEGER"))
evaluates to t 
expression:(null p_value)
evaluates to f 
expression:(|| (|| (|| (|| TRIM ( BOTH ' ' FROM l_json), """), TRIM ( BOTH ' ' FROM p_name)), "": "), p_value)
evaluates to "DefinitionId": 6148 
let l_json = "DefinitionId": 6148 
expression:(not (<unknown op>: 87 p_last))
evaluates to t 
expression:(|| TRIM ( BOTH ' ' FROM l_json), ",")
evaluates to "DefinitionId": 6148, 
let l_json = "DefinitionId": 6148, 
expression:(<unknown op>: 87 p_first)
evaluates to t 
expression:(|| "{", TRIM ( BOTH ' ' FROM l_json))
evaluates to {"DefinitionId": 6148, 
let l_json = {"DefinitionId": 6148, 
expression:TRIM ( BOTH ' ' FROM l_json)
evaluates to {"DefinitionId": 6148, 
procedure sf_json_attrib returns {"DefinitionId": 6148, 


execute function informix.sf_json_attrib[procid=9095] ( p_name = Note ,  p_value = NULL. ,  p_type = STRING ,  p_first = f ,  p_last = f ,  p_escape = t )
default value  p_type = STRING
default value  p_first = f
default value  p_last = f
default value  p_escape = t
set_state: owner is informix - utype = 'D'expression:(<procedure> chr, 9)
evaluates to 	 
let l_ascii = 	 
let l_json =  
expression:(or (or (= (<procedure> upper, p_type), "STRING"), (= (<procedure> upper, p_type), "DATETIME")), (= (<procedure> upper, p_type), "DATE"))
evaluates to t 
expression:(null p_value)
evaluates to t 
expression:(|| (|| (|| TRIM ( BOTH ' ' FROM l_json), """), TRIM ( BOTH ' ' FROM p_name)), "": null")
evaluates to "Note": null 
let l_json = "Note": null 
expression:(not (<unknown op>: 87 p_last))
evaluates to t 
expression:(|| TRIM ( BOTH ' ' FROM l_json), ",")
evaluates to "Note": null, 
let l_json = "Note": null, 
expression:(<unknown op>: 87 p_first)
evaluates to f 
expression:TRIM ( BOTH ' ' FROM l_json)
evaluates to "Note": null, 
procedure sf_json_attrib returns "Note": null, 


execute function informix.sf_json_attrib[procid=9095] ( p_name = Translate ,  p_value = Y ,  p_type = BOOLEAN ,  p_first = f ,  p_last = t ,  p_escape = t )
default value  p_type = STRING
default value  p_first = f
default value  p_last = f
default value  p_escape = t
set_state: owner is informix - utype = 'D'expression:(<procedure> chr, 9)
evaluates to 	 
let l_ascii = 	 
let l_json =  
expression:(or (or (= (<procedure> upper, p_type), "STRING"), (= (<procedure> upper, p_type), "DATETIME")), (= (<procedure> upper, p_type), "DATE"))
evaluates to f 
expression:(or (= (<procedure> upper, p_type), "NUMBER"), (= (<procedure> upper, p_type), "INTEGER"))
evaluates to f 
expression:(= (<procedure> upper, p_type), "CURRENCY")
evaluates to f 
expression:(= (<procedure> upper, p_type), "BOOLEAN")
evaluates to t 

execute function informix.equal[procid=-114] (   = Y ,    = Y )
expression:(= (<procedure> upper, p_value), "Y")
evaluates to t 
expression:(|| (|| (|| TRIM ( BOTH ' ' FROM l_json), """), TRIM ( BOTH ' ' FROM p_name)), "": true")
evaluates to "Translate": true 
let l_json = "Translate": true 
expression:(not (<unknown op>: 87 p_last))
evaluates to f 
expression:(|| TRIM ( BOTH ' ' FROM l_json), "}")
evaluates to "Translate": true} 
let l_json = "Translate": true} 
expression:(<unknown op>: 87 p_first)
evaluates to f 
expression:TRIM ( BOTH ' ' FROM l_json)
evaluates to "Translate": true} 
procedure sf_json_attrib returns "Translate": true} 

expression:(|| (|| (<procedure> sf_json_attrib, "DefinitionId", l_event_code_ref, "INTEGER", "t"), (<procedure> sf_json_attrib, "Note", p_note, "STRING")), (<procedure> sf_json_attrib, "Translate", "Y", "BOOLEAN", "f", "t"))
evaluates to {"DefinitionId": 6148,"Note": null,"Translate": true} 
let l_json = {"DefinitionId": 6148,"Note": null,"Translate": true} 

execute function informix.sp_events_instances_service_api[procid=9367] ( p_sp_cn_ref = 239091 ,  p_request_body = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_user_code = 10018430   ,  p_role_narr = Administrator ,  p_operation_id = /Services#post ,  trace_flg = N ,  tran_flg = N )
default value  p_user_code = NULL.
default value  p_role_narr = NULL.
default value  p_operation_id = NULL.
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 

set lock mode to wait 5;

execute (<procedure> sf_authorise, p_user_code, p_role_narr, p_operation_id);

execute procedure informix.sf_authorise[procid=9490] ( p_user_id = 10018430   ,  p_role = Administrator ,  p_operation_id = /Services#post ,  p_args = NULL. )
default value  p_operation_id = NULL.
default value  p_args = NULL.
set_state: owner is informix - utype = 'D'let l_authorised = f 
expression:TRIM ( BOTH ' ' FROM (<procedure> upper, p_role))
evaluates to ADMINISTRATOR 
let p_role = ADMINISTRATOR 
procedure sf_authorise returned no data

expression:
  (select (count *)
    from sp_connection
    where (= sp_cn_ref, p_sp_cn_ref))
evaluates to 1 ; 
let l_count = 1 
expression:(or (null l_count), (= l_count, 0))
evaluates to f 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = DefinitionId ,  p_data_type = NUMBER ,  p_raise_exception = t ,  p_errorcode = 26017 ,  p_validations = LIST{'NOT_NULL'} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to f 
expression:(= p_data_type, "BOOLEAN")
evaluates to f 
expression:(= p_data_type, "BOOLEAN_YN")
evaluates to f 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = DefinitionId ,  p_quoted = f )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "DefinitionId" 
let p_attrib_name = "DefinitionId" 
expression:(<procedure> length, p_attrib_name)
evaluates to 14 
let l_attrib_name_len = 14 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 2 
let l_pos = 2 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 15 
let l_pos = 15 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 16 
let l_pos = 16 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 17 
let l_pos = 17 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 18 
let l_pos = 18 
expression:(substring p_json, l_pos, 1)
evaluates to 6 
let l_char = 6 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = 6148 ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to f 
expression:(<unknown op>: 87 p_quoted)
evaluates to f 
expression:(<> l_char, " ")
evaluates to t 
expression:l_pos
evaluates to 18 
let l_attrib_start_pos = 18 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 19 
let l_pos = 19 
expression:(substring p_json, l_pos, 1)
evaluates to 1 
let l_char = 1 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 20 
let l_pos = 20 
expression:(substring p_json, l_pos, 1)
evaluates to 4 
let l_char = 4 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 21 
let l_pos = 21 
expression:(substring p_json, l_pos, 1)
evaluates to 8 
let l_char = 8 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 22 
let l_pos = 22 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to t 
expression:(substring p_json, l_attrib_start_pos, (- l_pos, l_attrib_start_pos))
evaluates to 6148 
let l_attrib_str = 6148 

execute function informix.equal[procid=-114] (   = 6148 ,    = NULL )
expression:(= (<procedure> upper, TRIM ( BOTH ' ' FROM l_attrib_str)), "NULL")
evaluates to f 
expression:TRIM ( BOTH ' ' FROM l_attrib_str)
evaluates to 6148 
procedure sf_json_get_attrib returns 6148 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "f")
evaluates to 6148 
let l_property_value = 6148 

execute function informix.equal[procid=-114] (   = 6148 ,    =  )
expression:(= l_property_value, "")
evaluates to f 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to t 
expression:(in p_data_type, "INTEGER")
evaluates to f 
expression:(in p_data_type, "DECIMAL", "NUMBER")
evaluates to t 
expression:l_property_value
evaluates to 6148.0000000000 
let l_decimal = 6148.0000000000 
expression:(not-null p_validations)
evaluates to t 
let l_min_value = f 
let l_max_value = f 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns NOT_NULL 
expression:(= l_value, "MIN_VALUE")
evaluates to f 
expression:(<unknown op>: 87 l_min_value)
evaluates to f 
expression:(= l_value, "MAX_VALUE")
evaluates to f 
expression:(<unknown op>: 87 l_max_value)
evaluates to f 
select cursor iteration.
end cursor
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to 6148 
procedure sf_get_property returns 6148 

expression:(<procedure> sf_get_property, p_request_body, "DefinitionId", "NUMBER", "t", 26017,  LIST{"NOT_NULL"})
evaluates to 6148 
let p_event_code_ref = 6148 
expression:
  (select event_type, event_code, cont_status
    from evnt_code
    where (= event_code_ref, p_event_code_ref))
evaluates to NULL. ; SC ; CM ; 
let p_event_type = CM 
let p_event_code = SC 
let l_evnt_code_cont_status = NULL. 
expression:(or (null p_event_type), (null p_event_code))
evaluates to f 

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = Note ,  p_data_type = STRING ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = Note ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "Note" 
let p_attrib_name = "Note" 
expression:(<procedure> length, p_attrib_name)
evaluates to 6 
let l_attrib_name_len = 6 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 23 
let l_pos = 23 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 28 
let l_pos = 28 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 29 
let l_pos = 29 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 30 
let l_pos = 30 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 31 
let l_pos = 31 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = NULL ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to NULL. 
procedure sf_get_property returns NULL. 

expression:(<procedure> sf_get_property, p_request_body, "Note", "STRING")
evaluates to NULL. 
let p_note_text = NULL. 

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = ReasonId ,  p_data_type = STRING ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = ReasonId ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "ReasonId" 
let p_attrib_name = "ReasonId" 
expression:(<procedure> length, p_attrib_name)
evaluates to 10 
let l_attrib_name_len = 10 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to NULL. 
procedure sf_get_property returns NULL. 

expression:(<procedure> upper, (<procedure> sf_get_property, p_request_body, "ReasonId", "STRING"))
evaluates to NULL. 
let p_evnt_reas_code = NULL. 
expression:(not-null p_evnt_reas_code)
evaluates to f 

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = ScheduledToId ,  p_data_type = STRING ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = ScheduledToId ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "ScheduledToId" 
let p_attrib_name = "ScheduledToId" 
expression:(<procedure> length, p_attrib_name)
evaluates to 15 
let l_attrib_name_len = 15 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to NULL. 
procedure sf_get_property returns NULL. 

expression:(<procedure> lower, (<procedure> sf_get_property, p_request_body, "ScheduledToId", "STRING"))
evaluates to NULL. 
let p_to_login = NULL. 

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = DepartmentIdScheduledTo ,  p_data_type = STRING ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = DepartmentIdScheduledTo ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "DepartmentIdScheduledTo" 
let p_attrib_name = "DepartmentIdScheduledTo" 
expression:(<procedure> length, p_attrib_name)
evaluates to 25 
let l_attrib_name_len = 25 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to NULL. 
procedure sf_get_property returns NULL. 

expression:(<procedure> upper, (<procedure> sf_get_property, p_request_body, "DepartmentIdScheduledTo", "STRING"))
evaluates to NULL. 
let p_to_dept = NULL. 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = ScheduleStatusId ,  p_data_type = STRING ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = LIST{'DEFAULT','O'} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = ScheduleStatusId ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "ScheduleStatusId" 
let p_attrib_name = "ScheduleStatusId" 
expression:(<procedure> length, p_attrib_name)
evaluates to 18 
let l_attrib_name_len = 18 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to t 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns DEFAULT 
expression:(= l_value, "DEFAULT")
evaluates to t 
let l_default = t 
select cursor iteration.
select cursor returns O 
expression:(= l_value, "DEFAULT")
evaluates to f 
expression:(<unknown op>: 87 l_default)
evaluates to t 
expression:(in p_data_type, "DATE", "DATETIME")
evaluates to f 
expression:l_value
evaluates to O 
let l_property_value = O 
let l_null = f 
select cursor iteration.
end cursor
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to O 
procedure sf_get_property returns O 

expression:(<procedure> upper, (<procedure> sf_get_property, p_request_body, "ScheduleStatusId", "STRING", "f",  <NULL> ,  LIST{"DEFAULT", "O"}))
evaluates to O  
let p_sched_stat_code = O  
expression:(<> p_sched_stat_code, "O")
evaluates to f 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = Due ,  p_data_type = DATETIME ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = LIST{'DEFAULT                                                                         ','2025-03-26 15:26:32                                                             '} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = Due ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "Due" 
let p_attrib_name = "Due" 
expression:(<procedure> length, p_attrib_name)
evaluates to 5 
let l_attrib_name_len = 5 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to t 
expression:(> (<procedure> length, l_property_value), 19)
evaluates to NULL. 
expression:(<procedure> replace, l_property_value, "T", " ")
evaluates to NULL. 
let l_dt = NULL. 
expression:(in p_data_type, "DATE")
evaluates to f 
expression:l_dt
evaluates to NULL. 
let l_property_value = NULL. 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to t 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns DEFAULT                                                                          
expression:(= l_value, "DEFAULT")
evaluates to t 
let l_default = t 
select cursor iteration.
select cursor returns 2025-03-26 15:26:32                                                              
expression:(= l_value, "DEFAULT")
evaluates to f 
expression:(<unknown op>: 87 l_default)
evaluates to t 
expression:(in p_data_type, "DATE", "DATETIME")
evaluates to t 
expression:l_value
evaluates to 2025-03-26 15:26:32                                                              
let l_dt = 2025-03-26 15:26:32                                                              
expression:(extend l_dt year to second)
evaluates to 2025-03-26 15:26:32 
let l_property_value = 2025-03-26 15:26:32 
let l_null = f 
select cursor iteration.
end cursor
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to 2025-03-26 15:26:32 
procedure sf_get_property returns 2025-03-26 15:26:32 

expression:(<procedure> sf_get_property, p_request_body, "Due", "DATETIME", "f",  <NULL> ,  LIST{"DEFAULT", (extend current year to fraction(3) year to second)})
evaluates to 2025-03-26 15:26:32 
let p_due_tm = 2025-03-26 15:26:32 

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = ParentEvent ,  p_data_type = NUMBER ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to f 
expression:(= p_data_type, "BOOLEAN")
evaluates to f 
expression:(= p_data_type, "BOOLEAN_YN")
evaluates to f 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = ParentEvent ,  p_quoted = f )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "ParentEvent" 
let p_attrib_name = "ParentEvent" 
expression:(<procedure> length, p_attrib_name)
evaluates to 13 
let l_attrib_name_len = 13 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "f")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to t 
expression:(in p_data_type, "INTEGER")
evaluates to f 
expression:(in p_data_type, "DECIMAL", "NUMBER")
evaluates to t 
expression:l_property_value
evaluates to NULL. 
let l_decimal = NULL. 
expression:(not-null p_validations)
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to NULL. 
procedure sf_get_property returns NULL. 

expression:(<procedure> sf_get_property, p_request_body, "ParentEvent", "NUMBER")
evaluates to NULL. 
let p_parent_event = NULL. 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = EventRelationTypeCode ,  p_data_type = STRING ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = LIST{'DEFAULT','F'} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = EventRelationTypeCode ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "EventRelationTypeCode" 
let p_attrib_name = "EventRelationTypeCode" 
expression:(<procedure> length, p_attrib_name)
evaluates to 23 
let l_attrib_name_len = 23 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to t 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns DEFAULT 
expression:(= l_value, "DEFAULT")
evaluates to t 
let l_default = t 
select cursor iteration.
select cursor returns F 
expression:(= l_value, "DEFAULT")
evaluates to f 
expression:(<unknown op>: 87 l_default)
evaluates to t 
expression:(in p_data_type, "DATE", "DATETIME")
evaluates to f 
expression:l_value
evaluates to F 
let l_property_value = F 
let l_null = f 
select cursor iteration.
end cursor
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to F 
procedure sf_get_property returns F 

expression:(<procedure> upper, (<procedure> sf_get_property, p_request_body, "EventRelationTypeCode", "STRING", "f",  <NULL> ,  LIST{"DEFAULT", "F"}))
evaluates to F 
let p_evntrelntypecode = F 

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = EventOtherReference ,  p_data_type = NUMBER ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to f 
expression:(= p_data_type, "BOOLEAN")
evaluates to f 
expression:(= p_data_type, "BOOLEAN_YN")
evaluates to f 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = EventOtherReference ,  p_quoted = f )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "EventOtherReference" 
let p_attrib_name = "EventOtherReference" 
expression:(<procedure> length, p_attrib_name)
evaluates to 21 
let l_attrib_name_len = 21 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "f")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to t 
expression:(in p_data_type, "INTEGER")
evaluates to f 
expression:(in p_data_type, "DECIMAL", "NUMBER")
evaluates to t 
expression:l_property_value
evaluates to NULL. 
let l_decimal = NULL. 
expression:(not-null p_validations)
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to NULL. 
procedure sf_get_property returns NULL. 

expression:(<procedure> sf_get_property, p_request_body, "EventOtherReference", "NUMBER")
evaluates to NULL. 
let p_evnt_oth_ref = NULL. 

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = BillReference ,  p_data_type = NUMBER ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to f 
expression:(= p_data_type, "BOOLEAN")
evaluates to f 
expression:(= p_data_type, "BOOLEAN_YN")
evaluates to f 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = BillReference ,  p_quoted = f )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "BillReference" 
let p_attrib_name = "BillReference" 
expression:(<procedure> length, p_attrib_name)
evaluates to 15 
let l_attrib_name_len = 15 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "f")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to t 
expression:(in p_data_type, "INTEGER")
evaluates to f 
expression:(in p_data_type, "DECIMAL", "NUMBER")
evaluates to t 
expression:l_property_value
evaluates to NULL. 
let l_decimal = NULL. 
expression:(not-null p_validations)
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to NULL. 
procedure sf_get_property returns NULL. 

expression:(<procedure> sf_get_property, p_request_body, "BillReference", "NUMBER")
evaluates to NULL. 
let p_bill_ref = NULL. 

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = BillEventType ,  p_data_type = STRING ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = BillEventType ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "BillEventType" 
let p_attrib_name = "BillEventType" 
expression:(<procedure> length, p_attrib_name)
evaluates to 15 
let l_attrib_name_len = 15 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to NULL. 
procedure sf_get_property returns NULL. 

expression:(<procedure> upper, (<procedure> sf_get_property, p_request_body, "BillEventType", "STRING"))
evaluates to NULL. 
let p_bill_event_type = NULL. 
expression:(and (not-null p_bill_ref), (null p_bill_event_type))
evaluates to f 

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = BillStepReference ,  p_data_type = NUMBER ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to f 
expression:(= p_data_type, "BOOLEAN")
evaluates to f 
expression:(= p_data_type, "BOOLEAN_YN")
evaluates to f 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = BillStepReference ,  p_quoted = f )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "BillStepReference" 
let p_attrib_name = "BillStepReference" 
expression:(<procedure> length, p_attrib_name)
evaluates to 19 
let l_attrib_name_len = 19 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "f")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to t 
expression:(in p_data_type, "INTEGER")
evaluates to f 
expression:(in p_data_type, "DECIMAL", "NUMBER")
evaluates to t 
expression:l_property_value
evaluates to NULL. 
let l_decimal = NULL. 
expression:(not-null p_validations)
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to NULL. 
procedure sf_get_property returns NULL. 

expression:(<procedure> sf_get_property, p_request_body, "BillStepReference", "NUMBER")
evaluates to NULL. 
let p_bill_step_ref = NULL. 

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = AttachLocation ,  p_data_type = STRING ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = AttachLocation ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "AttachLocation" 
let p_attrib_name = "AttachLocation" 
expression:(<procedure> length, p_attrib_name)
evaluates to 16 
let l_attrib_name_len = 16 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to NULL. 
procedure sf_get_property returns NULL. 

expression:(<procedure> sf_get_property, p_request_body, "AttachLocation", "STRING")
evaluates to NULL. 
let p_attach_loc = NULL. 

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = PriorityId ,  p_data_type = NUMBER ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to f 
expression:(= p_data_type, "BOOLEAN")
evaluates to f 
expression:(= p_data_type, "BOOLEAN_YN")
evaluates to f 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = PriorityId ,  p_quoted = f )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "PriorityId" 
let p_attrib_name = "PriorityId" 
expression:(<procedure> length, p_attrib_name)
evaluates to 12 
let l_attrib_name_len = 12 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "f")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to t 
expression:(in p_data_type, "INTEGER")
evaluates to f 
expression:(in p_data_type, "DECIMAL", "NUMBER")
evaluates to t 
expression:l_property_value
evaluates to NULL. 
let l_decimal = NULL. 
expression:(not-null p_validations)
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to NULL. 
procedure sf_get_property returns NULL. 

expression:(<procedure> sf_get_property, p_request_body, "PriorityId", "NUMBER")
evaluates to NULL. 
let p_priority_id = NULL. 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = Alert ,  p_data_type = BOOLEAN_YN ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = LIST{'DEFAULT','N'} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to f 
expression:(= p_data_type, "BOOLEAN")
evaluates to f 
expression:(= p_data_type, "BOOLEAN_YN")
evaluates to t 

execute function informix.sf_json_get_attrib_bool_yn[procid=9541] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = Alert ,  p_raise_exception = t ,  p_errorcode = NULL. )
default value  p_raise_exception = t
default value  p_errorcode = 0
set_state: owner is informix - utype = 'D'
execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = Alert ,  p_quoted = f )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "Alert" 
let p_attrib_name = "Alert" 
expression:(<procedure> length, p_attrib_name)
evaluates to 7 
let l_attrib_name_len = 7 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_attrib_name, "f")
evaluates to NULL. 
let l_attrib_str = NULL. 
expression:(null l_attrib_str)
evaluates to t 
procedure sf_json_get_attrib_bool_yn returns NULL. 

expression:(<procedure> sf_json_get_attrib_bool_yn, p_json, p_name, "t", p_errorcode)
evaluates to NULL. 
let l_property_value = NULL. 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to t 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns DEFAULT 
expression:(= l_value, "DEFAULT")
evaluates to t 
let l_default = t 
select cursor iteration.
select cursor returns N 
expression:(= l_value, "DEFAULT")
evaluates to f 
expression:(<unknown op>: 87 l_default)
evaluates to t 
expression:(in p_data_type, "DATE", "DATETIME")
evaluates to f 
expression:l_value
evaluates to N 
let l_property_value = N 
let l_null = f 
select cursor iteration.
end cursor
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to N 
procedure sf_get_property returns N 

expression:(<procedure> sf_get_property, p_request_body, "Alert", "BOOLEAN_YN", "f",  <NULL> ,  LIST{"DEFAULT", "N"})
evaluates to N 
let p_alert = N 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = CreateSMSEvent ,  p_data_type = BOOLEAN_YN ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = LIST{'DEFAULT','Y'} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to f 
expression:(= p_data_type, "BOOLEAN")
evaluates to f 
expression:(= p_data_type, "BOOLEAN_YN")
evaluates to t 

execute function informix.sf_json_get_attrib_bool_yn[procid=9541] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = CreateSMSEvent ,  p_raise_exception = t ,  p_errorcode = NULL. )
default value  p_raise_exception = t
default value  p_errorcode = 0
set_state: owner is informix - utype = 'D'
execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = CreateSMSEvent ,  p_quoted = f )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "CreateSMSEvent" 
let p_attrib_name = "CreateSMSEvent" 
expression:(<procedure> length, p_attrib_name)
evaluates to 16 
let l_attrib_name_len = 16 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_attrib_name, "f")
evaluates to NULL. 
let l_attrib_str = NULL. 
expression:(null l_attrib_str)
evaluates to t 
procedure sf_json_get_attrib_bool_yn returns NULL. 

expression:(<procedure> sf_json_get_attrib_bool_yn, p_json, p_name, "t", p_errorcode)
evaluates to NULL. 
let l_property_value = NULL. 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to t 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns DEFAULT 
expression:(= l_value, "DEFAULT")
evaluates to t 
let l_default = t 
select cursor iteration.
select cursor returns Y 
expression:(= l_value, "DEFAULT")
evaluates to f 
expression:(<unknown op>: 87 l_default)
evaluates to t 
expression:(in p_data_type, "DATE", "DATETIME")
evaluates to f 
expression:l_value
evaluates to Y 
let l_property_value = Y 
let l_null = f 
select cursor iteration.
end cursor
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to Y 
procedure sf_get_property returns Y 

expression:(<procedure> sf_get_property, p_request_body, "CreateSMSEvent", "BOOLEAN_YN", "f",  <NULL> ,  LIST{"DEFAULT", "Y"})
evaluates to Y 
let p_create_sms = Y 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = ScheduleCodeId ,  p_data_type = STRING ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = LIST{'DEFAULT','ACT'} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = ScheduleCodeId ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "ScheduleCodeId" 
let p_attrib_name = "ScheduleCodeId" 
expression:(<procedure> length, p_attrib_name)
evaluates to 16 
let l_attrib_name_len = 16 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to t 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns DEFAULT 
expression:(= l_value, "DEFAULT")
evaluates to t 
let l_default = t 
select cursor iteration.
select cursor returns ACT 
expression:(= l_value, "DEFAULT")
evaluates to f 
expression:(<unknown op>: 87 l_default)
evaluates to t 
expression:(in p_data_type, "DATE", "DATETIME")
evaluates to f 
expression:l_value
evaluates to ACT 
let l_property_value = ACT 
let l_null = f 
select cursor iteration.
end cursor
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to ACT 
procedure sf_get_property returns ACT 

expression:(<procedure> upper, (<procedure> sf_get_property, p_request_body, "ScheduleCodeId", "STRING", "f",  <NULL> ,  LIST{"DEFAULT", "ACT"}))
evaluates to ACT 
let p_sched_code = ACT 
expression:(not-null p_sched_code)
evaluates to t 
expression:
  (select (count *)
    from sched_code
    where (= sched_code, p_sched_code))
evaluates to 1 ; 
let l_count = 1 
expression:(or (= l_count, 0), (null l_count))
evaluates to f 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = Translate ,  p_data_type = BOOLEAN_YN ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = LIST{'DEFAULT','N'} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to f 
expression:(= p_data_type, "BOOLEAN")
evaluates to f 
expression:(= p_data_type, "BOOLEAN_YN")
evaluates to t 

execute function informix.sf_json_get_attrib_bool_yn[procid=9541] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = Translate ,  p_raise_exception = t ,  p_errorcode = NULL. )
default value  p_raise_exception = t
default value  p_errorcode = 0
set_state: owner is informix - utype = 'D'
execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = Translate ,  p_quoted = f )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "Translate" 
let p_attrib_name = "Translate" 
expression:(<procedure> length, p_attrib_name)
evaluates to 11 
let l_attrib_name_len = 11 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 36 
let l_pos = 36 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 46 
let l_pos = 46 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 47 
let l_pos = 47 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 48 
let l_pos = 48 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 49 
let l_pos = 49 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = TRUE ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to f 
expression:(<unknown op>: 87 p_quoted)
evaluates to f 
expression:(<> l_char, " ")
evaluates to t 
expression:l_pos
evaluates to 49 
let l_attrib_start_pos = 49 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 50 
let l_pos = 50 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 51 
let l_pos = 51 
expression:(substring p_json, l_pos, 1)
evaluates to u 
let l_char = u 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 52 
let l_pos = 52 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 53 
let l_pos = 53 
expression:(substring p_json, l_pos, 1)
evaluates to } 
let l_char = } 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to t 
expression:(substring p_json, l_attrib_start_pos, (- l_pos, l_attrib_start_pos))
evaluates to true 
let l_attrib_str = true 

execute function informix.equal[procid=-114] (   = TRUE ,    = NULL )
expression:(= (<procedure> upper, TRIM ( BOTH ' ' FROM l_attrib_str)), "NULL")
evaluates to f 
expression:TRIM ( BOTH ' ' FROM l_attrib_str)
evaluates to true 
procedure sf_json_get_attrib returns true 

expression:(<procedure> sf_json_get_attrib, p_json, p_attrib_name, "f")
evaluates to true 
let l_attrib_str = true 
expression:(null l_attrib_str)
evaluates to f 

execute function informix.equal[procid=-114] (   = TRUE ,    = TRUE )
expression:(= (<procedure> upper, TRIM ( BOTH ' ' FROM l_attrib_str)), "TRUE")
evaluates to t 
procedure sf_json_get_attrib_bool_yn returns Y 

expression:(<procedure> sf_json_get_attrib_bool_yn, p_json, p_name, "t", p_errorcode)
evaluates to Y 
let l_property_value = Y 

execute function informix.equal[procid=-114] (   = Y ,    =  )
expression:(= l_property_value, "")
evaluates to f 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to Y 
procedure sf_get_property returns Y 

expression:(<procedure> sf_get_property, p_request_body, "Translate", "BOOLEAN_YN", "f",  <NULL> ,  LIST{"DEFAULT", "N"})
evaluates to Y 
let p_translate = Y 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = ScheduleStatusDt ,  p_data_type = DATETIME ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = LIST{'DEFAULT                                                                         ','2025-03-26 15:26:32                                                             '} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = ScheduleStatusDt ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "ScheduleStatusDt" 
let p_attrib_name = "ScheduleStatusDt" 
expression:(<procedure> length, p_attrib_name)
evaluates to 18 
let l_attrib_name_len = 18 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to t 
expression:(> (<procedure> length, l_property_value), 19)
evaluates to NULL. 
expression:(<procedure> replace, l_property_value, "T", " ")
evaluates to NULL. 
let l_dt = NULL. 
expression:(in p_data_type, "DATE")
evaluates to f 
expression:l_dt
evaluates to NULL. 
let l_property_value = NULL. 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to t 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns DEFAULT                                                                          
expression:(= l_value, "DEFAULT")
evaluates to t 
let l_default = t 
select cursor iteration.
select cursor returns 2025-03-26 15:26:32                                                              
expression:(= l_value, "DEFAULT")
evaluates to f 
expression:(<unknown op>: 87 l_default)
evaluates to t 
expression:(in p_data_type, "DATE", "DATETIME")
evaluates to t 
expression:l_value
evaluates to 2025-03-26 15:26:32                                                              
let l_dt = 2025-03-26 15:26:32                                                              
expression:(extend l_dt year to second)
evaluates to 2025-03-26 15:26:32 
let l_property_value = 2025-03-26 15:26:32 
let l_null = f 
select cursor iteration.
end cursor
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to 2025-03-26 15:26:32 
procedure sf_get_property returns 2025-03-26 15:26:32 

expression:(<procedure> sf_get_property, p_request_body, "ScheduleStatusDt", "DATETIME", "f",  <NULL> ,  LIST{"DEFAULT", (extend current year to fraction(3) year to second)})
evaluates to 2025-03-26 15:26:32 
let p_stat_tm = 2025-03-26 15:26:32 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = ScheduleStatusEffectBy ,  p_data_type = STRING ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = LIST{'DEFAULT','webuser'} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = ScheduleStatusEffectBy ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "ScheduleStatusEffectBy" 
let p_attrib_name = "ScheduleStatusEffectBy" 
expression:(<procedure> length, p_attrib_name)
evaluates to 24 
let l_attrib_name_len = 24 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to t 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns DEFAULT 
expression:(= l_value, "DEFAULT")
evaluates to t 
let l_default = t 
select cursor iteration.
select cursor returns webuser 
expression:(= l_value, "DEFAULT")
evaluates to f 
expression:(<unknown op>: 87 l_default)
evaluates to t 
expression:(in p_data_type, "DATE", "DATETIME")
evaluates to f 
expression:l_value
evaluates to webuser 
let l_property_value = webuser 
let l_null = f 
select cursor iteration.
end cursor
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to webuser 
procedure sf_get_property returns webuser 

expression:(<procedure> sf_get_property, p_request_body, "ScheduleStatusEffectBy", "STRING", "f",  <NULL> ,  LIST{"DEFAULT", <USER>})
evaluates to webuser 
let p_stat_effect_by = webuser 

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = TriggerDue ,  p_data_type = DATETIME ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = TriggerDue ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "TriggerDue" 
let p_attrib_name = "TriggerDue" 
expression:(<procedure> length, p_attrib_name)
evaluates to 12 
let l_attrib_name_len = 12 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to t 
expression:(> (<procedure> length, l_property_value), 19)
evaluates to NULL. 
expression:(<procedure> replace, l_property_value, "T", " ")
evaluates to NULL. 
let l_dt = NULL. 
expression:(in p_data_type, "DATE")
evaluates to f 
expression:l_dt
evaluates to NULL. 
let l_property_value = NULL. 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to NULL. 
procedure sf_get_property returns NULL. 

expression:(<procedure> sf_get_property, p_request_body, "TriggerDue", "DATETIME")
evaluates to NULL. 
let p_trigger_due_tm = NULL. 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = EventTriggers ,  p_data_type = BOOLEAN_YN ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = LIST{'DEFAULT','Y'} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to f 
expression:(= p_data_type, "BOOLEAN")
evaluates to f 
expression:(= p_data_type, "BOOLEAN_YN")
evaluates to t 

execute function informix.sf_json_get_attrib_bool_yn[procid=9541] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = EventTriggers ,  p_raise_exception = t ,  p_errorcode = NULL. )
default value  p_raise_exception = t
default value  p_errorcode = 0
set_state: owner is informix - utype = 'D'
execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = EventTriggers ,  p_quoted = f )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "EventTriggers" 
let p_attrib_name = "EventTriggers" 
expression:(<procedure> length, p_attrib_name)
evaluates to 15 
let l_attrib_name_len = 15 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_attrib_name, "f")
evaluates to NULL. 
let l_attrib_str = NULL. 
expression:(null l_attrib_str)
evaluates to t 
procedure sf_json_get_attrib_bool_yn returns NULL. 

expression:(<procedure> sf_json_get_attrib_bool_yn, p_json, p_name, "t", p_errorcode)
evaluates to NULL. 
let l_property_value = NULL. 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to t 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns DEFAULT 
expression:(= l_value, "DEFAULT")
evaluates to t 
let l_default = t 
select cursor iteration.
select cursor returns Y 
expression:(= l_value, "DEFAULT")
evaluates to f 
expression:(<unknown op>: 87 l_default)
evaluates to t 
expression:(in p_data_type, "DATE", "DATETIME")
evaluates to f 
expression:l_value
evaluates to Y 
let l_property_value = Y 
let l_null = f 
select cursor iteration.
end cursor
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to Y 
procedure sf_get_property returns Y 

expression:(<procedure> sf_get_property, p_request_body, "EventTriggers", "BOOLEAN_YN", "f",  <NULL> ,  LIST{"DEFAULT", "Y"})
evaluates to Y 
let p_event_triggers = Y 

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = FinancialReference ,  p_data_type = NUMBER ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to f 
expression:(= p_data_type, "BOOLEAN")
evaluates to f 
expression:(= p_data_type, "BOOLEAN_YN")
evaluates to f 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = FinancialReference ,  p_quoted = f )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "FinancialReference" 
let p_attrib_name = "FinancialReference" 
expression:(<procedure> length, p_attrib_name)
evaluates to 20 
let l_attrib_name_len = 20 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "f")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to t 
expression:(in p_data_type, "INTEGER")
evaluates to f 
expression:(in p_data_type, "DECIMAL", "NUMBER")
evaluates to t 
expression:l_property_value
evaluates to NULL. 
let l_decimal = NULL. 
expression:(not-null p_validations)
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to NULL. 
procedure sf_get_property returns NULL. 

expression:(<procedure> sf_get_property, p_request_body, "FinancialReference", "NUMBER")
evaluates to NULL. 
let p_fin_ref = NULL. 
expression:(not-null p_fin_ref)
evaluates to f 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = CreatedBy ,  p_data_type = STRING ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = LIST{'DEFAULT','webuser'} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = CreatedBy ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "CreatedBy" 
let p_attrib_name = "CreatedBy" 
expression:(<procedure> length, p_attrib_name)
evaluates to 11 
let l_attrib_name_len = 11 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to t 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns DEFAULT 
expression:(= l_value, "DEFAULT")
evaluates to t 
let l_default = t 
select cursor iteration.
select cursor returns webuser 
expression:(= l_value, "DEFAULT")
evaluates to f 
expression:(<unknown op>: 87 l_default)
evaluates to t 
expression:(in p_data_type, "DATE", "DATETIME")
evaluates to f 
expression:l_value
evaluates to webuser 
let l_property_value = webuser 
let l_null = f 
select cursor iteration.
end cursor
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to webuser 
procedure sf_get_property returns webuser 

expression:(<procedure> sf_get_property, p_request_body, "CreatedBy", "STRING", "f",  <NULL> ,  LIST{"DEFAULT", <USER>})
evaluates to webuser 
let p_created_by = webuser 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = Created ,  p_data_type = DATETIME ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = LIST{'DEFAULT                                                                         ','2025-03-26 15:26:32                                                             '} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = Created ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "Created" 
let p_attrib_name = "Created" 
expression:(<procedure> length, p_attrib_name)
evaluates to 9 
let l_attrib_name_len = 9 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to t 
expression:(> (<procedure> length, l_property_value), 19)
evaluates to NULL. 
expression:(<procedure> replace, l_property_value, "T", " ")
evaluates to NULL. 
let l_dt = NULL. 
expression:(in p_data_type, "DATE")
evaluates to f 
expression:l_dt
evaluates to NULL. 
let l_property_value = NULL. 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to t 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns DEFAULT                                                                          
expression:(= l_value, "DEFAULT")
evaluates to t 
let l_default = t 
select cursor iteration.
select cursor returns 2025-03-26 15:26:32                                                              
expression:(= l_value, "DEFAULT")
evaluates to f 
expression:(<unknown op>: 87 l_default)
evaluates to t 
expression:(in p_data_type, "DATE", "DATETIME")
evaluates to t 
expression:l_value
evaluates to 2025-03-26 15:26:32                                                              
let l_dt = 2025-03-26 15:26:32                                                              
expression:(extend l_dt year to second)
evaluates to 2025-03-26 15:26:32 
let l_property_value = 2025-03-26 15:26:32 
let l_null = f 
select cursor iteration.
end cursor
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to 2025-03-26 15:26:32 
procedure sf_get_property returns 2025-03-26 15:26:32 

expression:(<procedure> sf_get_property, p_request_body, "Created", "DATETIME", "f",  <NULL> ,  LIST{"DEFAULT", (extend current year to fraction(3) year to second)})
evaluates to 2025-03-26 15:26:32 
let p_created_tm = 2025-03-26 15:26:32 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = Mode ,  p_data_type = STRING ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = LIST{'DEFAULT','U'} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = Mode ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "Mode" 
let p_attrib_name = "Mode" 
expression:(<procedure> length, p_attrib_name)
evaluates to 6 
let l_attrib_name_len = 6 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to t 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns DEFAULT 
expression:(= l_value, "DEFAULT")
evaluates to t 
let l_default = t 
select cursor iteration.
select cursor returns U 
expression:(= l_value, "DEFAULT")
evaluates to f 
expression:(<unknown op>: 87 l_default)
evaluates to t 
expression:(in p_data_type, "DATE", "DATETIME")
evaluates to f 
expression:l_value
evaluates to U 
let l_property_value = U 
let l_null = f 
select cursor iteration.
end cursor
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to U 
procedure sf_get_property returns U 

expression:(<procedure> sf_get_property, p_request_body, "Mode", "STRING", "f",  <NULL> ,  LIST{"DEFAULT", "U"})
evaluates to U 
let p_mode = U 

execute function informix.sf_get_property[procid=9798] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_name = ServiceHistToDt ,  p_data_type = DATETIME ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"DefinitionId": 6148,"Note": null,"Translate": true} ,  p_attrib_name = ServiceHistToDt ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "ServiceHistToDt" 
let p_attrib_name = "ServiceHistToDt" 
expression:(<procedure> length, p_attrib_name)
evaluates to 17 
let l_attrib_name_len = 17 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to t 
expression:(> (<procedure> length, l_property_value), 19)
evaluates to NULL. 
expression:(<procedure> replace, l_property_value, "T", " ")
evaluates to NULL. 
let l_dt = NULL. 
expression:(in p_data_type, "DATE")
evaluates to f 
expression:l_dt
evaluates to NULL. 
let l_property_value = NULL. 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to NULL. 
procedure sf_get_property returns NULL. 

expression:(<procedure> sf_get_property, p_request_body, "ServiceHistToDt", "DATETIME")
evaluates to NULL. 
let p_spcnhist_to_dt = NULL. 
expression:(and (and (not-null p_to_login), (not-null p_to_dept)), (not-null p_sched_code))
evaluates to f 
let l_schedule = N 
let l_acct_void_event = NULL. 
let l_contact_code = NULL. 
let p_contact_code = NULL. 
let l_sys_status = NULL. 
let l_cm_ic_cnt = NULL. 
let l_cm_pi_cnt = NULL. 
let l_sm_sc_cnt = NULL. 
let l_sm_sp_cnt = NULL. 
let l_event_ref = NULL. 

execute function informix.ss_sys_cnfg_api[procid=9891] ( p_cnfg_key = ACCT_TO_VOID_EVENT ,  p_alt_cnfg_key = NULL. ,  p_default_val = N ,  p_force_upper = N ,  p_max_length = 10 ,  p_check_is_numeric = N ,  p_check_is_dt = N ,  p_user_code = 10018430   ,  p_role_narr = Administrator ,  p_operation_id = NULL. ,  trace_flg = N )
default value  p_alt_cnfg_key = NULL.
default value  p_default_val = NULL.
default value  p_force_upper = N
default value  p_max_length = 0
default value  p_check_is_numeric = N
default value  p_check_is_dt = N
default value  p_user_code = NULL.
default value  p_role_narr = NULL.
default value  p_operation_id = NULL.
default value  trace_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

set lock mode to wait 30;

execute (<procedure> sf_authorise, p_user_code, p_role_narr, p_operation_id);

execute procedure informix.sf_authorise[procid=9490] ( p_user_id = 10018430   ,  p_role = Administrator ,  p_operation_id = NULL. ,  p_args = NULL. )
default value  p_operation_id = NULL.
default value  p_args = NULL.
set_state: owner is informix - utype = 'D'let l_authorised = f 
expression:TRIM ( BOTH ' ' FROM (<procedure> upper, p_role))
evaluates to ADMINISTRATOR 
let p_role = ADMINISTRATOR 
procedure sf_authorise returned no data

expression:(<procedure> upper, p_cnfg_key)
evaluates to ACCT_TO_VOID_EVENT               
let p_cnfg_key = ACCT_TO_VOID_EVENT               
let l_cnfg_val = NULL. 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_cnfg_key))
evaluates to NULL. ; 
let l_cnfg_val = NULL. 
expression:(and (null l_cnfg_val), (not-null p_alt_cnfg_key))
evaluates to f 
expression:(nvl l_cnfg_val, p_default_val)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_force_upper, "Y")
evaluates to f 
expression:(> p_max_length, 0)
evaluates to t 
expression:(substring l_cnfg_val, 1, p_max_length)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(= p_check_is_dt, "Y")
evaluates to f 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(|| (|| "{"Value": "", TRIM ( BOTH ' ' FROM l_cnfg_val)), ""}")
evaluates to {"Value": "N"}                                                                                                                                                                                                                                                                                               
let l_json = {"Value": "N"}                                                                                                                                                                                                                                                                                               
expression:TRIM ( BOTH ' ' FROM l_json)
evaluates to {"Value": "N"}                                                                                                                                                                                                                                                                                               
procedure ss_sys_cnfg_api returns 200 , {"Value": "N"}                                                                                                                                                                                                                                                                                               , NULL. , NULL. 

expression:(<procedure> ss_sys_cnfg_api, "ACCT_TO_VOID_EVENT" as p_cnfg_key, "N" as p_default_val, 10 as p_max_length, "N" as p_force_upper, p_user_code as p_user_code, p_role_narr as p_role_narr)
evaluates to NULL. ; NULL. ; {"Value": "N"}                                                                                                                                                                                                                                                                                               ; 200 ; 
let l_status = 200 
let l_json = {"Value": "N"}                                                                                                                                                                                                                                                                                               
let l_errcode = NULL. 
let l_msg = NULL. 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"Value": "N"}                                                                                                                                                                                                                                                 ,  p_attrib_name = Value ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "Value" 
let p_attrib_name = "Value" 
expression:(<procedure> length, p_attrib_name)
evaluates to 7 
let l_attrib_name_len = 7 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 2 
let l_pos = 2 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 8 
let l_pos = 8 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 9 
let l_pos = 9 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 10 
let l_pos = 10 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 11 
let l_pos = 11 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = "N"} ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to f 
expression:(<unknown op>: 87 p_quoted)
evaluates to t 
expression:(= l_char, """)
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 12 
let l_attrib_start_pos = 12 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 12 
let l_pos = 12 
expression:(substring p_json, l_pos, 1)
evaluates to N 
let l_char = N 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 13 
let l_pos = 13 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to t 
expression:(null l_attrib_str)
evaluates to t 
expression:(substring p_json, l_attrib_start_pos, (- l_pos, l_attrib_start_pos))
evaluates to N 
let l_attrib_str = N 
expression:TRIM ( BOTH ' ' FROM l_attrib_str)
evaluates to N 
procedure sf_json_get_attrib returns N 

expression:(<procedure> sf_json_get_attrib, l_json, "Value", "t")
evaluates to N          
let l_acct_void_event = N          
expression:(= p_translate, "Y")
evaluates to t 

execute function informix.ss_flex_code[procid=1382] ( p_sys_table = evnt_code ,  p_sys_hard_group = CM ,  p_sys_hard_code = SC ,  p_multiple_rows = N ,  p_msg = NULL. ,  resume_flg = Z )
default value  p_multiple_rows = N
default value  p_msg = NULL.
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(not-in resume_flg, "Y", "N", "Z")
evaluates to f 
let l_found = N 
let l_tmp_key1 = NULL. 
expression:(not-null p_msg)
evaluates to f 
expression:(|| (|| "Flex key not found: ", TRIM ( BOTH ' ' FROM p_sys_table)), " | ")
evaluates to Flex key not found: evnt_code |  
let l_msg = Flex key not found: evnt_code |  
expression:(not-null p_sys_hard_group)
evaluates to t 
expression:(|| (|| l_msg, TRIM ( BOTH ' ' FROM p_sys_hard_group)), " | ")
evaluates to Flex key not found: evnt_code | CM |  
let l_msg = Flex key not found: evnt_code | CM |  
expression:(not-null p_sys_hard_code)
evaluates to t 
expression:(|| (|| l_msg, TRIM ( BOTH ' ' FROM p_sys_hard_code)), ". ")
evaluates to Flex key not found: evnt_code | CM | SC.  
let l_msg = Flex key not found: evnt_code | CM | SC.  
start select cursor.
select flex_key1, flex_key2
  from sys_code
  where (and (and (= sys_table, p_sys_table), (or (= sys_hard_group, p_sys_hard_group), (null p_sys_hard_group))), (or (= sys_hard_code, p_sys_hard_code), (null p_sys_hard_code)))
  order by flex_key2
select cursor iteration.
select cursor returns CM , SC 
expression:(= l_found, "N")
evaluates to t 
expression:l_flex_key1
evaluates to CM 
let l_tmp_key1 = CM 
expression:l_flex_key2
evaluates to SC 
let l_tmp_key2 = SC 
let l_found = Y 
select cursor iteration.
end cursor
expression:(not-null l_tmp_key1)
evaluates to t 
expression:l_tmp_key2
evaluates to SC 
expression:l_tmp_key1
evaluates to CM 
procedure ss_flex_code returns 0 , CM , SC 

expression:(<procedure> ss_flex_code, "evnt_code" as p_sys_table, p_event_type as p_sys_hard_group, p_event_code as p_sys_hard_code, "Z" as resume_flg)
evaluates to SC                               ; CM                               ; 0 ; 
let l_status = 0 
let l_event_type = CM                               
let l_event_code = SC                               

execute function informix.sievent[procid=7558] ( p_event_ref = 0 ,  p_event_type = CM ,  p_event_code = SC ,  p_created_by = webuser ,  p_created_tm = 2025-03-26 15:26:32 ,  tran_flg = N )
default value  p_event_ref = 0
default value  p_created_by = webuser
default value  p_created_tm = 2025-03-26 15:26:32
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 

insert into event(event_ref, event_type, event_code, created_by, created_tm)
  values (p_event_ref, p_event_type, p_event_code, p_created_by, p_created_tm);

before actions:

end before actions

for each row actions: 

end for each row actions

after actions:

end after actions
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
let return_status = 0 
expression:(dbinfo-sqlca.sqlerrd1 )
evaluates to 7159600 
let ser_num = 7159600 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
expression:ser_num
evaluates to 7159600 
expression:return_status
evaluates to 0 
procedure sievent returns 0 , 7159600 

expression:(<procedure> sievent, l_event_type as p_event_type, l_event_code as p_event_code, "N" as tran_flg)
evaluates to 7159600 ; 0 ; 
let l_status = 0 
let p_event_ref = 7159600 
expression:(<> l_status, 0)
evaluates to f 

execute function informix.sievnt_sp_cn[procid=893] ( p_event_ref = 7159600 ,  p_sp_cn_ref = 239091 ,  tran_flg = N )
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 

insert into evnt_sp_cn(event_ref, sp_cn_ref)
  values (p_event_ref, p_sp_cn_ref);

before actions:

end before actions

for each row actions: 

end for each row actions

after actions:

end after actions
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
let return_status = 0 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
expression:return_status
evaluates to 0 
procedure sievnt_sp_cn returns 0 

expression:(<procedure> sievnt_sp_cn, p_event_ref as p_event_ref, p_sp_cn_ref as p_sp_cn_ref, "N" as tran_flg)
evaluates to 0 
let l_status = 0 
expression:(<> l_status, 0)
evaluates to f 
expression:p_sched_stat_code
evaluates to O  
let l_sched_stat_code = O  
expression:(= l_schedule, "N")
evaluates to t 
let l_sched_stat_code = C 
let l_sp_cn_status = NULL. 
expression:
  (select evnt_code_sv_st.sp_cn_status
    from sp_connection, evnt_code_sv_st
    where (and (and (and (and (= sp_connection.srvctypecode, evnt_code_sv_st.srvctypecode), (= event_type, l_event_type)), (= event_code, l_event_code)), (= sched_stat_code, l_sched_stat_code)), (= sp_cn_ref, p_sp_cn_ref)))
evaluates to NULL. ; 
let l_sp_cn_status = NULL. 
expression:(null l_sp_cn_status)
evaluates to t 
expression:
  (select sp_cn_status
    from evnt_code_sv_st
    where (and (and (and (= event_type, l_event_type), (= event_code, l_event_code)), (= sched_stat_code, l_sched_stat_code)), (= srvctypecode, "ALL")))
evaluates to IDS ; 
let l_sp_cn_status = IDS 
expression:(not-null l_sp_cn_status)
evaluates to t 

execute function informix.sp_chg_cn_status[procid=5638] ( p_sp_cn_ref = 239091 ,  p_sp_cn_status = IDS ,  p_sp_cn_stat_type = U ,  p_event_ref = 7159600 ,  p_translate = N ,  p_spcnhist_to_dt = NULL. ,  updated_by = webuser ,  resume_flg = N ,  tran_flg = N )
default value  p_sp_cn_stat_type = U
default value  p_translate = N
default value  p_spcnhist_to_dt = NULL.
default value  updated_by = webuser
default value  resume_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 
expression:(and (and (<> p_sp_cn_stat_type, "U"), (<> p_sp_cn_stat_type, "S")), (<> p_sp_cn_stat_type, "B"))
evaluates to f 
expression:(= p_translate, "N")
evaluates to t 
expression:p_sp_cn_status
evaluates to IDS 
let l_new_status = IDS 
expression:(= p_sp_cn_stat_type, "B")
evaluates to f 
expression:p_sp_cn_stat_type
evaluates to U 
let l_sp_cn_stat_type = U 
expression:(= l_sp_cn_stat_type, "U")
evaluates to t 
expression:
  (select sp_cn_status, subscriber_code, srvctypecode
    from sp_connection
    where (= sp_cn_ref, p_sp_cn_ref))
evaluates to PID  ; UAT0341352 ; IDS ; 
let l_old_status = IDS 
let l_subscriber_code = UAT0341352 
let l_srvctypecode = PID  
expression:(<> (dbinfo-sqlca.sqlerrd2 ), 1)
evaluates to f 
expression:(or (null l_old_status), (<> l_old_status, l_new_status))
evaluates to f 
expression:(= p_sp_cn_stat_type, "B")
evaluates to f 
expression:(<> l_srvctypecode, "ACCT")
evaluates to t 

execute function informix.sp_trigger_cont_stat[procid=9496] ( p_contact_code = UAT0341352 ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
let l_return_status = 100 
let l_cont_status = NULL. 
let l_new_cont_status = NULL. 

execute function informix.ss_sys_cnfg[procid=7787] ( p_cnfg_key = TRIGGER_CONT_STAT ,  p_alt_cnfg_key = NULL. ,  p_default_val = N ,  p_force_upper = Y ,  p_max_length = 1 ,  p_check_is_numeric = N ,  p_check_is_dt = N ,  trace_flg = N ,  resume_flg = N )
default value  p_alt_cnfg_key = NULL.
default value  p_default_val = NULL.
default value  p_force_upper = N
default value  p_max_length = 0
default value  p_check_is_numeric = N
default value  p_check_is_dt = N
default value  trace_flg = N
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

set lock mode to wait 30;
expression:(<procedure> upper, p_cnfg_key)
evaluates to TRIGGER_CONT_STAT                
let p_cnfg_key = TRIGGER_CONT_STAT                
let l_cnfg_val = NULL. 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_cnfg_key))
evaluates to Yes ; 
let l_cnfg_val = Yes 
expression:(and (null l_cnfg_val), (not-null p_alt_cnfg_key))
evaluates to f 
expression:(nvl l_cnfg_val, p_default_val)
evaluates to Yes 
let l_cnfg_val = Yes 
expression:(= p_force_upper, "Y")
evaluates to t 
expression:(<procedure> upper, l_cnfg_val)
evaluates to YES 
let l_cnfg_val = YES 
expression:(> p_max_length, 0)
evaluates to t 
expression:(substring l_cnfg_val, 1, p_max_length)
evaluates to Y 
let l_cnfg_val = Y 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(= p_check_is_dt, "Y")
evaluates to f 
expression:l_cnfg_val
evaluates to Y 
procedure ss_sys_cnfg returns 0 , Y , NULL. 

expression:(<procedure> ss_sys_cnfg, "TRIGGER_CONT_STAT" as p_cnfg_key, "N" as p_default_val, "Y" as p_force_upper, 1 as p_max_length)
evaluates to NULL. ; Y ; 0 ; 
let l_status = 0 
let l_trigger_on_stat = Y 
let l_msg = NULL. 
expression:(= l_trigger_on_stat, "N")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
expression:
  (select cont_status
    from contact
    where (= contact_code, p_contact_code))
evaluates to ACT ; 
let l_cont_status = ACT 
expression:
  (select (count *)
    from sp_connection
    where (and (= subscriber_code, p_contact_code), (<> srvctypecode, "ACCT")))
evaluates to 9 ; 
let l_total_services = 9 
expression:
  (select (count *)
    from sp_connection
    where (and (and (= subscriber_code, p_contact_code), (<> srvctypecode, "ACCT")), (= sys_status, "DIS")))
evaluates to 0 ; 
let l_dis_services = 0 
expression:
  (select (count *)
    from sp_connection
    where (and (and (= subscriber_code, p_contact_code), (<> srvctypecode, "ACCT")), (or (= sp_cn_status, "PDC"), (= sys_status, "DIS"))))
evaluates to 2 ; 
let l_pdc_services = 2 
expression:
  (select (count *)
    from sp_connection
    where (and (and (and (= subscriber_code, p_contact_code), (<> srvctypecode, "ACCT")), (in sys_status, "OPN", "IDS")), (in sp_cn_status, "OPN", "IDS")))
evaluates to 7 ; 
let l_opn_services = 7 
expression:
  (select (count *)
    from sp_connection
    where (and (and (= subscriber_code, p_contact_code), (<> srvctypecode, "ACCT")), (or (= sp_cn_status, "SUS"), (= sys_status, "DIS"))))
evaluates to 0 ; 
let l_sus_services = 0 
expression:(> l_opn_services, 0)
evaluates to t 
let l_new_cont_status = A 
expression:(in l_cont_status, "A", "D", "H", "P", "S")
evaluates to f 
let l_new_cont_status = NULL. 
expression:(= tran_flg, "Y")
evaluates to f 
expression:l_new_cont_status
evaluates to NULL. 
expression:l_return_status
evaluates to 100 
procedure sp_trigger_cont_stat returns 100 , NULL. , NULL. 

expression:(<procedure> sp_trigger_cont_stat, l_subscriber_code as p_contact_code, "N" as tran_flg)
evaluates to NULL. ; NULL. ; 100 ; 
let l_result = 100 
let l_new_cont_status = NULL. 
let l_msg = NULL. 
expression:(= tran_flg, "Y")
evaluates to f 
procedure sp_chg_cn_status returns 0 , NULL. 

expression:(<procedure> sp_chg_cn_status, p_sp_cn_ref as p_sp_cn_ref, l_sp_cn_status as p_sp_cn_status, p_event_ref as p_event_ref, p_mode as p_sp_cn_stat_type, p_spcnhist_to_dt as p_spcnhist_to_dt, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_status = 0 
let l_msg = NULL. 
expression:(not-null p_note_text)
evaluates to f 
expression:(not-null p_evnt_reas_code)
evaluates to f 
expression:(not-null p_priority_id)
evaluates to f 
expression:(not-null p_parent_event)
evaluates to f 
expression:(not-null p_evnt_oth_ref)
evaluates to f 
expression:(not-null p_bill_ref)
evaluates to f 
expression:(not-null p_bill_step_ref)
evaluates to f 
expression:(not-null p_attach_loc)
evaluates to f 
expression:(= p_alert, "Y")
evaluates to f 
expression:(not-null p_fin_ref)
evaluates to f 
let l_event_chg_ref = NULL. 
start select cursor.
(
  select event_chg_ref, chg_code
    from evnt_charge, sp_connection
    where (and (and (and (and (and (= evnt_charge.srvctypecode, sp_connection.srvctypecode), (= event_type, l_event_type)), (= event_code, l_event_code)), (= sp_connection.sp_cn_ref, p_sp_cn_ref)), (between p_created_tm, evnt_chg_wefr, evnt_chg_weto)), (not-null p_sp_cn_ref))
union 
  select event_chg_ref, chg_code
    from evnt_charge
    where (and (and (and (and (= event_type, l_event_type), (= event_code, l_event_code)), (= srvctypecode, "ALL")), (between p_created_tm, evnt_chg_wefr, evnt_chg_weto)), (null p_sp_cn_ref))
)
select cursor iteration.
end cursor
expression:(not-null l_event_chg_ref)
evaluates to f 
expression:(= p_event_triggers, "Y")
evaluates to t 

execute function informix.sp_trigger_event_api[procid=9371] ( p_event_ref = 7159600 ,  p_proc_na_events = Y ,  p_due_tm = NULL. ,  p_user_code = 10018430   ,  p_role_narr = Administrator ,  p_operation_id = NULL. ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_proc_na_events = N
default value  p_due_tm = NULL.
default value  p_user_code = NULL.
default value  p_role_narr = NULL.
default value  p_operation_id = NULL.
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

execute (<procedure> sf_authorise, p_user_code, p_role_narr, p_operation_id);

execute procedure informix.sf_authorise[procid=9490] ( p_user_id = 10018430   ,  p_role = Administrator ,  p_operation_id = NULL. ,  p_args = NULL. )
default value  p_operation_id = NULL.
default value  p_args = NULL.
set_state: owner is informix - utype = 'D'let l_authorised = f 
expression:TRIM ( BOTH ' ' FROM (<procedure> upper, p_role))
evaluates to ADMINISTRATOR 
let p_role = ADMINISTRATOR 
procedure sf_authorise returned no data

let l_insert_cnt = 0 
let l_event_type = NULL. 
expression:
  (select event_type, event_code
    from event
    where (= event_ref, p_event_ref))
evaluates to SC ; CM ; 
let l_event_type = CM 
let l_event_code = SC 
expression:(null l_event_type)
evaluates to f 
let l_sp_cn_ref = NULL. 
expression:
  (select (min sp_cn_ref), (count *)
    from evnt_sp_cn
    where (= event_ref, p_event_ref))
evaluates to 1 ; 239091 ; 
let l_sp_cn_ref = 239091 
let l_count = 1 
expression:(> l_count, 1)
evaluates to f 
let l_contact_code = NULL. 
expression:(= l_count, 0)
evaluates to f 
expression:(not-null l_sp_cn_ref)
evaluates to t 
expression:
  (select srvctypecode, subscriber_code
    from sp_connection
    where (= sp_cn_ref, l_sp_cn_ref))
evaluates to UAT0341352 ; PID  ; 
let l_srvctypecode = PID  
let l_contact_code = UAT0341352 
expression:(= p_proc_na_events, "Y")
evaluates to t 
let l_sched_stat_code = NA 
let l_due_tm = 2025-03-26 15:26:32.000 
expression:(not-null p_due_tm)
evaluates to f 
expression:(and (and (not-null l_sp_cn_ref), (= l_event_type, "CM")), (= l_event_code, "DR"))
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
start select cursor.
select trigger_type, trigger_code
  from evnt_trigger
  where (and (and (and (= event_type, l_event_type), (= event_code, l_event_code)), (= trigger_on_stat, l_sched_stat_code)), (or (= srvctypecode, "ALL"), (= srvctypecode, l_srvctypecode)))
select cursor iteration.
end cursor
expression:(= tran_flg, "Y")
evaluates to f 
expression:(= l_insert_cnt, 0)
evaluates to t 
procedure sp_trigger_event_api returns 100 , NULL. , No events triggered 

expression:(<procedure> sp_trigger_event_api, p_event_ref as p_event_ref, "Y" as p_proc_na_events, p_trigger_due_tm as p_due_tm, p_user_code as p_user_code, p_role_narr as p_role_narr, "N" as tran_flg)
evaluates to No events triggered ; NULL. ; 100 ; 
let l_status = 100 
let l_errcode = NULL. 
let l_msg = No events triggered 
expression:(and (= l_schedule, "Y"), (= p_event_triggers, "Y"))
evaluates to f 
expression:(= l_schedule, "Y")
evaluates to f 
expression:(and (not-null l_acct_void_event), (> (<procedure> length, l_acct_void_event), 6))
evaluates to f 
expression:(not-null p_sp_cn_ref)
evaluates to t 

execute function informix.ss_sys_cnfg_api[procid=9891] ( p_cnfg_key = LINK_ATTRIBUTES_TO_EVENT_CM_SC ,  p_alt_cnfg_key = NULL. ,  p_default_val = N ,  p_force_upper = Y ,  p_max_length = 1 ,  p_check_is_numeric = N ,  p_check_is_dt = N ,  p_user_code = 10018430   ,  p_role_narr = Administrator ,  p_operation_id = NULL. ,  trace_flg = N )
default value  p_alt_cnfg_key = NULL.
default value  p_default_val = NULL.
default value  p_force_upper = N
default value  p_max_length = 0
default value  p_check_is_numeric = N
default value  p_check_is_dt = N
default value  p_user_code = NULL.
default value  p_role_narr = NULL.
default value  p_operation_id = NULL.
default value  trace_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

set lock mode to wait 30;

execute (<procedure> sf_authorise, p_user_code, p_role_narr, p_operation_id);

execute procedure informix.sf_authorise[procid=9490] ( p_user_id = 10018430   ,  p_role = Administrator ,  p_operation_id = NULL. ,  p_args = NULL. )
default value  p_operation_id = NULL.
default value  p_args = NULL.
set_state: owner is informix - utype = 'D'let l_authorised = f 
expression:TRIM ( BOTH ' ' FROM (<procedure> upper, p_role))
evaluates to ADMINISTRATOR 
let p_role = ADMINISTRATOR 
procedure sf_authorise returned no data

expression:(<procedure> upper, p_cnfg_key)
evaluates to LINK_ATTRIBUTES_TO_EVENT_CM_SC   
let p_cnfg_key = LINK_ATTRIBUTES_TO_EVENT_CM_SC   
let l_cnfg_val = NULL. 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_cnfg_key))
evaluates to NULL. ; 
let l_cnfg_val = NULL. 
expression:(and (null l_cnfg_val), (not-null p_alt_cnfg_key))
evaluates to f 
expression:(nvl l_cnfg_val, p_default_val)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_force_upper, "Y")
evaluates to t 
expression:(<procedure> upper, l_cnfg_val)
evaluates to N 
let l_cnfg_val = N 
expression:(> p_max_length, 0)
evaluates to t 
expression:(substring l_cnfg_val, 1, p_max_length)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(= p_check_is_dt, "Y")
evaluates to f 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(|| (|| "{"Value": "", TRIM ( BOTH ' ' FROM l_cnfg_val)), ""}")
evaluates to {"Value": "N"}                                                                                                                                                                                                                                                                                               
let l_json = {"Value": "N"}                                                                                                                                                                                                                                                                                               
expression:TRIM ( BOTH ' ' FROM l_json)
evaluates to {"Value": "N"}                                                                                                                                                                                                                                                                                               
procedure ss_sys_cnfg_api returns 200 , {"Value": "N"}                                                                                                                                                                                                                                                                                               , NULL. , NULL. 

expression:(<procedure> ss_sys_cnfg_api, (|| (|| (|| "LINK_ATTRIBUTES_TO_EVENT_", l_event_type), "_"), l_event_code) as p_cnfg_key, "N" as p_default_val, 1 as p_max_length, "Y" as p_force_upper, p_user_code as p_user_code, p_role_narr as p_role_narr)
evaluates to NULL. ; NULL. ; {"Value": "N"}                                                                                                                                                                                                                                                                                               ; 200 ; 
let l_status = 200 
let l_json = {"Value": "N"}                                                                                                                                                                                                                                                                                               
let l_errcode = NULL. 
let l_msg = NULL. 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"Value": "N"}                                                                                                                                                                                                                                                 ,  p_attrib_name = Value ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "Value" 
let p_attrib_name = "Value" 
expression:(<procedure> length, p_attrib_name)
evaluates to 7 
let l_attrib_name_len = 7 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 2 
let l_pos = 2 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 8 
let l_pos = 8 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 9 
let l_pos = 9 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 10 
let l_pos = 10 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 11 
let l_pos = 11 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = "N"} ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to f 
expression:(<unknown op>: 87 p_quoted)
evaluates to t 
expression:(= l_char, """)
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 12 
let l_attrib_start_pos = 12 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 12 
let l_pos = 12 
expression:(substring p_json, l_pos, 1)
evaluates to N 
let l_char = N 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 13 
let l_pos = 13 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to t 
expression:(null l_attrib_str)
evaluates to t 
expression:(substring p_json, l_attrib_start_pos, (- l_pos, l_attrib_start_pos))
evaluates to N 
let l_attrib_str = N 
expression:TRIM ( BOTH ' ' FROM l_attrib_str)
evaluates to N 
procedure sf_json_get_attrib returns N 

expression:(<procedure> sf_json_get_attrib, l_json, "Value", "t")
evaluates to N 
let l_link_attributes = N 
expression:(= l_link_attributes, "Y")
evaluates to f 
expression:(and (= l_schedule, "Y"), (= p_create_sms, "Y"))
evaluates to f 

execute function informix.sf_json_attrib[procid=9095] ( p_name = Id ,  p_value = 7159600 ,  p_type = NUMBER ,  p_first = t ,  p_last = t ,  p_escape = t )
default value  p_type = STRING
default value  p_first = f
default value  p_last = f
default value  p_escape = t
set_state: owner is informix - utype = 'D'expression:(<procedure> chr, 9)
evaluates to 	 
let l_ascii = 	 
let l_json =  
expression:(or (or (= (<procedure> upper, p_type), "STRING"), (= (<procedure> upper, p_type), "DATETIME")), (= (<procedure> upper, p_type), "DATE"))
evaluates to f 
expression:(or (= (<procedure> upper, p_type), "NUMBER"), (= (<procedure> upper, p_type), "INTEGER"))
evaluates to t 
expression:(null p_value)
evaluates to f 
expression:(|| (|| (|| (|| TRIM ( BOTH ' ' FROM l_json), """), TRIM ( BOTH ' ' FROM p_name)), "": "), p_value)
evaluates to "Id": 7159600 
let l_json = "Id": 7159600 
expression:(not (<unknown op>: 87 p_last))
evaluates to f 
expression:(|| TRIM ( BOTH ' ' FROM l_json), "}")
evaluates to "Id": 7159600} 
let l_json = "Id": 7159600} 
expression:(<unknown op>: 87 p_first)
evaluates to t 
expression:(|| "{", TRIM ( BOTH ' ' FROM l_json))
evaluates to {"Id": 7159600} 
let l_json = {"Id": 7159600} 
expression:TRIM ( BOTH ' ' FROM l_json)
evaluates to {"Id": 7159600} 
procedure sf_json_attrib returns {"Id": 7159600} 

expression:(<procedure> sf_json_attrib, "Id", p_event_ref, "NUMBER", "t", "t")
evaluates to {"Id": 7159600} 
let l_json = {"Id": 7159600} 
expression:(= tran_flg, "Y")
evaluates to f 
expression:TRIM ( BOTH ' ' FROM l_json)
evaluates to {"Id": 7159600} 
procedure sp_events_instances_service_api returns 201 , {"Id": 7159600} , NULL. , NULL. 

expression:(<procedure> sp_events_instances_service_api, p_sp_cn_ref as p_sp_cn_ref, l_json as p_request_body, p_user_code as p_user_code, p_role_narr as p_role_narr, p_operation_id as p_operation_id, "N" as tran_flg)
evaluates to NULL. ; NULL. ; {"Id": 7159600} ; 201 ; 
let l_return = 201 
let l_json = {"Id": 7159600} 
let l_errcode = NULL. 
let l_msg = NULL. 
expression:(not-in l_return, 200, 201, 204)
evaluates to f 

execute function informix.sf_get_property[procid=9798] ( p_json = {"Id": 7159600} ,  p_name = Id ,  p_data_type = INTEGER ,  p_raise_exception = f ,  p_errorcode = NULL. ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to f 
expression:(= p_data_type, "BOOLEAN")
evaluates to f 
expression:(= p_data_type, "BOOLEAN_YN")
evaluates to f 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"Id": 7159600} ,  p_attrib_name = Id ,  p_quoted = f )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "Id" 
let p_attrib_name = "Id" 
expression:(<procedure> length, p_attrib_name)
evaluates to 4 
let l_attrib_name_len = 4 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 2 
let l_pos = 2 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 5 
let l_pos = 5 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 6 
let l_pos = 6 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 7 
let l_pos = 7 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 8 
let l_pos = 8 
expression:(substring p_json, l_pos, 1)
evaluates to 7 
let l_char = 7 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = 7159 ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to f 
expression:(<unknown op>: 87 p_quoted)
evaluates to f 
expression:(<> l_char, " ")
evaluates to t 
expression:l_pos
evaluates to 8 
let l_attrib_start_pos = 8 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 9 
let l_pos = 9 
expression:(substring p_json, l_pos, 1)
evaluates to 1 
let l_char = 1 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 10 
let l_pos = 10 
expression:(substring p_json, l_pos, 1)
evaluates to 5 
let l_char = 5 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 11 
let l_pos = 11 
expression:(substring p_json, l_pos, 1)
evaluates to 9 
let l_char = 9 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 12 
let l_pos = 12 
expression:(substring p_json, l_pos, 1)
evaluates to 6 
let l_char = 6 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 13 
let l_pos = 13 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 14 
let l_pos = 14 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 15 
let l_pos = 15 
expression:(substring p_json, l_pos, 1)
evaluates to } 
let l_char = } 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to t 
expression:(substring p_json, l_attrib_start_pos, (- l_pos, l_attrib_start_pos))
evaluates to 7159600 
let l_attrib_str = 7159600 

execute function informix.equal[procid=-114] (   = 7159600 ,    = NULL )
expression:(= (<procedure> upper, TRIM ( BOTH ' ' FROM l_attrib_str)), "NULL")
evaluates to f 
expression:TRIM ( BOTH ' ' FROM l_attrib_str)
evaluates to 7159600 
procedure sf_json_get_attrib returns 7159600 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "f")
evaluates to 7159600 
let l_property_value = 7159600 

execute function informix.equal[procid=-114] (   = 7159600 ,    =  )
expression:(= l_property_value, "")
evaluates to f 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to t 
expression:(in p_data_type, "INTEGER")
evaluates to t 
expression:l_property_value
evaluates to 7159600 
let l_integer = 7159600 
expression:(not-null p_validations)
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to 7159600 
procedure sf_get_property returns 7159600 

expression:(<procedure> sf_get_property, l_json, "Id", "INTEGER")
evaluates to 7159600 
let l_srvc_evnt_ref = 7159600 
expression:(not-null p_prnt_sp_cn_ref)
evaluates to f 
expression:(or (= p_set_connect, "Y"), (= p_set_connect, "E"))
evaluates to t 

execute function informix.sp_connect[procid=8508] ( p_sp_cn_ref = 239091 ,  p_scheduled_dt = 2025-03-26 02:03:41 ,  p_note = NULL. ,  p_set_connect = Y ,  p_user = webuser ,  p_allow_connect = N ,  p_event_triggers = Y ,  p_source = NULL. ,  resume_flg = N ,  tran_flg = N ,  trace_flg = N )
default value  p_scheduled_dt = 2025-03-26 15:26:32.000
default value  p_note = NULL.
default value  p_set_connect = N
default value  p_user = webuser
default value  p_allow_connect = N
default value  p_event_triggers = Y
default value  p_source = NULL.
default value  resume_flg = N
default value  tran_flg = Y
default value  trace_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
expression:
  (select sp_connected, sp_disconnected, nt_connected
    from sp_connection
    where (= sp_cn_ref, p_sp_cn_ref))
evaluates to NULL. ; 2025-03-26 02:03:41 ; 2025-03-26 02:03:41 ; 
let l_sp_connected = 2025-03-26 02:03:41 
let l_sp_disconnected = 2025-03-26 02:03:41 
let l_nt_connected = NULL. 
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
expression:(<> l_sp_connected, l_sp_disconnected)
evaluates to f 

execute function informix.ss_has_conn_event[procid=1809] ( p_sp_cn_ref = 239091 ,  resume_flg = N )
default value  resume_flg = N
set_state: owner is informix - utype = 'D'let l_count = 0 
expression:
  (select (count *)
    from sp_connection
    where (= sp_cn_ref, p_sp_cn_ref))
evaluates to 1 ; 
let l_count = 1 
expression:(<> l_count, 1)
evaluates to f 
start procedure cursor.
execute (<procedure> ss_flex_code, "init_conn" as p_sys_table,  <NULL>  as p_sys_hard_group,  <NULL>  as p_sys_hard_code, "Y" as p_multiple_rows, "Could not get init_conn events from sys_code." as p_msg, "Z" as resume_flg)
default value  p_multiple_rows = N
default value  p_msg = NULL.
default value  resume_flg = N
iteration of cursory procedure ss_flex_code

execute function informix.ss_flex_code[procid=1382] ( p_sys_table = init_conn ,  p_sys_hard_group = NULL. ,  p_sys_hard_code = NULL. ,  p_multiple_rows = Y ,  p_msg = Could not get init_conn events from sys_code. ,  resume_flg = Z )
set_state: owner is informix - utype = 'D'expression:(not-in resume_flg, "Y", "N", "Z")
evaluates to f 
let l_found = N 
let l_tmp_key1 = NULL. 
expression:(not-null p_msg)
evaluates to t 
expression:p_msg
evaluates to Could not get init_conn events from sys_code. 
let l_msg = Could not get init_conn events from sys_code. 
start select cursor.
select flex_key1, flex_key2
  from sys_code
  where (and (and (= sys_table, p_sys_table), (or (= sys_hard_group, p_sys_hard_group), (null p_sys_hard_group))), (or (= sys_hard_code, p_sys_hard_code), (null p_sys_hard_code)))
  order by flex_key2
select cursor iteration.
select cursor returns CM , IC 
expression:(= l_found, "N")
evaluates to t 
expression:l_flex_key1
evaluates to CM 
let l_tmp_key1 = CM 
expression:l_flex_key2
evaluates to IC 
let l_tmp_key2 = IC 
let l_found = Y 
select cursor iteration.
select cursor returns CM , PI 
expression:(= l_found, "N")
evaluates to f 
expression:(= p_multiple_rows, "N")
evaluates to f 
expression:(not-null l_tmp_key1)
evaluates to t 
expression:l_tmp_key2
evaluates to IC 
expression:l_tmp_key1
evaluates to CM 
procedure ss_flex_code returns 0 , CM , IC 


execute function informix.ss_event_present[procid=1808] ( p_sp_cn_ref = 239091 ,  p_event_type = CM ,  p_event_code = IC ,  p_scheduled = Y ,  p_sched_stat_code = NULL. ,  p_translate = N ,  resume_flg = N )
default value  p_scheduled = Y
default value  p_sched_stat_code = NULL.
default value  p_translate = Y
default value  resume_flg = N
set_state: owner is informix - utype = 'D'let l_event_ref = NULL. 
expression:(= p_translate, "Y")
evaluates to f 
expression:(= p_scheduled, "Y")
evaluates to t 
expression:
  (select (count *)
    from event, schedule
    where (and (and (and (and (= event.event_type, p_event_type), (= event.event_code, p_event_code)), (= schedule.event_ref, event.event_ref)), (or (and (null p_sched_stat_code), (<> schedule.sched_stat_code, "V")), (and (not-null p_sched_stat_code), (= schedule.sched_stat_code, p_sched_stat_code)))), (in event.event_ref, 
      (select event_ref
        from evnt_sp_cn
        where (= evnt_sp_cn.sp_cn_ref, p_sp_cn_ref)))))
evaluates to 0 ; 
let l_count = 0 
expression:(= l_count, 1)
evaluates to f 
expression:l_event_ref
evaluates to NULL. 
expression:l_count
evaluates to 0 
procedure ss_event_present returns 0 , 0 , NULL. , NULL. 

expression:(<procedure> ss_event_present, p_sp_cn_ref as p_sp_cn_ref, l_event_type as p_event_type, l_event_code as p_event_code, "Y" as p_scheduled, "N" as p_translate)
evaluates to NULL. ; NULL. ; 0 ; 0 ; 
let l_status = 0 
let l_count = 0 
let l_event_ref = NULL. 
let l_msg = NULL. 
expression:(<> l_status, 0)
evaluates to f 
expression:(> l_count, 1)
evaluates to f 
expression:(> l_count, 0)
evaluates to f 
iteration of cursory procedure ss_flex_code
set_state: owner is informix - utype = 'D'let l_tmp_key1 = NULL. 
expression:l_flex_key2
evaluates to PI 
expression:l_flex_key1
evaluates to CM 
procedure ss_flex_code returns 0 , CM , PI 


execute function informix.ss_event_present[procid=1808] ( p_sp_cn_ref = 239091 ,  p_event_type = CM ,  p_event_code = PI ,  p_scheduled = Y ,  p_sched_stat_code = NULL. ,  p_translate = N ,  resume_flg = N )
default value  p_scheduled = Y
default value  p_sched_stat_code = NULL.
default value  p_translate = Y
default value  resume_flg = N
set_state: owner is informix - utype = 'D'let l_event_ref = NULL. 
expression:(= p_translate, "Y")
evaluates to f 
expression:(= p_scheduled, "Y")
evaluates to t 
expression:
  (select (count *)
    from event, schedule
    where (and (and (and (and (= event.event_type, p_event_type), (= event.event_code, p_event_code)), (= schedule.event_ref, event.event_ref)), (or (and (null p_sched_stat_code), (<> schedule.sched_stat_code, "V")), (and (not-null p_sched_stat_code), (= schedule.sched_stat_code, p_sched_stat_code)))), (in event.event_ref, 
      (select event_ref
        from evnt_sp_cn
        where (= evnt_sp_cn.sp_cn_ref, p_sp_cn_ref)))))
evaluates to 0 ; 
let l_count = 0 
expression:(= l_count, 1)
evaluates to f 
expression:l_event_ref
evaluates to NULL. 
expression:l_count
evaluates to 0 
procedure ss_event_present returns 0 , 0 , NULL. , NULL. 

expression:(<procedure> ss_event_present, p_sp_cn_ref as p_sp_cn_ref, l_event_type as p_event_type, l_event_code as p_event_code, "Y" as p_scheduled, "N" as p_translate)
evaluates to NULL. ; NULL. ; 0 ; 0 ; 
let l_status = 0 
let l_count = 0 
let l_event_ref = NULL. 
let l_msg = NULL. 
expression:(<> l_status, 0)
evaluates to f 
expression:(> l_count, 1)
evaluates to f 
expression:(> l_count, 0)
evaluates to f 
iteration of cursory procedure ss_flex_code
set_state: owner is informix - utype = 'D'select cursor iteration.
end cursor
expression:(not-null l_tmp_key1)
evaluates to f 
expression:(= l_found, "N")
evaluates to f 
procedure ss_flex_code returned no data

end cursor
procedure ss_has_conn_event returns 0 , N , NULL. , NULL. 

expression:(<procedure> ss_has_conn_event, p_sp_cn_ref as p_sp_cn_ref)
evaluates to NULL. ; NULL. ; N ; 0 ; 
let l_result = 0 
let l_has_conn_event = N 
let l_conn_event_ref = NULL. 
let l_msg = NULL. 
expression:(and (<> l_has_conn_event, "N"), (= p_allow_connect, "N"))
evaluates to f 
expression:(<> l_has_conn_event, "N")
evaluates to f 

execute function informix.ss_conn_event_code[procid=5612] ( p_sp_cn_ref = 239091 ,  resume_flg = N ,  trace_flg = N )
default value  resume_flg = N
default value  trace_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
let l_cnfg_type = NULL. 
let l_cnfg_code = NULL. 
let l_type = NEW 
let l_srvctypecode = NULL. 

execute function informix.ss_is_port_conn[procid=1392] ( p_sp_cn_ref = 239091 ,  resume_flg = N )
default value  resume_flg = N
set_state: owner is informix - utype = 'D'let l_count = 0 
expression:
  (select (count *)
    from sp_connection
    where (= sp_cn_ref, p_sp_cn_ref))
evaluates to 1 ; 
let l_count = 1 
expression:(<> l_count, 1)
evaluates to f 
let l_count = 0 
expression:
  (select (count *)
    from sp_cn_port
    where (= sp_cn_ref, p_sp_cn_ref))
evaluates to 0 ; 
let l_count = 0 
expression:(= l_count, 0)
evaluates to t 

execute function informix.ss_event_present[procid=1808] ( p_sp_cn_ref = 239091 ,  p_event_type = CM ,  p_event_code = PS ,  p_scheduled = N ,  p_sched_stat_code = NULL. ,  p_translate = Y ,  resume_flg = N )
default value  p_scheduled = Y
default value  p_sched_stat_code = NULL.
default value  p_translate = Y
default value  resume_flg = N
set_state: owner is informix - utype = 'D'let l_event_ref = NULL. 
expression:(= p_translate, "Y")
evaluates to t 

execute function informix.ss_flex_code[procid=1382] ( p_sys_table = evnt_code ,  p_sys_hard_group = CM ,  p_sys_hard_code = PS ,  p_multiple_rows = N ,  p_msg = NULL. ,  resume_flg = Z )
default value  p_multiple_rows = N
default value  p_msg = NULL.
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(not-in resume_flg, "Y", "N", "Z")
evaluates to f 
let l_found = N 
let l_tmp_key1 = NULL. 
expression:(not-null p_msg)
evaluates to f 
expression:(|| (|| "Flex key not found: ", TRIM ( BOTH ' ' FROM p_sys_table)), " | ")
evaluates to Flex key not found: evnt_code |  
let l_msg = Flex key not found: evnt_code |  
expression:(not-null p_sys_hard_group)
evaluates to t 
expression:(|| (|| l_msg, TRIM ( BOTH ' ' FROM p_sys_hard_group)), " | ")
evaluates to Flex key not found: evnt_code | CM |  
let l_msg = Flex key not found: evnt_code | CM |  
expression:(not-null p_sys_hard_code)
evaluates to t 
expression:(|| (|| l_msg, TRIM ( BOTH ' ' FROM p_sys_hard_code)), ". ")
evaluates to Flex key not found: evnt_code | CM | PS.  
let l_msg = Flex key not found: evnt_code | CM | PS.  
start select cursor.
select flex_key1, flex_key2
  from sys_code
  where (and (and (= sys_table, p_sys_table), (or (= sys_hard_group, p_sys_hard_group), (null p_sys_hard_group))), (or (= sys_hard_code, p_sys_hard_code), (null p_sys_hard_code)))
  order by flex_key2
select cursor iteration.
select cursor returns CM , PS 
expression:(= l_found, "N")
evaluates to t 
expression:l_flex_key1
evaluates to CM 
let l_tmp_key1 = CM 
expression:l_flex_key2
evaluates to PS 
let l_tmp_key2 = PS 
let l_found = Y 
select cursor iteration.
end cursor
expression:(not-null l_tmp_key1)
evaluates to t 
expression:l_tmp_key2
evaluates to PS 
expression:l_tmp_key1
evaluates to CM 
procedure ss_flex_code returns 0 , CM , PS 

expression:(<procedure> ss_flex_code, "evnt_code" as p_sys_table, p_event_type as p_sys_hard_group, p_event_code as p_sys_hard_code, "Z" as resume_flg)
evaluates to PS                               ; CM                               ; 0 ; 
let l_result = 0 
let p_event_type = CM                               
let p_event_code = PS                               
expression:(= p_scheduled, "Y")
evaluates to f 
expression:
  (select (count *)
    from evnt_sp_cn, event
    where (and (and (and (= event.event_type, p_event_type), (= event.event_code, p_event_code)), (= event.event_ref, evnt_sp_cn.event_ref)), (= evnt_sp_cn.sp_cn_ref, p_sp_cn_ref)))
evaluates to 0 ; 
let l_count = 0 
expression:(= l_count, 1)
evaluates to f 
expression:l_event_ref
evaluates to NULL. 
expression:l_count
evaluates to 0 
procedure ss_event_present returns 0 , 0 , NULL. , NULL. 

expression:(<procedure> ss_event_present, p_sp_cn_ref as p_sp_cn_ref, "CM" as p_event_type, "PS" as p_event_code, "N" as p_scheduled, "Y" as p_translate)
evaluates to NULL. ; NULL. ; 0 ; 0 ; 
let l_status = 0 
let l_count = 0 
let l_event_ref = NULL. 
let l_msg = NULL. 
expression:(= l_count, 1)
evaluates to f 
procedure ss_is_port_conn returns 0 , N , NULL. 

expression:(<procedure> ss_is_port_conn, p_sp_cn_ref as p_sp_cn_ref)
evaluates to NULL. ; N ; 0 ; 
let l_result = 0 
let l_is_port = N 
let l_msg = NULL. 
expression:(= l_is_port, "Y")
evaluates to f 
expression:
  (select srvctypecode
    from sp_connection
    where (= sp_cn_ref, p_sp_cn_ref))
evaluates to PID  ; 
let l_srvctypecode = PID  
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, (|| (|| TRIM ( BOTH ' ' FROM l_type), "_SERVICE_EVENT_TYPE_"), TRIM ( BOTH ' ' FROM l_srvctypecode))))
evaluates to NULL. ; 
let l_cnfg_type = NULL. 
expression:(or (not-null l_cnfg_type), (<> l_cnfg_type, ""))
evaluates to NULL. 
let l_event_type = CM 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, (|| (|| l_type, "_SERVICE_EVENT_CODE_"), TRIM ( BOTH ' ' FROM l_srvctypecode))))
evaluates to NULL. ; 
let l_cnfg_code = NULL. 
expression:(or (not-null l_cnfg_code), (<> l_cnfg_code, ""))
evaluates to NULL. 
expression:(= l_is_port, "Y")
evaluates to f 
let l_event_code = IC 
expression:l_event_code
evaluates to IC 
expression:l_event_type
evaluates to CM 
procedure ss_conn_event_code returns 0 , CM , IC , NULL. 

expression:(<procedure> ss_conn_event_code, p_sp_cn_ref as p_sp_cn_ref)
evaluates to NULL. ; IC ; CM ; 0 ; 
let l_result = 0 
let l_event_type = CM 
let l_event_code = IC 
let l_msg = NULL. 

execute function informix.sp_new_event[procid=9653] ( p_event_ref = 0 ,  p_event_type = CM ,  p_event_code = IC ,  p_created_by = webuser ,  p_parent_event = NULL. ,  p_evntrelntypecode = F ,  p_evnt_oth_ref = NULL. ,  p_sp_cn_ref = 239091 ,  p_contact_code = NULL. ,  p_created_tm = 2025-03-26 15:26:32.000 ,  p_note_text = NULL. ,  p_note_text2 = NULL. ,  p_evnt_reas_code = NULL. ,  p_to_login = system ,  p_to_dept = SYS ,  p_sched_code = ACT ,  p_due_tm = 2025-03-26 02:03:41 ,  p_trigger_due_tm = NULL. ,  p_sched_stat_code = O ,  p_stat_tm = 2025-03-26 15:26:32.000 ,  p_stat_effect_by = webuser ,  p_bill_ref = NULL. ,  p_bill_event_type = NULL. ,  p_bill_step_ref = NULL. ,  p_attach_loc = NULL. ,  p_priority_id = NULL. ,  p_alert = N ,  p_translate = Y ,  p_mode = U ,  p_creditchkevnt_crt = Y ,  p_spcnhist_to_dt = NULL. ,  p_event_triggers = Y ,  p_fin_ref = NULL. ,  p_create_sms = Y ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_event_ref = 0
default value  p_created_by = webuser
default value  p_parent_event = NULL.
default value  p_evntrelntypecode = F
default value  p_evnt_oth_ref = NULL.
default value  p_sp_cn_ref = NULL.
default value  p_contact_code = NULL.
default value  p_created_tm = 2025-03-26 15:26:32.000
default value  p_note_text = NULL.
default value  p_note_text2 = NULL.
default value  p_evnt_reas_code = NULL.
default value  p_to_login = NULL.
default value  p_to_dept = NULL.
default value  p_sched_code = NULL.
default value  p_due_tm = 2025-03-26 15:26:32.000
default value  p_trigger_due_tm = NULL.
default value  p_sched_stat_code = NULL.
default value  p_stat_tm = 2025-03-26 15:26:32.000
default value  p_stat_effect_by = webuser
default value  p_bill_ref = NULL.
default value  p_bill_event_type = NULL.
default value  p_bill_step_ref = NULL.
default value  p_attach_loc = NULL.
default value  p_priority_id = NULL.
default value  p_alert = N
default value  p_translate = N
default value  p_mode = U
default value  p_creditchkevnt_crt = Y
default value  p_spcnhist_to_dt = NULL.
default value  p_event_triggers = Y
default value  p_fin_ref = NULL.
default value  p_create_sms = Y
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 

set lock mode to wait 5;
expression:(or (null p_event_type), (null p_event_code))
evaluates to f 
expression:(and (not-null p_bill_ref), (null p_bill_event_type))
evaluates to f 
let l_acct_void_event = NULL. 
let l_contact_code = NULL. 
let l_sys_status = NULL. 
let l_cm_ic_cnt = NULL. 
let l_cm_pi_cnt = NULL. 
let l_sm_sc_cnt = NULL. 
let l_sm_sp_cnt = NULL. 
let l_event_ref = NULL. 

execute function informix.ss_sys_cnfg[procid=7787] ( p_cnfg_key = ACCT_TO_VOID_EVENT ,  p_alt_cnfg_key = NULL. ,  p_default_val = N ,  p_force_upper = N ,  p_max_length = 10 ,  p_check_is_numeric = N ,  p_check_is_dt = N ,  trace_flg = N ,  resume_flg = N )
default value  p_alt_cnfg_key = NULL.
default value  p_default_val = NULL.
default value  p_force_upper = N
default value  p_max_length = 0
default value  p_check_is_numeric = N
default value  p_check_is_dt = N
default value  trace_flg = N
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

set lock mode to wait 30;
expression:(<procedure> upper, p_cnfg_key)
evaluates to ACCT_TO_VOID_EVENT               
let p_cnfg_key = ACCT_TO_VOID_EVENT               
let l_cnfg_val = NULL. 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_cnfg_key))
evaluates to NULL. ; 
let l_cnfg_val = NULL. 
expression:(and (null l_cnfg_val), (not-null p_alt_cnfg_key))
evaluates to f 
expression:(nvl l_cnfg_val, p_default_val)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_force_upper, "Y")
evaluates to f 
expression:(> p_max_length, 0)
evaluates to t 
expression:(substring l_cnfg_val, 1, p_max_length)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(= p_check_is_dt, "Y")
evaluates to f 
expression:l_cnfg_val
evaluates to N 
procedure ss_sys_cnfg returns 0 , N , NULL. 

expression:(<procedure> ss_sys_cnfg, "ACCT_TO_VOID_EVENT" as p_cnfg_key, "N" as p_default_val, 10 as p_max_length, "N" as p_force_upper)
evaluates to NULL. ; N ; 0 ; 
let l_return = 0 
let l_acct_void_event = N 
let l_msg = NULL. 
expression:(= p_translate, "Y")
evaluates to t 

execute function informix.ss_flex_code[procid=1382] ( p_sys_table = evnt_code ,  p_sys_hard_group = CM ,  p_sys_hard_code = IC ,  p_multiple_rows = N ,  p_msg = NULL. ,  resume_flg = Z )
default value  p_multiple_rows = N
default value  p_msg = NULL.
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(not-in resume_flg, "Y", "N", "Z")
evaluates to f 
let l_found = N 
let l_tmp_key1 = NULL. 
expression:(not-null p_msg)
evaluates to f 
expression:(|| (|| "Flex key not found: ", TRIM ( BOTH ' ' FROM p_sys_table)), " | ")
evaluates to Flex key not found: evnt_code |  
let l_msg = Flex key not found: evnt_code |  
expression:(not-null p_sys_hard_group)
evaluates to t 
expression:(|| (|| l_msg, TRIM ( BOTH ' ' FROM p_sys_hard_group)), " | ")
evaluates to Flex key not found: evnt_code | CM |  
let l_msg = Flex key not found: evnt_code | CM |  
expression:(not-null p_sys_hard_code)
evaluates to t 
expression:(|| (|| l_msg, TRIM ( BOTH ' ' FROM p_sys_hard_code)), ". ")
evaluates to Flex key not found: evnt_code | CM | IC.  
let l_msg = Flex key not found: evnt_code | CM | IC.  
start select cursor.
select flex_key1, flex_key2
  from sys_code
  where (and (and (= sys_table, p_sys_table), (or (= sys_hard_group, p_sys_hard_group), (null p_sys_hard_group))), (or (= sys_hard_code, p_sys_hard_code), (null p_sys_hard_code)))
  order by flex_key2
select cursor iteration.
select cursor returns CM , IC 
expression:(= l_found, "N")
evaluates to t 
expression:l_flex_key1
evaluates to CM 
let l_tmp_key1 = CM 
expression:l_flex_key2
evaluates to IC 
let l_tmp_key2 = IC 
let l_found = Y 
select cursor iteration.
end cursor
expression:(not-null l_tmp_key1)
evaluates to t 
expression:l_tmp_key2
evaluates to IC 
expression:l_tmp_key1
evaluates to CM 
procedure ss_flex_code returns 0 , CM , IC 

expression:(<procedure> ss_flex_code, "evnt_code" as p_sys_table, p_event_type as p_sys_hard_group, p_event_code as p_sys_hard_code, "Z" as resume_flg)
evaluates to IC                               ; CM                               ; 0 ; 
let l_return = 0 
let l_event_type = CM                               
let l_event_code = IC                               
let l_count = 0 
expression:
  (select (count *)
    from evnt_code
    where (and (= event_type, l_event_type), (= event_code, l_event_code)))
evaluates to 1 ; 
let l_count = 1 
expression:(<> l_count, 1)
evaluates to f 
expression:(and (and (not-null p_to_login), (not-null p_to_dept)), (not-null p_sched_code))
evaluates to t 
let l_schedule = Y 

execute function informix.sievent[procid=7558] ( p_event_ref = 0 ,  p_event_type = CM ,  p_event_code = IC ,  p_created_by = webuser ,  p_created_tm = 2025-03-26 15:26:32 ,  tran_flg = N )
default value  p_event_ref = 0
default value  p_created_by = webuser
default value  p_created_tm = 2025-03-26 15:26:32
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 

insert into event(event_ref, event_type, event_code, created_by, created_tm)
  values (p_event_ref, p_event_type, p_event_code, p_created_by, p_created_tm);

before actions:

end before actions

for each row actions: 

end for each row actions

after actions:

end after actions
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
let return_status = 0 
expression:(dbinfo-sqlca.sqlerrd1 )
evaluates to 7159601 
let ser_num = 7159601 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
expression:ser_num
evaluates to 7159601 
expression:return_status
evaluates to 0 
procedure sievent returns 0 , 7159601 

expression:(<procedure> sievent, p_event_ref as p_event_ref, l_event_type as p_event_type, l_event_code as p_event_code, p_created_by as p_created_by, p_created_tm as p_created_tm, "N" as tran_flg)
evaluates to 7159601 ; 0 ; 
let l_return = 0 
let p_event_ref = 7159601 
expression:(not-null p_contact_code)
evaluates to f 
expression:(not-null p_sp_cn_ref)
evaluates to t 

execute function informix.sievnt_sp_cn[procid=893] ( p_event_ref = 7159601 ,  p_sp_cn_ref = 239091 ,  tran_flg = N )
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 

insert into evnt_sp_cn(event_ref, sp_cn_ref)
  values (p_event_ref, p_sp_cn_ref);

before actions:

end before actions

for each row actions: 

end for each row actions

after actions:

end after actions
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
let return_status = 0 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
expression:return_status
evaluates to 0 
procedure sievnt_sp_cn returns 0 

expression:(<procedure> sievnt_sp_cn, p_event_ref as p_event_ref, p_sp_cn_ref as p_sp_cn_ref, "N" as tran_flg)
evaluates to 0 
let l_return = 0 
expression:(= l_schedule, "N")
evaluates to f 
expression:p_sched_stat_code
evaluates to O  
let l_sched_stat_code = O  
let l_sp_cn_status = NULL. 
expression:
  (select evnt_code_sv_st.sp_cn_status
    from sp_connection, evnt_code_sv_st
    where (and (and (and (and (= sp_connection.srvctypecode, evnt_code_sv_st.srvctypecode), (= event_type, l_event_type)), (= event_code, l_event_code)), (= sched_stat_code, l_sched_stat_code)), (= sp_cn_ref, p_sp_cn_ref)))
evaluates to NULL. ; 
let l_sp_cn_status = NULL. 
expression:(null l_sp_cn_status)
evaluates to t 
expression:
  (select sp_cn_status
    from evnt_code_sv_st
    where (and (and (and (= event_type, l_event_type), (= event_code, l_event_code)), (= sched_stat_code, l_sched_stat_code)), (= srvctypecode, "ALL")))
evaluates to NULL. ; 
let l_sp_cn_status = NULL. 
expression:(not-null l_sp_cn_status)
evaluates to f 

execute function informix.sp_add_event_note[procid=1708] ( p_event_ref = 7159601 ,  p_note_text = NULL. ,  resume_flg = N ,  tran_flg = N )
default value  resume_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 
expression:(not-null p_note_text)
evaluates to f 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
procedure sp_add_event_note returns 0 , NULL. 

expression:(<procedure> sp_add_event_note, p_event_ref as p_event_ref, p_note_text as p_note_text, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_return = 0 
let l_msg = NULL. 

execute function informix.sp_add_event_note[procid=1708] ( p_event_ref = 7159601 ,  p_note_text = NULL. ,  resume_flg = N ,  tran_flg = N )
default value  resume_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 
expression:(not-null p_note_text)
evaluates to f 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
procedure sp_add_event_note returns 0 , NULL. 

expression:(<procedure> sp_add_event_note, p_event_ref as p_event_ref, p_note_text2 as p_note_text, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_return = 0 
let l_msg = NULL. 
expression:(not-null p_evnt_reas_code)
evaluates to f 
expression:(not-null p_priority_id)
evaluates to f 
expression:(not-null p_parent_event)
evaluates to f 
expression:(not-null p_evnt_oth_ref)
evaluates to f 
expression:(not-null p_bill_ref)
evaluates to f 
expression:(not-null p_bill_step_ref)
evaluates to f 
expression:(not-null p_attach_loc)
evaluates to f 
expression:(= p_alert, "Y")
evaluates to f 
expression:(not-null p_fin_ref)
evaluates to f 
let l_event_chg_ref = NULL. 
start select cursor.
(
  select event_chg_ref, chg_code
    from evnt_charge, sp_connection
    where (and (and (and (and (and (= evnt_charge.srvctypecode, sp_connection.srvctypecode), (= event_type, p_event_type)), (= event_code, p_event_code)), (= sp_connection.sp_cn_ref, p_sp_cn_ref)), (between p_created_tm, evnt_chg_wefr, evnt_chg_weto)), (not-null p_sp_cn_ref))
union 
  select event_chg_ref, chg_code
    from evnt_charge
    where (and (and (and (and (= event_type, p_event_type), (= event_code, p_event_code)), (= srvctypecode, "ALL")), (between p_created_tm, evnt_chg_wefr, evnt_chg_weto)), (null p_sp_cn_ref))
)
select cursor iteration.
end cursor
expression:(not-null l_event_chg_ref)
evaluates to f 
expression:(= p_event_triggers, "Y")
evaluates to t 

execute function informix.sp_trigger_event[procid=6257] ( p_event_ref = 7159601 ,  p_proc_na_events = Y ,  p_due_tm = NULL. ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_proc_na_events = N
default value  p_due_tm = NULL.
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
let l_insert_cnt = 0 
let l_event_type = NULL. 
expression:
  (select event_type, event_code
    from event
    where (= event_ref, p_event_ref))
evaluates to IC ; CM ; 
let l_event_type = CM 
let l_event_code = IC 
expression:(null l_event_type)
evaluates to f 
let l_sp_cn_ref = NULL. 
expression:
  (select (min sp_cn_ref), (count *)
    from evnt_sp_cn
    where (= event_ref, p_event_ref))
evaluates to 1 ; 239091 ; 
let l_sp_cn_ref = 239091 
let l_count = 1 
expression:(> l_count, 1)
evaluates to f 
let l_contact_code = NULL. 
expression:(= l_count, 0)
evaluates to f 
expression:(not-null l_sp_cn_ref)
evaluates to t 
expression:
  (select srvctypecode, subscriber_code
    from sp_connection
    where (= sp_cn_ref, l_sp_cn_ref))
evaluates to UAT0341352 ; PID  ; 
let l_srvctypecode = PID  
let l_contact_code = UAT0341352 
expression:(= p_proc_na_events, "Y")
evaluates to t 
let l_sched_stat_code = NA 
let l_due_tm = 2025-03-26 15:26:32.000 
expression:(not-null p_due_tm)
evaluates to f 
expression:(and (and (not-null l_sp_cn_ref), (= l_event_type, "CM")), (= l_event_code, "DR"))
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
start select cursor.
select trigger_type, trigger_code
  from evnt_trigger
  where (and (and (and (= event_type, l_event_type), (= event_code, l_event_code)), (= trigger_on_stat, l_sched_stat_code)), (or (= srvctypecode, "ALL"), (= srvctypecode, l_srvctypecode)))
select cursor iteration.
end cursor
expression:(= tran_flg, "Y")
evaluates to f 
expression:(= l_insert_cnt, 0)
evaluates to t 
procedure sp_trigger_event returns 100 , No events triggered 

expression:(<procedure> sp_trigger_event, p_event_ref as p_event_ref, "Y" as p_proc_na_events, p_trigger_due_tm as p_due_tm, "N" as tran_flg)
evaluates to No events triggered ; 100 ; 
let l_return = 100 
let l_msg = No events triggered 
expression:(and (= l_schedule, "Y"), (= p_event_triggers, "Y"))
evaluates to t 

execute function informix.sp_trigger_event[procid=6257] ( p_event_ref = 7159601 ,  p_proc_na_events = N ,  p_due_tm = NULL. ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_proc_na_events = N
default value  p_due_tm = NULL.
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
let l_insert_cnt = 0 
let l_event_type = NULL. 
expression:
  (select event_type, event_code
    from event
    where (= event_ref, p_event_ref))
evaluates to IC ; CM ; 
let l_event_type = CM 
let l_event_code = IC 
expression:(null l_event_type)
evaluates to f 
let l_sp_cn_ref = NULL. 
expression:
  (select (min sp_cn_ref), (count *)
    from evnt_sp_cn
    where (= event_ref, p_event_ref))
evaluates to 1 ; 239091 ; 
let l_sp_cn_ref = 239091 
let l_count = 1 
expression:(> l_count, 1)
evaluates to f 
let l_contact_code = NULL. 
expression:(= l_count, 0)
evaluates to f 
expression:(not-null l_sp_cn_ref)
evaluates to t 
expression:
  (select srvctypecode, subscriber_code
    from sp_connection
    where (= sp_cn_ref, l_sp_cn_ref))
evaluates to UAT0341352 ; PID  ; 
let l_srvctypecode = PID  
let l_contact_code = UAT0341352 
expression:(= p_proc_na_events, "Y")
evaluates to f 
let l_sched_stat_code = NULL. 
expression:
  (select sched_stat_code, due_tm
    from schedule
    where (= event_ref, p_event_ref))
evaluates to NULL. ; NULL. ; 
let l_sched_stat_code = NULL. 
let l_due_tm = NULL. 
expression:(null l_sched_stat_code)
evaluates to t 
procedure sp_trigger_event returns 100 , Event is not scheduled 

expression:(<procedure> sp_trigger_event, p_event_ref as p_event_ref, p_trigger_due_tm as p_due_tm, "N" as tran_flg)
evaluates to Event is not scheduled ; 100 ; 
let l_return = 100 
let l_msg = Event is not scheduled 
expression:(= l_schedule, "Y")
evaluates to t 

execute function informix.sp_sched_evnt[procid=7423] ( p_event_ref = 7159601 ,  p_to_login = system ,  p_to_dept = SYS ,  p_sched_code = ACT ,  p_due_tm = 2025-03-26 02:03:41 ,  p_created_by = webuser ,  p_created_tm = 2025-03-26 15:26:32 ,  p_sched_stat_code = O  ,  p_stat_tm = 2025-03-26 15:26:32 ,  p_stat_effect_by = webuser ,  p_note_text = NULL. ,  p_event_triggers = Y ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_due_tm = 2025-03-26 15:26:32.000
default value  p_created_by = webuser
default value  p_created_tm = 2025-03-26 15:26:32.000
default value  p_stat_tm = 2025-03-26 15:26:32.000
default value  p_stat_effect_by = webuser
default value  p_note_text = NULL.
default value  p_event_triggers = Y
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
expression:
  (select event_ref
    from schedule
    where (= event_ref, p_event_ref))
evaluates to NULL. ; 
let l_old_event_ref = NULL. 
expression:(= (dbinfo-sqlca.sqlerrd2 ), 1)
evaluates to f 

execute function informix.sischedule[procid=1796] ( p_event_ref = 7159601 ,  p_to_login = system ,  p_to_dept = SYS ,  p_sched_code = ACT ,  p_due_tm = 2025-03-26 02:03:41 ,  p_created_by = webuser ,  p_created_tm = 2025-03-26 15:26:32 ,  p_sched_stat_code = O  ,  p_stat_tm = 2025-03-26 15:26:32 ,  p_stat_effect_by = webuser ,  tran_flg = N )
default value  p_due_tm = NULL.
default value  p_created_tm = 2025-03-26 15:26:32
default value  p_sched_stat_code = NULL.
default value  p_stat_tm = NULL.
default value  p_stat_effect_by = NULL.
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 

insert into schedule(event_ref, to_login, to_dept, sched_code, due_tm, created_by, created_tm, sched_stat_code, stat_tm, stat_effect_by)
  values (p_event_ref, p_to_login, p_to_dept, p_sched_code, p_due_tm, p_created_by, p_created_tm, p_sched_stat_code, p_stat_tm, p_stat_effect_by);

before actions:

end before actions

for each row actions: 

execute procedure informix.sp_new_scheddimen[procid=8514] ( p_event_ref = 7159601 ,  p_sched_stat_code = O  ,  p_due_tm = 2025-03-26 02:03:41 ,  resume_flg = N ,  tran_flg = N )
default value  p_due_tm = NULL.
default value  resume_flg = N
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 
expression:
  (select evnt_sp_cn.sp_cn_ref, sp_connected, sp_disconnected, phone_num, nt_connected, nt_cn_ref, sched_stat_code.sched_stat_narr, event_type, event_code, srvctypecode
    from sched_stat_code, event, outer(evnt_sp_cn, sp_connection)
    where (and (and (and (= event.event_ref, evnt_sp_cn.event_ref), (= sp_connection.sp_cn_ref, evnt_sp_cn.sp_cn_ref)), (= sched_stat_code.sched_stat_code, p_sched_stat_code)), (= event.event_ref, p_event_ref)))
evaluates to PID  ; IC ; CM ; Open                             ; 168093 ; NULL. ; PD161470                                                         ; 2025-03-26 02:03:41 ; 2025-03-26 02:03:41 ; 239091 ; 
let l_sp_cn_ref = 239091 
let l_sp_connected = 2025-03-26 02:03:41 
let l_sp_disconnected = 2025-03-26 02:03:41 
let l_phone_num = PD161470                                                         
let l_nt_connected = NULL. 
let l_nt_cn_ref = 168093 
let l_sched_stat_narr = Open                             
let l_event_type = CM 
let l_event_code = IC 
let l_srvctypecode = PID  

insert into sched_dimension(event_ref, sp_cn_ref, due_tm, sched_stat_code, nt_connected, phone_num, nt_cn_ref, sched_stat_narr, sp_connected, sp_disconnected, event_type, event_code, srvctypecode)
  values (p_event_ref, l_sp_cn_ref, p_due_tm, p_sched_stat_code, l_nt_connected, l_phone_num, l_nt_cn_ref, l_sched_stat_narr, l_sp_connected, l_sp_disconnected, l_event_type, l_event_code, l_srvctypecode);

before actions:

end before actions

for each row actions: 

end for each row actions

after actions:

end after actions
expression:(or (= tran_flg, "C"), (= tran_flg, "Y"))
evaluates to f 
procedure sp_new_scheddimen returned no data


end for each row actions

after actions:

end after actions
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
let return_status = 0 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
expression:return_status
evaluates to 0 
procedure sischedule returns 0 

expression:(<procedure> sischedule, p_event_ref as p_event_ref, p_to_login as p_to_login, p_to_dept as p_to_dept, p_sched_code as p_sched_code, p_due_tm as p_due_tm, p_created_by as p_created_by, p_created_tm as p_created_tm, p_sched_stat_code as p_sched_stat_code, p_stat_tm as p_stat_tm, p_stat_effect_by as p_stat_effect_by, "N" as tran_flg)
evaluates to 0 
let l_return = 0 
expression:(not-null p_note_text)
evaluates to f 
expression:(= p_event_triggers, "Y")
evaluates to t 

execute function informix.sp_trigger_event[procid=6257] ( p_event_ref = 7159601 ,  p_proc_na_events = N ,  p_due_tm = NULL. ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_proc_na_events = N
default value  p_due_tm = NULL.
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
let l_insert_cnt = 0 
let l_event_type = NULL. 
expression:
  (select event_type, event_code
    from event
    where (= event_ref, p_event_ref))
evaluates to IC ; CM ; 
let l_event_type = CM 
let l_event_code = IC 
expression:(null l_event_type)
evaluates to f 
let l_sp_cn_ref = NULL. 
expression:
  (select (min sp_cn_ref), (count *)
    from evnt_sp_cn
    where (= event_ref, p_event_ref))
evaluates to 1 ; 239091 ; 
let l_sp_cn_ref = 239091 
let l_count = 1 
expression:(> l_count, 1)
evaluates to f 
let l_contact_code = NULL. 
expression:(= l_count, 0)
evaluates to f 
expression:(not-null l_sp_cn_ref)
evaluates to t 
expression:
  (select srvctypecode, subscriber_code
    from sp_connection
    where (= sp_cn_ref, l_sp_cn_ref))
evaluates to UAT0341352 ; PID  ; 
let l_srvctypecode = PID  
let l_contact_code = UAT0341352 
expression:(= p_proc_na_events, "Y")
evaluates to f 
let l_sched_stat_code = NULL. 
expression:
  (select sched_stat_code, due_tm
    from schedule
    where (= event_ref, p_event_ref))
evaluates to 2025-03-26 02:03:41 ; O  ; 
let l_sched_stat_code = O  
let l_due_tm = 2025-03-26 02:03:41 
expression:(null l_sched_stat_code)
evaluates to f 
expression:(<> l_sched_stat_code, "O")
evaluates to f 
expression:(not-null p_due_tm)
evaluates to f 
expression:(and (and (not-null l_sp_cn_ref), (= l_event_type, "CM")), (= l_event_code, "DR"))
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
start select cursor.
select trigger_type, trigger_code
  from evnt_trigger
  where (and (and (and (= event_type, l_event_type), (= event_code, l_event_code)), (= trigger_on_stat, l_sched_stat_code)), (or (= srvctypecode, "ALL"), (= srvctypecode, l_srvctypecode)))
select cursor iteration.
end cursor
expression:(= tran_flg, "Y")
evaluates to f 
expression:(= l_insert_cnt, 0)
evaluates to t 
procedure sp_trigger_event returns 100 , No events triggered 

expression:(<procedure> sp_trigger_event, p_event_ref as p_event_ref, "N" as tran_flg)
evaluates to No events triggered ; 100 ; 
let l_return = 100 
let l_msg = No events triggered 
expression:(= tran_flg, "Y")
evaluates to f 
procedure sp_sched_evnt returns 0 , NULL. 

expression:(<procedure> sp_sched_evnt, p_event_ref as p_event_ref, p_to_login as p_to_login, p_to_dept as p_to_dept, p_sched_code as p_sched_code, p_due_tm as p_due_tm, p_created_by as p_created_by, p_created_tm as p_created_tm, p_sched_stat_code as p_sched_stat_code, p_stat_tm as p_stat_tm, p_stat_effect_by as p_stat_effect_by, p_event_triggers as p_event_triggers, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_return = 0 
let l_msg = NULL. 
expression:(and (= p_event_type, "AA"), (= p_event_code, "BR"))
evaluates to f 
expression:(and (not-null l_acct_void_event), (> (<procedure> length, l_acct_void_event), 6))
evaluates to f 
expression:(not-null p_sp_cn_ref)
evaluates to t 

execute function informix.ss_sys_cnfg[procid=7787] ( p_cnfg_key = LINK_ATTRIBUTES_TO_EVENT_CM_IC ,  p_alt_cnfg_key = NULL. ,  p_default_val = N ,  p_force_upper = Y ,  p_max_length = 1 ,  p_check_is_numeric = N ,  p_check_is_dt = N ,  trace_flg = N ,  resume_flg = N )
default value  p_alt_cnfg_key = NULL.
default value  p_default_val = NULL.
default value  p_force_upper = N
default value  p_max_length = 0
default value  p_check_is_numeric = N
default value  p_check_is_dt = N
default value  trace_flg = N
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

set lock mode to wait 30;
expression:(<procedure> upper, p_cnfg_key)
evaluates to LINK_ATTRIBUTES_TO_EVENT_CM_IC   
let p_cnfg_key = LINK_ATTRIBUTES_TO_EVENT_CM_IC   
let l_cnfg_val = NULL. 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_cnfg_key))
evaluates to NULL. ; 
let l_cnfg_val = NULL. 
expression:(and (null l_cnfg_val), (not-null p_alt_cnfg_key))
evaluates to f 
expression:(nvl l_cnfg_val, p_default_val)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_force_upper, "Y")
evaluates to t 
expression:(<procedure> upper, l_cnfg_val)
evaluates to N 
let l_cnfg_val = N 
expression:(> p_max_length, 0)
evaluates to t 
expression:(substring l_cnfg_val, 1, p_max_length)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(= p_check_is_dt, "Y")
evaluates to f 
expression:l_cnfg_val
evaluates to N 
procedure ss_sys_cnfg returns 0 , N , NULL. 

expression:(<procedure> ss_sys_cnfg, (|| (|| (|| "LINK_ATTRIBUTES_TO_EVENT_", l_event_type), "_"), l_event_code) as p_cnfg_key, "N" as p_default_val, 1 as p_max_length, "Y" as p_force_upper)
evaluates to NULL. ; N ; 0 ; 
let l_return = 0 
let l_link_attributes = N 
let l_msg = NULL. 
expression:(= l_link_attributes, "Y")
evaluates to f 
expression:(and (= l_schedule, "Y"), (= p_create_sms, "Y"))
evaluates to t 

execute function informix.ss_sys_cnfg[procid=7787] ( p_cnfg_key = SMS_EVENT_CM_IC ,  p_alt_cnfg_key = NULL. ,  p_default_val = N ,  p_force_upper = Y ,  p_max_length = 1 ,  p_check_is_numeric = N ,  p_check_is_dt = N ,  trace_flg = N ,  resume_flg = N )
default value  p_alt_cnfg_key = NULL.
default value  p_default_val = NULL.
default value  p_force_upper = N
default value  p_max_length = 0
default value  p_check_is_numeric = N
default value  p_check_is_dt = N
default value  trace_flg = N
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

set lock mode to wait 30;
expression:(<procedure> upper, p_cnfg_key)
evaluates to SMS_EVENT_CM_IC                  
let p_cnfg_key = SMS_EVENT_CM_IC                  
let l_cnfg_val = NULL. 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_cnfg_key))
evaluates to NULL. ; 
let l_cnfg_val = NULL. 
expression:(and (null l_cnfg_val), (not-null p_alt_cnfg_key))
evaluates to f 
expression:(nvl l_cnfg_val, p_default_val)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_force_upper, "Y")
evaluates to t 
expression:(<procedure> upper, l_cnfg_val)
evaluates to N 
let l_cnfg_val = N 
expression:(> p_max_length, 0)
evaluates to t 
expression:(substring l_cnfg_val, 1, p_max_length)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(= p_check_is_dt, "Y")
evaluates to f 
expression:l_cnfg_val
evaluates to N 
procedure ss_sys_cnfg returns 0 , N , NULL. 

expression:(<procedure> ss_sys_cnfg, (|| (|| (|| "SMS_EVENT_", p_event_type), "_"), p_event_code) as p_cnfg_key, "N" as p_default_val, 1 as p_max_length, "Y" as p_force_upper)
evaluates to NULL. ; N ; 0 ; 
let l_return = 0 
let l_is_sms_event = N 
let l_msg = NULL. 
expression:(= l_is_sms_event, "Y")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
expression:p_event_ref
evaluates to 7159601 
procedure sp_new_event returns 0 , 7159601 

expression:(<procedure> sp_new_event, 0 as p_event_ref, l_event_type as p_event_type, l_event_code as p_event_code, "Y" as p_translate, p_sp_cn_ref as p_sp_cn_ref, p_user as p_created_by, current year to fraction(3) as p_created_tm, p_note as p_note_text, "system" as p_to_login, "SYS" as p_to_dept, "ACT" as p_sched_code, p_scheduled_dt as p_due_tm, "O" as p_sched_stat_code, p_user as p_stat_effect_by, current year to fraction(3) as p_stat_tm, p_event_triggers as p_event_triggers, "N" as tran_flg)
evaluates to 7159601 ; 0 ; 
let l_result = 0 
let l_event_ref = 7159601 

execute function informix.ss_flex_code[procid=1382] ( p_sys_table = evnt_code ,  p_sys_hard_group = CM ,  p_sys_hard_code = PN ,  p_multiple_rows = N ,  p_msg = Port Notification event not in sys_code. ,  resume_flg = Z )
default value  p_multiple_rows = N
default value  p_msg = NULL.
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(not-in resume_flg, "Y", "N", "Z")
evaluates to f 
let l_found = N 
let l_tmp_key1 = NULL. 
expression:(not-null p_msg)
evaluates to t 
expression:p_msg
evaluates to Port Notification event not in sys_code. 
let l_msg = Port Notification event not in sys_code. 
start select cursor.
select flex_key1, flex_key2
  from sys_code
  where (and (and (= sys_table, p_sys_table), (or (= sys_hard_group, p_sys_hard_group), (null p_sys_hard_group))), (or (= sys_hard_code, p_sys_hard_code), (null p_sys_hard_code)))
  order by flex_key2
select cursor iteration.
select cursor returns CM , PN 
expression:(= l_found, "N")
evaluates to t 
expression:l_flex_key1
evaluates to CM 
let l_tmp_key1 = CM 
expression:l_flex_key2
evaluates to PN 
let l_tmp_key2 = PN 
let l_found = Y 
select cursor iteration.
end cursor
expression:(not-null l_tmp_key1)
evaluates to t 
expression:l_tmp_key2
evaluates to PN 
expression:l_tmp_key1
evaluates to CM 
procedure ss_flex_code returns 0 , CM , PN 

expression:(<procedure> ss_flex_code, "evnt_code" as p_sys_table, "CM" as p_sys_hard_group, "PN" as p_sys_hard_code, "Port Notification event not in sys_code." as p_msg, "Z" as resume_flg)
evaluates to PN                               ; CM                               ; 0 ; 
let l_result = 0 
let l_event_type = CM                               
let l_event_code = PN                               

update schedule set
    (sched_stat_code) = ("C"),
    (stat_tm) = (current year to fraction(3)),
    (stat_effect_by) = (p_user)
  where (and (= sched_stat_code, "O"), (in event_ref, 
    (select event.event_ref
      from event, evnt_sp_cn
      where (and (and (and (= event.event_ref, evnt_sp_cn.event_ref), (= sp_cn_ref, p_sp_cn_ref)), (= event_type, l_event_type)), (= event_code, l_event_code)))));

before actions:

end before actions

after actions:

end after actions
expression:(or (= p_set_connect, "Y"), (and (null l_nt_connected), (<= p_scheduled_dt, current year to fraction(3))))
evaluates to t 

execute function informix.sp_set_connect[procid=8509] ( p_event_ref = 7159601 ,  p_sp_plan_ref = NULL. ,  p_actual_change_dt = 2025-03-26 02:03:41 ,  p_plan_code = NULL. ,  p_sp_code = NULL. ,  p_event_triggers = Y ,  p_source = NULL. ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_sp_plan_ref = NULL.
default value  p_plan_code = NULL.
default value  p_sp_code = NULL.
default value  p_event_triggers = Y
default value  p_source = NULL.
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
expression:
  (select sp_cn_ref
    from evnt_sp_cn
    where (= event_ref, p_event_ref))
evaluates to 239091 ; 
let l_sp_cn_ref = 239091 
expression:(<> (dbinfo-sqlca.sqlerrd2 ), 1)
evaluates to f 
expression:(null p_sp_plan_ref)
evaluates to t 
let l_sp_plan_ref = NULL. 
start select cursor.
select sp_plan_ref, sp_plan_start, sp_plan_stop
  from sp_cn_plan
  where (= sp_cn_ref, l_sp_cn_ref)
  order by sp_plan_stopdesc
select cursor iteration.
select cursor returns 385186 , 2025-03-26 02:03:41 , 2025-03-26 02:03:41 
end cursor
expression:(null l_sp_plan_ref)
evaluates to f 

update sp_cn_plan set
    (sp_plan_start) = ((- p_actual_change_dt, (units 1, 2474)))
  where (and (and (= sp_cn_ref, l_sp_cn_ref), (<> sp_plan_ref, l_sp_plan_ref)), (>= sp_plan_start, p_actual_change_dt));

before actions:

end before actions

after actions:

end after actions

update subsdisc set
    (subsdiscwefr) = (p_actual_change_dt)
  where (and (= sp_plan_ref, l_sp_plan_ref), (= subsdiscwefr, l_sp_plan_start));

before actions:

end before actions

after actions:

end after actions

update subsdisc set
    (subsdiscweto) = (p_actual_change_dt)
  where (and (= sp_plan_ref, l_sp_plan_ref), (= subsdiscweto, l_sp_plan_start));

before actions:

end before actions

after actions:

end after actions

update subsdiscuserinfo set
    (subsdiscinfowefr) = (p_actual_change_dt)
  where (and (in subsdiscid, 
    (select subsdiscid
      from subsdisc
      where (and (= sp_plan_ref, l_sp_plan_ref), (= subsdiscwefr, p_actual_change_dt)))), (= subsdiscinfowefr, l_sp_plan_start));

before actions:

end before actions

after actions:

end after actions

update subsdiscuserinfo set
    (subsdiscinfoweto) = (p_actual_change_dt)
  where (and (in subsdiscid, 
    (select subsdiscid
      from subsdisc
      where (and (= sp_plan_ref, l_sp_plan_ref), (= subsdiscweto, p_actual_change_dt)))), (= subsdiscinfoweto, l_sp_plan_start));

before actions:

end before actions

after actions:

end after actions

update subsdiscbenfinfo set
    (subsdiscbenfwefr) = (p_actual_change_dt)
  where (and (in subsdiscid, 
    (select subsdiscid
      from subsdisc
      where (and (= sp_plan_ref, l_sp_plan_ref), (= subsdiscwefr, p_actual_change_dt)))), (= subsdiscbenfwefr, l_sp_plan_start));

before actions:

end before actions

after actions:

end after actions

update subsdiscbenfinfo set
    (subsdiscbenfweto) = (p_actual_change_dt)
  where (and (in subsdiscid, 
    (select subsdiscid
      from subsdisc
      where (and (= sp_plan_ref, l_sp_plan_ref), (= subsdiscweto, p_actual_change_dt)))), (= subsdiscbenfweto, l_sp_plan_start));

before actions:

end before actions

after actions:

end after actions

execute function informix.sp_close_evnt[procid=7475] ( p_sched_ref = 7159601 ,  p_actual_change_dt = 2025-03-26 15:26:32.000 ,  p_sched_stat_code = C ,  p_report_procd_err = Y ,  p_event_triggers = Y ,  resume_flg = N ,  tran_flg = N ,  trace_flg = N )
default value  p_sched_stat_code = C
default value  p_report_procd_err = Y
default value  p_event_triggers = Y
default value  resume_flg = N
default value  tran_flg = Y
default value  trace_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
expression:
  (select sched_stat_code
    from schedule
    where (= event_ref, p_sched_ref))
evaluates to O  ; 
let l_sched_stat_code = O  
expression:(not-in l_sched_stat_code, "O", "R")
evaluates to f 

execute function informix.sp_chg_sched_stat[procid=7701] ( p_event_ref = 7159601 ,  p_sched_stat_code = C  ,  p_due_tm = NULL. ,  p_note_text = Event Close. ,  p_spcnhist_to_dt = NULL. ,  p_event_triggers = Y ,  p_allow_retry = Y ,  p_update_correspnd = Y ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_due_tm = NULL.
default value  p_note_text = NULL.
default value  p_spcnhist_to_dt = NULL.
default value  p_event_triggers = Y
default value  p_allow_retry = Y
default value  p_update_correspnd = Y
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
let l_event_ref = NULL. 
let l_sp_cn_ref = NULL. 
expression:
  (select event.event_ref, sched_stat_code, due_tm, event.event_type, event.event_code, sp_cn_ref, set_ref
    from event, evnt_code, outer(schedule), outer(evnt_sp_cn)
    where (and (and (and (and (= event.event_ref, schedule.event_ref), (= event.event_code, evnt_code.event_code)), (= event.event_type, evnt_code.event_type)), (= event.event_ref, evnt_sp_cn.event_ref)), (= event.event_ref, p_event_ref)))
evaluates to NULL. ; 239091 ; IC ; CM ; 2025-03-26 02:03:41 ; O  ; 7159601 ; 
let l_event_ref = 7159601 
let l_sched_stat_code = O  
let l_due_tm = 2025-03-26 02:03:41 
let l_event_type = CM 
let l_event_code = IC 
let l_sp_cn_ref = 239091 
let l_set_ref = NULL. 
expression:(null l_event_ref)
evaluates to f 
expression:(and (= p_sched_stat_code, "F"), (= p_allow_retry, "Y"))
evaluates to f 

execute function informix.equal[procid=-114] (   = Event Close. ,    = EVENT SCHEDULE STATUS CHANGED: )
expression:(= p_note_text, "EVENT SCHEDULE STATUS CHANGED:")
evaluates to f 
expression:
  (select (count *)
    from set_dtl_instance
    where (= event_ref, p_event_ref))
evaluates to 0 ; 
let l_count = 0 
expression:(and (> l_count, 0), (in l_sched_stat_code, "F", "V"))
evaluates to f 
expression:(not-null l_sched_stat_code)
evaluates to t 
expression:(null p_due_tm)
evaluates to t 
expression:l_due_tm
evaluates to 2025-03-26 02:03:41 
let p_due_tm = 2025-03-26 02:03:41 
expression:(not-null l_set_ref)
evaluates to f 

update schedule set
    (sched_stat_code) = (p_sched_stat_code),
    (due_tm) = (p_due_tm)
  where (= event_ref, p_event_ref);

before actions:

end before actions

for each row actions: 

execute procedure informix.sp_del_scheddimen[procid=8516] ( p_event_ref = 7159601 ,  tran_flg = N )
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 

delete from sched_dimension
  where (= event_ref, p_event_ref);

before actions:

end before actions

for each row actions: 

end for each row actions

after actions:

end after actions
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
let return_status = 0 
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
let return_status = 0 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
procedure sp_del_scheddimen returned no data


end for each row actions

after actions:

end after actions
expression:(<> (dbinfo-sqlca.sqlerrd2 ), 1)
evaluates to f 
expression:(not-null l_sp_cn_ref)
evaluates to t 
let l_sp_cn_status = NULL. 
expression:
  (select evnt_code_sv_st.sp_cn_status
    from sp_connection, evnt_code_sv_st
    where (and (and (and (and (= sp_connection.srvctypecode, evnt_code_sv_st.srvctypecode), (= event_type, l_event_type)), (= event_code, l_event_code)), (= sched_stat_code, p_sched_stat_code)), (= sp_cn_ref, l_sp_cn_ref)))
evaluates to NULL. ; 
let l_sp_cn_status = NULL. 
expression:(null l_sp_cn_status)
evaluates to t 
expression:
  (select sp_cn_status
    from evnt_code_sv_st
    where (and (and (and (= event_type, l_event_type), (= event_code, l_event_code)), (= sched_stat_code, p_sched_stat_code)), (= srvctypecode, "ALL")))
evaluates to NULL. ; 
let l_sp_cn_status = NULL. 
expression:(not-null l_sp_cn_status)
evaluates to f 
expression:(and (and (not-null l_sp_cn_ref), (<> (nvl p_sched_stat_code, "x"), (nvl l_sched_stat_code, "x"))), (= p_event_triggers, "Y"))
evaluates to t 

execute function informix.sp_trigger_event[procid=6257] ( p_event_ref = 7159601 ,  p_proc_na_events = N ,  p_due_tm = NULL. ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_proc_na_events = N
default value  p_due_tm = NULL.
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
let l_insert_cnt = 0 
let l_event_type = NULL. 
expression:
  (select event_type, event_code
    from event
    where (= event_ref, p_event_ref))
evaluates to IC ; CM ; 
let l_event_type = CM 
let l_event_code = IC 
expression:(null l_event_type)
evaluates to f 
let l_sp_cn_ref = NULL. 
expression:
  (select (min sp_cn_ref), (count *)
    from evnt_sp_cn
    where (= event_ref, p_event_ref))
evaluates to 1 ; 239091 ; 
let l_sp_cn_ref = 239091 
let l_count = 1 
expression:(> l_count, 1)
evaluates to f 
let l_contact_code = NULL. 
expression:(= l_count, 0)
evaluates to f 
expression:(not-null l_sp_cn_ref)
evaluates to t 
expression:
  (select srvctypecode, subscriber_code
    from sp_connection
    where (= sp_cn_ref, l_sp_cn_ref))
evaluates to UAT0341352 ; PID  ; 
let l_srvctypecode = PID  
let l_contact_code = UAT0341352 
expression:(= p_proc_na_events, "Y")
evaluates to f 
let l_sched_stat_code = NULL. 
expression:
  (select sched_stat_code, due_tm
    from schedule
    where (= event_ref, p_event_ref))
evaluates to 2025-03-26 02:03:41 ; C  ; 
let l_sched_stat_code = C  
let l_due_tm = 2025-03-26 02:03:41 
expression:(null l_sched_stat_code)
evaluates to f 
expression:(<> l_sched_stat_code, "O")
evaluates to t 
let l_due_tm = 2025-03-26 15:26:32.000 
expression:(not-null p_due_tm)
evaluates to f 
expression:(and (and (not-null l_sp_cn_ref), (= l_event_type, "CM")), (= l_event_code, "DR"))
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
start select cursor.
select trigger_type, trigger_code
  from evnt_trigger
  where (and (and (and (= event_type, l_event_type), (= event_code, l_event_code)), (= trigger_on_stat, l_sched_stat_code)), (or (= srvctypecode, "ALL"), (= srvctypecode, l_srvctypecode)))
select cursor iteration.
select cursor returns RP , AC 
expression:(null l_sp_cn_ref)
evaluates to f 
let l_create_against_acct = N 
expression:(= l_create_against_acct, "Y")
evaluates to f 
expression:(= l_create_against_acct, "Y")
evaluates to f 
let l_targ_subscriber_code = NULL. 
expression:l_sp_cn_ref
evaluates to 239091 
let l_targ_sp_cn_ref = 239091 
expression:(+ l_insert_cnt, 1)
evaluates to 1 
let l_insert_cnt = 1 

execute function informix.sp_new_event[procid=9653] ( p_event_ref = 0 ,  p_event_type = RP ,  p_event_code = AC ,  p_created_by = webuser ,  p_parent_event = 7159601 ,  p_evntrelntypecode = T ,  p_evnt_oth_ref = NULL. ,  p_sp_cn_ref = 239091 ,  p_contact_code = NULL. ,  p_created_tm = 2025-03-26 15:26:32.000 ,  p_note_text = NULL. ,  p_note_text2 = NULL. ,  p_evnt_reas_code = NULL. ,  p_to_login = system ,  p_to_dept = SYS ,  p_sched_code = ACT ,  p_due_tm = 2025-03-26 15:26:32 ,  p_trigger_due_tm = NULL. ,  p_sched_stat_code = O ,  p_stat_tm = 2025-03-26 15:26:32.000 ,  p_stat_effect_by = NULL. ,  p_bill_ref = NULL. ,  p_bill_event_type = NULL. ,  p_bill_step_ref = NULL. ,  p_attach_loc = NULL. ,  p_priority_id = NULL. ,  p_alert = N ,  p_translate = N ,  p_mode = U ,  p_creditchkevnt_crt = Y ,  p_spcnhist_to_dt = NULL. ,  p_event_triggers = Y ,  p_fin_ref = NULL. ,  p_create_sms = Y ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_event_ref = 0
default value  p_created_by = webuser
default value  p_parent_event = NULL.
default value  p_evntrelntypecode = F
default value  p_evnt_oth_ref = NULL.
default value  p_sp_cn_ref = NULL.
default value  p_contact_code = NULL.
default value  p_created_tm = 2025-03-26 15:26:32.000
default value  p_note_text = NULL.
default value  p_note_text2 = NULL.
default value  p_evnt_reas_code = NULL.
default value  p_to_login = NULL.
default value  p_to_dept = NULL.
default value  p_sched_code = NULL.
default value  p_due_tm = 2025-03-26 15:26:32.000
default value  p_trigger_due_tm = NULL.
default value  p_sched_stat_code = NULL.
default value  p_stat_tm = 2025-03-26 15:26:32.000
default value  p_stat_effect_by = webuser
default value  p_bill_ref = NULL.
default value  p_bill_event_type = NULL.
default value  p_bill_step_ref = NULL.
default value  p_attach_loc = NULL.
default value  p_priority_id = NULL.
default value  p_alert = N
default value  p_translate = N
default value  p_mode = U
default value  p_creditchkevnt_crt = Y
default value  p_spcnhist_to_dt = NULL.
default value  p_event_triggers = Y
default value  p_fin_ref = NULL.
default value  p_create_sms = Y
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 

set lock mode to wait 5;
expression:(or (null p_event_type), (null p_event_code))
evaluates to f 
expression:(and (not-null p_bill_ref), (null p_bill_event_type))
evaluates to f 
let l_acct_void_event = NULL. 
let l_contact_code = NULL. 
let l_sys_status = NULL. 
let l_cm_ic_cnt = NULL. 
let l_cm_pi_cnt = NULL. 
let l_sm_sc_cnt = NULL. 
let l_sm_sp_cnt = NULL. 
let l_event_ref = NULL. 

execute function informix.ss_sys_cnfg[procid=7787] ( p_cnfg_key = ACCT_TO_VOID_EVENT ,  p_alt_cnfg_key = NULL. ,  p_default_val = N ,  p_force_upper = N ,  p_max_length = 10 ,  p_check_is_numeric = N ,  p_check_is_dt = N ,  trace_flg = N ,  resume_flg = N )
default value  p_alt_cnfg_key = NULL.
default value  p_default_val = NULL.
default value  p_force_upper = N
default value  p_max_length = 0
default value  p_check_is_numeric = N
default value  p_check_is_dt = N
default value  trace_flg = N
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

set lock mode to wait 30;
expression:(<procedure> upper, p_cnfg_key)
evaluates to ACCT_TO_VOID_EVENT               
let p_cnfg_key = ACCT_TO_VOID_EVENT               
let l_cnfg_val = NULL. 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_cnfg_key))
evaluates to NULL. ; 
let l_cnfg_val = NULL. 
expression:(and (null l_cnfg_val), (not-null p_alt_cnfg_key))
evaluates to f 
expression:(nvl l_cnfg_val, p_default_val)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_force_upper, "Y")
evaluates to f 
expression:(> p_max_length, 0)
evaluates to t 
expression:(substring l_cnfg_val, 1, p_max_length)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(= p_check_is_dt, "Y")
evaluates to f 
expression:l_cnfg_val
evaluates to N 
procedure ss_sys_cnfg returns 0 , N , NULL. 

expression:(<procedure> ss_sys_cnfg, "ACCT_TO_VOID_EVENT" as p_cnfg_key, "N" as p_default_val, 10 as p_max_length, "N" as p_force_upper)
evaluates to NULL. ; N ; 0 ; 
let l_return = 0 
let l_acct_void_event = N 
let l_msg = NULL. 
expression:(= p_translate, "Y")
evaluates to f 
expression:p_event_type
evaluates to RP 
let l_event_type = RP 
expression:p_event_code
evaluates to AC 
let l_event_code = AC 
let l_count = 0 
expression:
  (select (count *)
    from evnt_code
    where (and (= event_type, l_event_type), (= event_code, l_event_code)))
evaluates to 1 ; 
let l_count = 1 
expression:(<> l_count, 1)
evaluates to f 
expression:(and (and (not-null p_to_login), (not-null p_to_dept)), (not-null p_sched_code))
evaluates to t 
let l_schedule = Y 

execute function informix.sievent[procid=7558] ( p_event_ref = 0 ,  p_event_type = RP ,  p_event_code = AC ,  p_created_by = webuser ,  p_created_tm = 2025-03-26 15:26:32 ,  tran_flg = N )
default value  p_event_ref = 0
default value  p_created_by = webuser
default value  p_created_tm = 2025-03-26 15:26:32
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 

insert into event(event_ref, event_type, event_code, created_by, created_tm)
  values (p_event_ref, p_event_type, p_event_code, p_created_by, p_created_tm);

before actions:

end before actions

for each row actions: 

end for each row actions

after actions:

end after actions
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
let return_status = 0 
expression:(dbinfo-sqlca.sqlerrd1 )
evaluates to 7159602 
let ser_num = 7159602 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
expression:ser_num
evaluates to 7159602 
expression:return_status
evaluates to 0 
procedure sievent returns 0 , 7159602 

expression:(<procedure> sievent, p_event_ref as p_event_ref, l_event_type as p_event_type, l_event_code as p_event_code, p_created_by as p_created_by, p_created_tm as p_created_tm, "N" as tran_flg)
evaluates to 7159602 ; 0 ; 
let l_return = 0 
let p_event_ref = 7159602 
expression:(not-null p_contact_code)
evaluates to f 
expression:(not-null p_sp_cn_ref)
evaluates to t 

execute function informix.sievnt_sp_cn[procid=893] ( p_event_ref = 7159602 ,  p_sp_cn_ref = 239091 ,  tran_flg = N )
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 

insert into evnt_sp_cn(event_ref, sp_cn_ref)
  values (p_event_ref, p_sp_cn_ref);

before actions:

end before actions

for each row actions: 

end for each row actions

after actions:

end after actions
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
let return_status = 0 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
expression:return_status
evaluates to 0 
procedure sievnt_sp_cn returns 0 

expression:(<procedure> sievnt_sp_cn, p_event_ref as p_event_ref, p_sp_cn_ref as p_sp_cn_ref, "N" as tran_flg)
evaluates to 0 
let l_return = 0 
expression:(= l_schedule, "N")
evaluates to f 
expression:p_sched_stat_code
evaluates to O  
let l_sched_stat_code = O  
let l_sp_cn_status = NULL. 
expression:
  (select evnt_code_sv_st.sp_cn_status
    from sp_connection, evnt_code_sv_st
    where (and (and (and (and (= sp_connection.srvctypecode, evnt_code_sv_st.srvctypecode), (= event_type, l_event_type)), (= event_code, l_event_code)), (= sched_stat_code, l_sched_stat_code)), (= sp_cn_ref, p_sp_cn_ref)))
evaluates to NULL. ; 
let l_sp_cn_status = NULL. 
expression:(null l_sp_cn_status)
evaluates to t 
expression:
  (select sp_cn_status
    from evnt_code_sv_st
    where (and (and (and (= event_type, l_event_type), (= event_code, l_event_code)), (= sched_stat_code, l_sched_stat_code)), (= srvctypecode, "ALL")))
evaluates to NULL. ; 
let l_sp_cn_status = NULL. 
expression:(not-null l_sp_cn_status)
evaluates to f 

execute function informix.sp_add_event_note[procid=1708] ( p_event_ref = 7159602 ,  p_note_text = NULL. ,  resume_flg = N ,  tran_flg = N )
default value  resume_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 
expression:(not-null p_note_text)
evaluates to f 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
procedure sp_add_event_note returns 0 , NULL. 

expression:(<procedure> sp_add_event_note, p_event_ref as p_event_ref, p_note_text as p_note_text, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_return = 0 
let l_msg = NULL. 

execute function informix.sp_add_event_note[procid=1708] ( p_event_ref = 7159602 ,  p_note_text = NULL. ,  resume_flg = N ,  tran_flg = N )
default value  resume_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 
expression:(not-null p_note_text)
evaluates to f 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
procedure sp_add_event_note returns 0 , NULL. 

expression:(<procedure> sp_add_event_note, p_event_ref as p_event_ref, p_note_text2 as p_note_text, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_return = 0 
let l_msg = NULL. 
expression:(not-null p_evnt_reas_code)
evaluates to f 
expression:(not-null p_priority_id)
evaluates to f 
expression:(not-null p_parent_event)
evaluates to t 

execute function informix.sievent_rel[procid=1657] ( p_parent_event = 7159601 ,  p_child_event = 7159602 ,  p_evntrelntypecode = T ,  tran_flg = N )
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 

insert into event_rel(parent_event, child_event, evntrelntypecode)
  values (p_parent_event, p_child_event, p_evntrelntypecode);

before actions:

end before actions

for each row actions: 

end for each row actions

after actions:

end after actions
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
let return_status = 0 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
expression:return_status
evaluates to 0 
procedure sievent_rel returns 0 

expression:(<procedure> sievent_rel, p_parent_event as p_parent_event, p_event_ref as p_child_event, p_evntrelntypecode as p_evntrelntypecode, "N" as tran_flg)
evaluates to 0 
let l_return = 0 
expression:(not-null p_evnt_oth_ref)
evaluates to f 
expression:(not-null p_bill_ref)
evaluates to f 
expression:(not-null p_bill_step_ref)
evaluates to f 
expression:(not-null p_attach_loc)
evaluates to f 
expression:(= p_alert, "Y")
evaluates to f 
expression:(not-null p_fin_ref)
evaluates to f 
let l_event_chg_ref = NULL. 
start select cursor.
(
  select event_chg_ref, chg_code
    from evnt_charge, sp_connection
    where (and (and (and (and (and (= evnt_charge.srvctypecode, sp_connection.srvctypecode), (= event_type, p_event_type)), (= event_code, p_event_code)), (= sp_connection.sp_cn_ref, p_sp_cn_ref)), (between p_created_tm, evnt_chg_wefr, evnt_chg_weto)), (not-null p_sp_cn_ref))
union 
  select event_chg_ref, chg_code
    from evnt_charge
    where (and (and (and (and (= event_type, p_event_type), (= event_code, p_event_code)), (= srvctypecode, "ALL")), (between p_created_tm, evnt_chg_wefr, evnt_chg_weto)), (null p_sp_cn_ref))
)
select cursor iteration.
end cursor
expression:(not-null l_event_chg_ref)
evaluates to f 
expression:(= p_event_triggers, "Y")
evaluates to t 

execute function informix.sp_trigger_event[procid=6257] ( p_event_ref = 7159602 ,  p_proc_na_events = Y ,  p_due_tm = NULL. ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_proc_na_events = N
default value  p_due_tm = NULL.
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
let l_insert_cnt = 0 
let l_event_type = NULL. 
expression:
  (select event_type, event_code
    from event
    where (= event_ref, p_event_ref))
evaluates to AC ; RP ; 
let l_event_type = RP 
let l_event_code = AC 
expression:(null l_event_type)
evaluates to f 
let l_sp_cn_ref = NULL. 
expression:
  (select (min sp_cn_ref), (count *)
    from evnt_sp_cn
    where (= event_ref, p_event_ref))
evaluates to 1 ; 239091 ; 
let l_sp_cn_ref = 239091 
let l_count = 1 
expression:(> l_count, 1)
evaluates to f 
let l_contact_code = NULL. 
expression:(= l_count, 0)
evaluates to f 
expression:(not-null l_sp_cn_ref)
evaluates to t 
expression:
  (select srvctypecode, subscriber_code
    from sp_connection
    where (= sp_cn_ref, l_sp_cn_ref))
evaluates to UAT0341352 ; PID  ; 
let l_srvctypecode = PID  
let l_contact_code = UAT0341352 
expression:(= p_proc_na_events, "Y")
evaluates to t 
let l_sched_stat_code = NA 
let l_due_tm = 2025-03-26 15:26:32.000 
expression:(not-null p_due_tm)
evaluates to f 
expression:(and (and (not-null l_sp_cn_ref), (= l_event_type, "CM")), (= l_event_code, "DR"))
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
start select cursor.
select trigger_type, trigger_code
  from evnt_trigger
  where (and (and (and (= event_type, l_event_type), (= event_code, l_event_code)), (= trigger_on_stat, l_sched_stat_code)), (or (= srvctypecode, "ALL"), (= srvctypecode, l_srvctypecode)))
select cursor iteration.
end cursor
expression:(= tran_flg, "Y")
evaluates to f 
expression:(= l_insert_cnt, 0)
evaluates to t 
procedure sp_trigger_event returns 100 , No events triggered 

expression:(<procedure> sp_trigger_event, p_event_ref as p_event_ref, "Y" as p_proc_na_events, p_trigger_due_tm as p_due_tm, "N" as tran_flg)
evaluates to No events triggered ; 100 ; 
let l_return = 100 
let l_msg = No events triggered 
expression:(and (= l_schedule, "Y"), (= p_event_triggers, "Y"))
evaluates to t 

execute function informix.sp_trigger_event[procid=6257] ( p_event_ref = 7159602 ,  p_proc_na_events = N ,  p_due_tm = NULL. ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_proc_na_events = N
default value  p_due_tm = NULL.
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
let l_insert_cnt = 0 
let l_event_type = NULL. 
expression:
  (select event_type, event_code
    from event
    where (= event_ref, p_event_ref))
evaluates to AC ; RP ; 
let l_event_type = RP 
let l_event_code = AC 
expression:(null l_event_type)
evaluates to f 
let l_sp_cn_ref = NULL. 
expression:
  (select (min sp_cn_ref), (count *)
    from evnt_sp_cn
    where (= event_ref, p_event_ref))
evaluates to 1 ; 239091 ; 
let l_sp_cn_ref = 239091 
let l_count = 1 
expression:(> l_count, 1)
evaluates to f 
let l_contact_code = NULL. 
expression:(= l_count, 0)
evaluates to f 
expression:(not-null l_sp_cn_ref)
evaluates to t 
expression:
  (select srvctypecode, subscriber_code
    from sp_connection
    where (= sp_cn_ref, l_sp_cn_ref))
evaluates to UAT0341352 ; PID  ; 
let l_srvctypecode = PID  
let l_contact_code = UAT0341352 
expression:(= p_proc_na_events, "Y")
evaluates to f 
let l_sched_stat_code = NULL. 
expression:
  (select sched_stat_code, due_tm
    from schedule
    where (= event_ref, p_event_ref))
evaluates to NULL. ; NULL. ; 
let l_sched_stat_code = NULL. 
let l_due_tm = NULL. 
expression:(null l_sched_stat_code)
evaluates to t 
procedure sp_trigger_event returns 100 , Event is not scheduled 

expression:(<procedure> sp_trigger_event, p_event_ref as p_event_ref, p_trigger_due_tm as p_due_tm, "N" as tran_flg)
evaluates to Event is not scheduled ; 100 ; 
let l_return = 100 
let l_msg = Event is not scheduled 
expression:(= l_schedule, "Y")
evaluates to t 

execute function informix.sp_sched_evnt[procid=7423] ( p_event_ref = 7159602 ,  p_to_login = system ,  p_to_dept = SYS ,  p_sched_code = ACT ,  p_due_tm = 2025-03-26 15:26:32 ,  p_created_by = webuser ,  p_created_tm = 2025-03-26 15:26:32 ,  p_sched_stat_code = O  ,  p_stat_tm = 2025-03-26 15:26:32 ,  p_stat_effect_by = NULL. ,  p_note_text = NULL. ,  p_event_triggers = Y ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_due_tm = 2025-03-26 15:26:32.000
default value  p_created_by = webuser
default value  p_created_tm = 2025-03-26 15:26:32.000
default value  p_stat_tm = 2025-03-26 15:26:32.000
default value  p_stat_effect_by = webuser
default value  p_note_text = NULL.
default value  p_event_triggers = Y
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
expression:
  (select event_ref
    from schedule
    where (= event_ref, p_event_ref))
evaluates to NULL. ; 
let l_old_event_ref = NULL. 
expression:(= (dbinfo-sqlca.sqlerrd2 ), 1)
evaluates to f 

execute function informix.sischedule[procid=1796] ( p_event_ref = 7159602 ,  p_to_login = system ,  p_to_dept = SYS ,  p_sched_code = ACT ,  p_due_tm = 2025-03-26 15:26:32 ,  p_created_by = webuser ,  p_created_tm = 2025-03-26 15:26:32 ,  p_sched_stat_code = O  ,  p_stat_tm = 2025-03-26 15:26:32 ,  p_stat_effect_by = NULL. ,  tran_flg = N )
default value  p_due_tm = NULL.
default value  p_created_tm = 2025-03-26 15:26:32
default value  p_sched_stat_code = NULL.
default value  p_stat_tm = NULL.
default value  p_stat_effect_by = NULL.
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 

insert into schedule(event_ref, to_login, to_dept, sched_code, due_tm, created_by, created_tm, sched_stat_code, stat_tm, stat_effect_by)
  values (p_event_ref, p_to_login, p_to_dept, p_sched_code, p_due_tm, p_created_by, p_created_tm, p_sched_stat_code, p_stat_tm, p_stat_effect_by);

before actions:

end before actions

for each row actions: 

execute procedure informix.sp_new_scheddimen[procid=8514] ( p_event_ref = 7159602 ,  p_sched_stat_code = O  ,  p_due_tm = 2025-03-26 15:26:32 ,  resume_flg = N ,  tran_flg = N )
default value  p_due_tm = NULL.
default value  resume_flg = N
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 
expression:
  (select evnt_sp_cn.sp_cn_ref, sp_connected, sp_disconnected, phone_num, nt_connected, nt_cn_ref, sched_stat_code.sched_stat_narr, event_type, event_code, srvctypecode
    from sched_stat_code, event, outer(evnt_sp_cn, sp_connection)
    where (and (and (and (= event.event_ref, evnt_sp_cn.event_ref), (= sp_connection.sp_cn_ref, evnt_sp_cn.sp_cn_ref)), (= sched_stat_code.sched_stat_code, p_sched_stat_code)), (= event.event_ref, p_event_ref)))
evaluates to PID  ; AC ; RP ; Open                             ; 168093 ; NULL. ; PD161470                                                         ; 2025-03-26 02:03:41 ; 2025-03-26 02:03:41 ; 239091 ; 
let l_sp_cn_ref = 239091 
let l_sp_connected = 2025-03-26 02:03:41 
let l_sp_disconnected = 2025-03-26 02:03:41 
let l_phone_num = PD161470                                                         
let l_nt_connected = NULL. 
let l_nt_cn_ref = 168093 
let l_sched_stat_narr = Open                             
let l_event_type = RP 
let l_event_code = AC 
let l_srvctypecode = PID  

insert into sched_dimension(event_ref, sp_cn_ref, due_tm, sched_stat_code, nt_connected, phone_num, nt_cn_ref, sched_stat_narr, sp_connected, sp_disconnected, event_type, event_code, srvctypecode)
  values (p_event_ref, l_sp_cn_ref, p_due_tm, p_sched_stat_code, l_nt_connected, l_phone_num, l_nt_cn_ref, l_sched_stat_narr, l_sp_connected, l_sp_disconnected, l_event_type, l_event_code, l_srvctypecode);

before actions:

end before actions

for each row actions: 

end for each row actions

after actions:

end after actions
expression:(or (= tran_flg, "C"), (= tran_flg, "Y"))
evaluates to f 
procedure sp_new_scheddimen returned no data


end for each row actions

after actions:

end after actions
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
let return_status = 0 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
expression:return_status
evaluates to 0 
procedure sischedule returns 0 

expression:(<procedure> sischedule, p_event_ref as p_event_ref, p_to_login as p_to_login, p_to_dept as p_to_dept, p_sched_code as p_sched_code, p_due_tm as p_due_tm, p_created_by as p_created_by, p_created_tm as p_created_tm, p_sched_stat_code as p_sched_stat_code, p_stat_tm as p_stat_tm, p_stat_effect_by as p_stat_effect_by, "N" as tran_flg)
evaluates to 0 
let l_return = 0 
expression:(not-null p_note_text)
evaluates to f 
expression:(= p_event_triggers, "Y")
evaluates to t 

execute function informix.sp_trigger_event[procid=6257] ( p_event_ref = 7159602 ,  p_proc_na_events = N ,  p_due_tm = NULL. ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_proc_na_events = N
default value  p_due_tm = NULL.
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
let l_insert_cnt = 0 
let l_event_type = NULL. 
expression:
  (select event_type, event_code
    from event
    where (= event_ref, p_event_ref))
evaluates to AC ; RP ; 
let l_event_type = RP 
let l_event_code = AC 
expression:(null l_event_type)
evaluates to f 
let l_sp_cn_ref = NULL. 
expression:
  (select (min sp_cn_ref), (count *)
    from evnt_sp_cn
    where (= event_ref, p_event_ref))
evaluates to 1 ; 239091 ; 
let l_sp_cn_ref = 239091 
let l_count = 1 
expression:(> l_count, 1)
evaluates to f 
let l_contact_code = NULL. 
expression:(= l_count, 0)
evaluates to f 
expression:(not-null l_sp_cn_ref)
evaluates to t 
expression:
  (select srvctypecode, subscriber_code
    from sp_connection
    where (= sp_cn_ref, l_sp_cn_ref))
evaluates to UAT0341352 ; PID  ; 
let l_srvctypecode = PID  
let l_contact_code = UAT0341352 
expression:(= p_proc_na_events, "Y")
evaluates to f 
let l_sched_stat_code = NULL. 
expression:
  (select sched_stat_code, due_tm
    from schedule
    where (= event_ref, p_event_ref))
evaluates to 2025-03-26 15:26:32 ; O  ; 
let l_sched_stat_code = O  
let l_due_tm = 2025-03-26 15:26:32 
expression:(null l_sched_stat_code)
evaluates to f 
expression:(<> l_sched_stat_code, "O")
evaluates to f 
expression:(not-null p_due_tm)
evaluates to f 
expression:(and (and (not-null l_sp_cn_ref), (= l_event_type, "CM")), (= l_event_code, "DR"))
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
start select cursor.
select trigger_type, trigger_code
  from evnt_trigger
  where (and (and (and (= event_type, l_event_type), (= event_code, l_event_code)), (= trigger_on_stat, l_sched_stat_code)), (or (= srvctypecode, "ALL"), (= srvctypecode, l_srvctypecode)))
select cursor iteration.
end cursor
expression:(= tran_flg, "Y")
evaluates to f 
expression:(= l_insert_cnt, 0)
evaluates to t 
procedure sp_trigger_event returns 100 , No events triggered 

expression:(<procedure> sp_trigger_event, p_event_ref as p_event_ref, "N" as tran_flg)
evaluates to No events triggered ; 100 ; 
let l_return = 100 
let l_msg = No events triggered 
expression:(= tran_flg, "Y")
evaluates to f 
procedure sp_sched_evnt returns 0 , NULL. 

expression:(<procedure> sp_sched_evnt, p_event_ref as p_event_ref, p_to_login as p_to_login, p_to_dept as p_to_dept, p_sched_code as p_sched_code, p_due_tm as p_due_tm, p_created_by as p_created_by, p_created_tm as p_created_tm, p_sched_stat_code as p_sched_stat_code, p_stat_tm as p_stat_tm, p_stat_effect_by as p_stat_effect_by, p_event_triggers as p_event_triggers, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_return = 0 
let l_msg = NULL. 
expression:(and (= p_event_type, "AA"), (= p_event_code, "BR"))
evaluates to f 
expression:(and (not-null l_acct_void_event), (> (<procedure> length, l_acct_void_event), 6))
evaluates to f 
expression:(not-null p_sp_cn_ref)
evaluates to t 

execute function informix.ss_sys_cnfg[procid=7787] ( p_cnfg_key = LINK_ATTRIBUTES_TO_EVENT_RP_AC ,  p_alt_cnfg_key = NULL. ,  p_default_val = N ,  p_force_upper = Y ,  p_max_length = 1 ,  p_check_is_numeric = N ,  p_check_is_dt = N ,  trace_flg = N ,  resume_flg = N )
default value  p_alt_cnfg_key = NULL.
default value  p_default_val = NULL.
default value  p_force_upper = N
default value  p_max_length = 0
default value  p_check_is_numeric = N
default value  p_check_is_dt = N
default value  trace_flg = N
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

set lock mode to wait 30;
expression:(<procedure> upper, p_cnfg_key)
evaluates to LINK_ATTRIBUTES_TO_EVENT_RP_AC   
let p_cnfg_key = LINK_ATTRIBUTES_TO_EVENT_RP_AC   
let l_cnfg_val = NULL. 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_cnfg_key))
evaluates to NULL. ; 
let l_cnfg_val = NULL. 
expression:(and (null l_cnfg_val), (not-null p_alt_cnfg_key))
evaluates to f 
expression:(nvl l_cnfg_val, p_default_val)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_force_upper, "Y")
evaluates to t 
expression:(<procedure> upper, l_cnfg_val)
evaluates to N 
let l_cnfg_val = N 
expression:(> p_max_length, 0)
evaluates to t 
expression:(substring l_cnfg_val, 1, p_max_length)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(= p_check_is_dt, "Y")
evaluates to f 
expression:l_cnfg_val
evaluates to N 
procedure ss_sys_cnfg returns 0 , N , NULL. 

expression:(<procedure> ss_sys_cnfg, (|| (|| (|| "LINK_ATTRIBUTES_TO_EVENT_", l_event_type), "_"), l_event_code) as p_cnfg_key, "N" as p_default_val, 1 as p_max_length, "Y" as p_force_upper)
evaluates to NULL. ; N ; 0 ; 
let l_return = 0 
let l_link_attributes = N 
let l_msg = NULL. 
expression:(= l_link_attributes, "Y")
evaluates to f 
expression:(and (= l_schedule, "Y"), (= p_create_sms, "Y"))
evaluates to t 

execute function informix.ss_sys_cnfg[procid=7787] ( p_cnfg_key = SMS_EVENT_RP_AC ,  p_alt_cnfg_key = NULL. ,  p_default_val = N ,  p_force_upper = Y ,  p_max_length = 1 ,  p_check_is_numeric = N ,  p_check_is_dt = N ,  trace_flg = N ,  resume_flg = N )
default value  p_alt_cnfg_key = NULL.
default value  p_default_val = NULL.
default value  p_force_upper = N
default value  p_max_length = 0
default value  p_check_is_numeric = N
default value  p_check_is_dt = N
default value  trace_flg = N
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

set lock mode to wait 30;
expression:(<procedure> upper, p_cnfg_key)
evaluates to SMS_EVENT_RP_AC                  
let p_cnfg_key = SMS_EVENT_RP_AC                  
let l_cnfg_val = NULL. 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_cnfg_key))
evaluates to NULL. ; 
let l_cnfg_val = NULL. 
expression:(and (null l_cnfg_val), (not-null p_alt_cnfg_key))
evaluates to f 
expression:(nvl l_cnfg_val, p_default_val)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_force_upper, "Y")
evaluates to t 
expression:(<procedure> upper, l_cnfg_val)
evaluates to N 
let l_cnfg_val = N 
expression:(> p_max_length, 0)
evaluates to t 
expression:(substring l_cnfg_val, 1, p_max_length)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(= p_check_is_dt, "Y")
evaluates to f 
expression:l_cnfg_val
evaluates to N 
procedure ss_sys_cnfg returns 0 , N , NULL. 

expression:(<procedure> ss_sys_cnfg, (|| (|| (|| "SMS_EVENT_", p_event_type), "_"), p_event_code) as p_cnfg_key, "N" as p_default_val, 1 as p_max_length, "Y" as p_force_upper)
evaluates to NULL. ; N ; 0 ; 
let l_return = 0 
let l_is_sms_event = N 
let l_msg = NULL. 
expression:(= l_is_sms_event, "Y")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
expression:p_event_ref
evaluates to 7159602 
procedure sp_new_event returns 0 , 7159602 

expression:(<procedure> sp_new_event, 0 as p_event_ref, l_trigger_type as p_event_type, l_trigger_code as p_event_code, <USER> as p_created_by, p_event_ref as p_parent_event, "T" as p_evntrelntypecode, l_targ_subscriber_code as p_contact_code, l_targ_sp_cn_ref as p_sp_cn_ref, current year to fraction(3) as p_created_tm,  <NULL>  as p_note_text, "system" as p_to_login, "SYS" as p_to_dept, "ACT" as p_sched_code, l_due_tm as p_due_tm, "O" as p_sched_stat_code,  <NULL>  as p_stat_effect_by, current year to fraction(3) as p_stat_tm, "N" as tran_flg)
evaluates to 7159602 ; 0 ; 
let l_return = 0 
let l_event_ref = 7159602 
select cursor iteration.
end cursor
expression:(= tran_flg, "Y")
evaluates to f 
expression:(= l_insert_cnt, 0)
evaluates to f 
expression:(|| l_insert_cnt, " event(s) triggered")
evaluates to 1 event(s) triggered 
procedure sp_trigger_event returns 0 , 1 event(s) triggered 

expression:(<procedure> sp_trigger_event, p_event_ref as p_event_ref, "N" as tran_flg)
evaluates to 1 event(s) triggered ; 0 ; 
let l_return = 0 
let l_msg = 1 event(s) triggered 

execute function informix.sp_add_event_note[procid=1708] ( p_event_ref = 7159601 ,  p_note_text = Event Close. ,  resume_flg = N ,  tran_flg = N )
default value  resume_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 
expression:(not-null p_note_text)
evaluates to t 
let l_note_order_num = NULL. 
let l_note_group_num = NULL. 
expression:
  (select (max note_order_num), (max note_group_num)
    from evnt_note
    where (= event_ref, p_event_ref))
evaluates to NULL. ; NULL. ; 
let l_note_order_num = NULL. 
let l_note_group_num = NULL. 
expression:(null l_note_order_num)
evaluates to t 
let l_note_order_num = 0 
expression:(null l_note_group_num)
evaluates to t 
let l_note_group_num = 0 
expression:(+ l_note_group_num, 1)
evaluates to 1 
let l_note_group_num = 1 
expression:(<> p_note_text, "")
evaluates to t 
expression:(+ l_note_order_num, 1)
evaluates to 1 
let l_note_order_num = 1 

execute function informix.sievnt_note[procid=3525] ( p_event_ref = 7159601 ,  p_note_order_num = 1 ,  p_note_text = Event Close.                                                                                                                                                                                                                                                   ,  p_note_group_num = 1 ,  tran_flg = N )
default value  p_note_text = NULL.
default value  p_note_group_num = 1
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 

insert into evnt_note(event_ref, note_order_num, note_text, note_group_num)
  values (p_event_ref, p_note_order_num, p_note_text, p_note_group_num);

before actions:

end before actions

for each row actions: 

end for each row actions

after actions:

end after actions
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
let return_status = 0 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
expression:return_status
evaluates to 0 
procedure sievnt_note returns 0 

expression:(<procedure> sievnt_note, p_event_ref as p_event_ref, l_note_order_num as p_note_order_num, p_note_text[1, 254] as p_note_text, l_note_group_num as p_note_group_num, "N" as tran_flg)
evaluates to 0 
let l_return = 0 
expression:p_note_text[255, 2048]
evaluates to                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
let p_note_text =                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
expression:(<> p_note_text, "")
evaluates to f 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
procedure sp_add_event_note returns 0 , NULL. 

expression:(<procedure> sp_add_event_note, p_event_ref as p_event_ref, p_note_text as p_note_text, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_return = 0 
let l_msg = NULL. 

execute function informix.ss_sys_cnfg[procid=7787] ( p_cnfg_key = CLOSE_PARENT_EVENT_CMIC ,  p_alt_cnfg_key = NULL. ,  p_default_val = N ,  p_force_upper = Y ,  p_max_length = 1 ,  p_check_is_numeric = N ,  p_check_is_dt = N ,  trace_flg = N ,  resume_flg = N )
default value  p_alt_cnfg_key = NULL.
default value  p_default_val = NULL.
default value  p_force_upper = N
default value  p_max_length = 0
default value  p_check_is_numeric = N
default value  p_check_is_dt = N
default value  trace_flg = N
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

set lock mode to wait 30;
expression:(<procedure> upper, p_cnfg_key)
evaluates to CLOSE_PARENT_EVENT_CMIC          
let p_cnfg_key = CLOSE_PARENT_EVENT_CMIC          
let l_cnfg_val = NULL. 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_cnfg_key))
evaluates to NULL. ; 
let l_cnfg_val = NULL. 
expression:(and (null l_cnfg_val), (not-null p_alt_cnfg_key))
evaluates to f 
expression:(nvl l_cnfg_val, p_default_val)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_force_upper, "Y")
evaluates to t 
expression:(<procedure> upper, l_cnfg_val)
evaluates to N 
let l_cnfg_val = N 
expression:(> p_max_length, 0)
evaluates to t 
expression:(substring l_cnfg_val, 1, p_max_length)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(= p_check_is_dt, "Y")
evaluates to f 
expression:l_cnfg_val
evaluates to N 
procedure ss_sys_cnfg returns 0 , N , NULL. 

expression:(<procedure> ss_sys_cnfg, (|| (|| "CLOSE_PARENT_EVENT_", l_event_type), l_event_code) as p_cnfg_key, "N" as p_default_val, "Y" as p_force_upper, 1 as p_max_length)
evaluates to NULL. ; N ; 0 ; 
let l_return = 0 
let l_close_parent_event = N 
let l_msg = NULL. 
expression:(= l_close_parent_event, "Y")
evaluates to f 
start select cursor.
select attribid, attribvalue
  from evntattrtrig
  where (and (and (and (= event_type, l_event_type), (= event_code, l_event_code)), (= sched_stat_code, p_sched_stat_code)), (= enabled, "Y"))
select cursor iteration.
end cursor
expression:(= p_update_correspnd, "Y")
evaluates to t 
expression:(= p_sched_stat_code, "O")
evaluates to f 
expression:(= p_sched_stat_code, "F")
evaluates to f 
expression:(= p_sched_stat_code, "C")
evaluates to t 
let l_corr_status_code = S 
let l_sent_dt = 2025-03-26 15:26:32.000 
expression:(not-null l_corr_status_code)
evaluates to t 

update correspondence set
    (corr_status_code) = (l_corr_status_code),
    (sent_dt) = (l_sent_dt)
  where (and (= event_ref, p_event_ref), (<> corr_status_code, l_corr_status_code));

before actions:

end before actions

after actions:

end after actions
expression:(= tran_flg, "Y")
evaluates to f 
procedure sp_chg_sched_stat returns 0 , NULL. 

expression:(<procedure> sp_chg_sched_stat, p_sched_ref as p_event_ref, p_sched_stat_code as p_sched_stat_code, "Event Close." as p_note_text, p_event_triggers as p_event_triggers, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_return = 0 
let l_msg = NULL. 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
procedure sp_close_evnt returns 0 , NULL. 

expression:(<procedure> sp_close_evnt, p_event_ref as p_sched_ref, current year to fraction(3) as p_actual_change_dt, p_event_triggers as p_event_triggers, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_return = 0 
let l_msg = NULL. 
expression:
  (select sp_connection.sp_cn_ref, sp_connected, sp_disconnected, subscriber_code
    from sp_cn_plan, sp_connection
    where (and (= sp_plan_ref, l_sp_plan_ref), (= sp_connection.sp_cn_ref, sp_cn_plan.sp_cn_ref)))
evaluates to UAT0341352 ; 2025-03-26 02:03:41 ; 2025-03-26 02:03:41 ; 239091 ; 
let l_chksp_cn_ref = 239091 
let l_sp_connected = 2025-03-26 02:03:41 
let l_sp_disconnected = 2025-03-26 02:03:41 
let l_subscriber_code = UAT0341352 
expression:(<> (dbinfo-sqlca.sqlerrd2 ), 1)
evaluates to f 
expression:(<> l_sp_connected, l_sp_disconnected)
evaluates to f 
expression:(<> l_chksp_cn_ref, l_sp_cn_ref)
evaluates to f 
start select cursor.
select sp_cn_chg_ref, frequency
  from sp_cn_chg
  where (and (and (and (= sp_cn_ref, l_sp_cn_ref), (null sp_plan_ref)), (= start_date, l_sp_connected)), (= end_date, l_sp_connected))
select cursor iteration.
end cursor

execute function informix.sp_new_event[procid=9653] ( p_event_ref = 0 ,  p_event_type = CM ,  p_event_code = CE ,  p_created_by = webuser ,  p_parent_event = NULL. ,  p_evntrelntypecode = F ,  p_evnt_oth_ref = NULL. ,  p_sp_cn_ref = 239091 ,  p_contact_code = NULL. ,  p_created_tm = 2025-03-26 02:03:41 ,  p_note_text = NULL. ,  p_note_text2 = NULL. ,  p_evnt_reas_code = NULL. ,  p_to_login = NULL. ,  p_to_dept = NULL. ,  p_sched_code = NULL. ,  p_due_tm = 2025-03-26 15:26:32.000 ,  p_trigger_due_tm = NULL. ,  p_sched_stat_code = NULL. ,  p_stat_tm = 2025-03-26 15:26:32.000 ,  p_stat_effect_by = webuser ,  p_bill_ref = NULL. ,  p_bill_event_type = NULL. ,  p_bill_step_ref = NULL. ,  p_attach_loc = NULL. ,  p_priority_id = NULL. ,  p_alert = N ,  p_translate = Y ,  p_mode = B ,  p_creditchkevnt_crt = Y ,  p_spcnhist_to_dt = NULL. ,  p_event_triggers = Y ,  p_fin_ref = NULL. ,  p_create_sms = Y ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_event_ref = 0
default value  p_created_by = webuser
default value  p_parent_event = NULL.
default value  p_evntrelntypecode = F
default value  p_evnt_oth_ref = NULL.
default value  p_sp_cn_ref = NULL.
default value  p_contact_code = NULL.
default value  p_created_tm = 2025-03-26 15:26:32.000
default value  p_note_text = NULL.
default value  p_note_text2 = NULL.
default value  p_evnt_reas_code = NULL.
default value  p_to_login = NULL.
default value  p_to_dept = NULL.
default value  p_sched_code = NULL.
default value  p_due_tm = 2025-03-26 15:26:32.000
default value  p_trigger_due_tm = NULL.
default value  p_sched_stat_code = NULL.
default value  p_stat_tm = 2025-03-26 15:26:32.000
default value  p_stat_effect_by = webuser
default value  p_bill_ref = NULL.
default value  p_bill_event_type = NULL.
default value  p_bill_step_ref = NULL.
default value  p_attach_loc = NULL.
default value  p_priority_id = NULL.
default value  p_alert = N
default value  p_translate = N
default value  p_mode = U
default value  p_creditchkevnt_crt = Y
default value  p_spcnhist_to_dt = NULL.
default value  p_event_triggers = Y
default value  p_fin_ref = NULL.
default value  p_create_sms = Y
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 

set lock mode to wait 5;
expression:(or (null p_event_type), (null p_event_code))
evaluates to f 
expression:(and (not-null p_bill_ref), (null p_bill_event_type))
evaluates to f 
let l_acct_void_event = NULL. 
let l_contact_code = NULL. 
let l_sys_status = NULL. 
let l_cm_ic_cnt = NULL. 
let l_cm_pi_cnt = NULL. 
let l_sm_sc_cnt = NULL. 
let l_sm_sp_cnt = NULL. 
let l_event_ref = NULL. 

execute function informix.ss_sys_cnfg[procid=7787] ( p_cnfg_key = ACCT_TO_VOID_EVENT ,  p_alt_cnfg_key = NULL. ,  p_default_val = N ,  p_force_upper = N ,  p_max_length = 10 ,  p_check_is_numeric = N ,  p_check_is_dt = N ,  trace_flg = N ,  resume_flg = N )
default value  p_alt_cnfg_key = NULL.
default value  p_default_val = NULL.
default value  p_force_upper = N
default value  p_max_length = 0
default value  p_check_is_numeric = N
default value  p_check_is_dt = N
default value  trace_flg = N
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

set lock mode to wait 30;
expression:(<procedure> upper, p_cnfg_key)
evaluates to ACCT_TO_VOID_EVENT               
let p_cnfg_key = ACCT_TO_VOID_EVENT               
let l_cnfg_val = NULL. 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_cnfg_key))
evaluates to NULL. ; 
let l_cnfg_val = NULL. 
expression:(and (null l_cnfg_val), (not-null p_alt_cnfg_key))
evaluates to f 
expression:(nvl l_cnfg_val, p_default_val)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_force_upper, "Y")
evaluates to f 
expression:(> p_max_length, 0)
evaluates to t 
expression:(substring l_cnfg_val, 1, p_max_length)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(= p_check_is_dt, "Y")
evaluates to f 
expression:l_cnfg_val
evaluates to N 
procedure ss_sys_cnfg returns 0 , N , NULL. 

expression:(<procedure> ss_sys_cnfg, "ACCT_TO_VOID_EVENT" as p_cnfg_key, "N" as p_default_val, 10 as p_max_length, "N" as p_force_upper)
evaluates to NULL. ; N ; 0 ; 
let l_return = 0 
let l_acct_void_event = N 
let l_msg = NULL. 
expression:(= p_translate, "Y")
evaluates to t 

execute function informix.ss_flex_code[procid=1382] ( p_sys_table = evnt_code ,  p_sys_hard_group = CM ,  p_sys_hard_code = CE ,  p_multiple_rows = N ,  p_msg = NULL. ,  resume_flg = Z )
default value  p_multiple_rows = N
default value  p_msg = NULL.
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(not-in resume_flg, "Y", "N", "Z")
evaluates to f 
let l_found = N 
let l_tmp_key1 = NULL. 
expression:(not-null p_msg)
evaluates to f 
expression:(|| (|| "Flex key not found: ", TRIM ( BOTH ' ' FROM p_sys_table)), " | ")
evaluates to Flex key not found: evnt_code |  
let l_msg = Flex key not found: evnt_code |  
expression:(not-null p_sys_hard_group)
evaluates to t 
expression:(|| (|| l_msg, TRIM ( BOTH ' ' FROM p_sys_hard_group)), " | ")
evaluates to Flex key not found: evnt_code | CM |  
let l_msg = Flex key not found: evnt_code | CM |  
expression:(not-null p_sys_hard_code)
evaluates to t 
expression:(|| (|| l_msg, TRIM ( BOTH ' ' FROM p_sys_hard_code)), ". ")
evaluates to Flex key not found: evnt_code | CM | CE.  
let l_msg = Flex key not found: evnt_code | CM | CE.  
start select cursor.
select flex_key1, flex_key2
  from sys_code
  where (and (and (= sys_table, p_sys_table), (or (= sys_hard_group, p_sys_hard_group), (null p_sys_hard_group))), (or (= sys_hard_code, p_sys_hard_code), (null p_sys_hard_code)))
  order by flex_key2
select cursor iteration.
select cursor returns CM , CE 
expression:(= l_found, "N")
evaluates to t 
expression:l_flex_key1
evaluates to CM 
let l_tmp_key1 = CM 
expression:l_flex_key2
evaluates to CE 
let l_tmp_key2 = CE 
let l_found = Y 
select cursor iteration.
end cursor
expression:(not-null l_tmp_key1)
evaluates to t 
expression:l_tmp_key2
evaluates to CE 
expression:l_tmp_key1
evaluates to CM 
procedure ss_flex_code returns 0 , CM , CE 

expression:(<procedure> ss_flex_code, "evnt_code" as p_sys_table, p_event_type as p_sys_hard_group, p_event_code as p_sys_hard_code, "Z" as resume_flg)
evaluates to CE                               ; CM                               ; 0 ; 
let l_return = 0 
let l_event_type = CM                               
let l_event_code = CE                               
let l_count = 0 
expression:
  (select (count *)
    from evnt_code
    where (and (= event_type, l_event_type), (= event_code, l_event_code)))
evaluates to 1 ; 
let l_count = 1 
expression:(<> l_count, 1)
evaluates to f 
expression:(and (and (not-null p_to_login), (not-null p_to_dept)), (not-null p_sched_code))
evaluates to f 
let l_schedule = N 

execute function informix.sievent[procid=7558] ( p_event_ref = 0 ,  p_event_type = CM ,  p_event_code = CE ,  p_created_by = webuser ,  p_created_tm = 2025-03-26 02:03:41 ,  tran_flg = N )
default value  p_event_ref = 0
default value  p_created_by = webuser
default value  p_created_tm = 2025-03-26 15:26:32
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 

insert into event(event_ref, event_type, event_code, created_by, created_tm)
  values (p_event_ref, p_event_type, p_event_code, p_created_by, p_created_tm);

before actions:

end before actions

for each row actions: 

end for each row actions

after actions:

end after actions
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
let return_status = 0 
expression:(dbinfo-sqlca.sqlerrd1 )
evaluates to 7159603 
let ser_num = 7159603 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
expression:ser_num
evaluates to 7159603 
expression:return_status
evaluates to 0 
procedure sievent returns 0 , 7159603 

expression:(<procedure> sievent, p_event_ref as p_event_ref, l_event_type as p_event_type, l_event_code as p_event_code, p_created_by as p_created_by, p_created_tm as p_created_tm, "N" as tran_flg)
evaluates to 7159603 ; 0 ; 
let l_return = 0 
let p_event_ref = 7159603 
expression:(not-null p_contact_code)
evaluates to f 
expression:(not-null p_sp_cn_ref)
evaluates to t 

execute function informix.sievnt_sp_cn[procid=893] ( p_event_ref = 7159603 ,  p_sp_cn_ref = 239091 ,  tran_flg = N )
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 

insert into evnt_sp_cn(event_ref, sp_cn_ref)
  values (p_event_ref, p_sp_cn_ref);

before actions:

end before actions

for each row actions: 

end for each row actions

after actions:

end after actions
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
let return_status = 0 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
expression:return_status
evaluates to 0 
procedure sievnt_sp_cn returns 0 

expression:(<procedure> sievnt_sp_cn, p_event_ref as p_event_ref, p_sp_cn_ref as p_sp_cn_ref, "N" as tran_flg)
evaluates to 0 
let l_return = 0 
expression:(= l_schedule, "N")
evaluates to t 
let l_sched_stat_code = C 
let l_sp_cn_status = NULL. 
expression:
  (select evnt_code_sv_st.sp_cn_status
    from sp_connection, evnt_code_sv_st
    where (and (and (and (and (= sp_connection.srvctypecode, evnt_code_sv_st.srvctypecode), (= event_type, l_event_type)), (= event_code, l_event_code)), (= sched_stat_code, l_sched_stat_code)), (= sp_cn_ref, p_sp_cn_ref)))
evaluates to NULL. ; 
let l_sp_cn_status = NULL. 
expression:(null l_sp_cn_status)
evaluates to t 
expression:
  (select sp_cn_status
    from evnt_code_sv_st
    where (and (and (and (= event_type, l_event_type), (= event_code, l_event_code)), (= sched_stat_code, l_sched_stat_code)), (= srvctypecode, "ALL")))
evaluates to OPN ; 
let l_sp_cn_status = OPN 
expression:(not-null l_sp_cn_status)
evaluates to t 

execute function informix.sp_chg_cn_status[procid=5638] ( p_sp_cn_ref = 239091 ,  p_sp_cn_status = OPN ,  p_sp_cn_stat_type = B ,  p_event_ref = 7159603 ,  p_translate = N ,  p_spcnhist_to_dt = NULL. ,  updated_by = webuser ,  resume_flg = N ,  tran_flg = N )
default value  p_sp_cn_stat_type = U
default value  p_translate = N
default value  p_spcnhist_to_dt = NULL.
default value  updated_by = webuser
default value  resume_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 
expression:(and (and (<> p_sp_cn_stat_type, "U"), (<> p_sp_cn_stat_type, "S")), (<> p_sp_cn_stat_type, "B"))
evaluates to f 
expression:(= p_translate, "N")
evaluates to t 
expression:p_sp_cn_status
evaluates to OPN 
let l_new_status = OPN 
expression:(= p_sp_cn_stat_type, "B")
evaluates to t 
let l_sp_cn_stat_type = S 
expression:(= l_sp_cn_stat_type, "U")
evaluates to f 
expression:
  (select sys_status, subscriber_code, srvctypecode
    from sp_connection
    where (= sp_cn_ref, p_sp_cn_ref))
evaluates to PID  ; UAT0341352 ; IDS ; 
let l_old_status = IDS 
let l_subscriber_code = UAT0341352 
let l_srvctypecode = PID  
expression:(<> (dbinfo-sqlca.sqlerrd2 ), 1)
evaluates to f 
expression:(or (null l_old_status), (<> l_old_status, l_new_status))
evaluates to t 
expression:(not-null l_old_status)
evaluates to t 

execute function informix.sp_sp_cn_hist[procid=3326] ( p_sp_cn_ref = 239091 ,  p_event_ref = 7159603 ,  p_to_dt = NULL. ,  resume_flg = N ,  tran_flg = N )
default value  p_event_ref = NULL.
default value  p_to_dt = NULL.
default value  resume_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 
let l_phone_num = NULL. 
expression:(nvl p_to_dt, (- current year to fraction(3), (units 1, 2474)))
evaluates to 2025-03-26 15:26:31.000 
let p_to_dt = 2025-03-26 15:26:31.000 
let l_sp_cn_history_id = NULL. 
expression:
  (select phone_num, sp_cn_narr, srvctypecode, sp_connected, sp_disconnected, sp_cn_status, sys_status, sp_enq_passwd, sp_mailbox_num, updated_by
    from sp_connection
    where (= sp_cn_ref, p_sp_cn_ref))
evaluates to webuser ; NULL. ; test@333                         ; IDS ; IDS ; 2025-03-26 02:03:41 ; 2025-03-26 02:03:41 ; PID  ; Test New Service Post Ar 1 ; PD161470                                                         ; 
let l_phone_num = PD161470                                                         
let l_sp_cn_narr = Test New Service Post Ar 1 
let l_srvctypecode = PID  
let l_sp_connected = 2025-03-26 02:03:41 
let l_sp_disconnected = 2025-03-26 02:03:41 
let l_sp_cn_status = IDS 
let l_sys_status = IDS 
let l_sp_enq_passwd = test@333                         
let l_sp_mailbox_num = NULL. 
let l_updated_by = webuser 
expression:(null l_phone_num)
evaluates to f 
expression:
  (select sp_cn_history_id
    from sp_cn_history
    where (and (= sp_cn_ref, p_sp_cn_ref), (between to_dt, (- p_to_dt, (units 3, 2474)), p_to_dt)))
evaluates to NULL. ; 
let l_sp_cn_history_id = NULL. 
expression:(null l_sp_cn_history_id)
evaluates to t 
expression:
  (select (max to_dt)
    from sp_cn_history
    where (= sp_cn_ref, p_sp_cn_ref))
evaluates to NULL. ; 
let l_to_dt = NULL. 
expression:(null l_to_dt)
evaluates to t 
let l_from_dt = 1900-01-01 00:00:00 

execute function informix.sisp_cn_history[procid=3305] ( p_sp_cn_history_id = 0 ,  p_sp_cn_ref = 239091 ,  p_from_dt = 1900-01-01 00:00:00 ,  p_to_dt = 2025-03-26 15:26:31 ,  p_phone_num = PD161470                                                         ,  p_sp_cn_narr = Test New Service Post Ar 1 ,  p_srvctypecode = PID  ,  p_sp_connected = 2025-03-26 02:03:41 ,  p_sp_disconnected = 2025-03-26 02:03:41 ,  p_sp_cn_status = IDS ,  p_sys_status = IDS ,  p_event_ref = 7159603 ,  p_sp_enq_passwd = test@333                         ,  p_sp_mailbox_num = NULL. ,  p_ori_updated_by = webuser ,  tran_flg = N )
default value  p_sp_cn_history_id = 0
default value  p_from_dt = 1990-01-01 00:00:00
default value  p_to_dt = 9999-01-01 00:00:00
default value  p_sp_cn_narr = NULL.
default value  p_event_ref = NULL.
default value  p_sp_mailbox_num = NULL.
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 

insert into sp_cn_history(sp_cn_history_id, sp_cn_ref, from_dt, to_dt, phone_num, sp_cn_narr, srvctypecode, sp_connected, sp_disconnected, sp_cn_status, sys_status, event_ref, sp_enq_passwd, sp_mailbox_num, ori_updated_by)
  values (p_sp_cn_history_id, p_sp_cn_ref, p_from_dt, p_to_dt, p_phone_num, p_sp_cn_narr, p_srvctypecode, p_sp_connected, p_sp_disconnected, p_sp_cn_status, p_sys_status, p_event_ref, p_sp_enq_passwd, p_sp_mailbox_num, p_ori_updated_by);

before actions:

end before actions

for each row actions: 

end for each row actions

after actions:

end after actions
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
let return_status = 0 
expression:(dbinfo-sqlca.sqlerrd1 )
evaluates to 477736 
let ser_num = 477736 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
expression:ser_num
evaluates to 477736 
expression:return_status
evaluates to 0 
procedure sisp_cn_history returns 0 , 477736 

expression:(<procedure> sisp_cn_history, 0 as p_sp_cn_history_id, p_sp_cn_ref as p_sp_cn_ref, l_from_dt as p_from_dt, p_to_dt as p_to_dt, l_phone_num as p_phone_num, l_sp_cn_narr as p_sp_cn_narr, l_srvctypecode as p_srvctypecode, l_sp_connected as p_sp_connected, l_sp_disconnected as p_sp_disconnected, l_sp_cn_status as p_sp_cn_status, l_sys_status as p_sys_status, p_event_ref as p_event_ref, l_sp_enq_passwd as p_sp_enq_passwd, l_sp_mailbox_num as p_sp_mailbox_num, l_updated_by as p_ori_updated_by)
evaluates to 477736 ; 0 ; 
let l_result = 0 
let l_sp_cn_history_id = 477736 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
expression:l_sp_cn_history_id
evaluates to 477736 
procedure sp_sp_cn_hist returns 0 , 477736 , NULL. 

expression:(<procedure> sp_sp_cn_hist, p_sp_cn_ref as p_sp_cn_ref, p_event_ref as p_event_ref, p_spcnhist_to_dt as p_to_dt, "N" as tran_flg)
evaluates to NULL. ; 477736 ; 0 ; 
let l_result = 0 
let l_sp_cn_history_id = 477736 
let l_msg = NULL. 
expression:(= l_sp_cn_stat_type, "U")
evaluates to f 

update sp_connection set
    (sys_status) = (l_new_status)
  where (= sp_cn_ref, p_sp_cn_ref);

before actions:

end before actions

for each row actions: 

execute function informix.get_upd_vals[procid=1412] ()
set_state: owner is informix - utype = 'D'procedure get_upd_vals returns webuser                          , 2025-03-26 15:26:32.000 


end for each row actions

after actions:

end after actions
expression:(<> (dbinfo-sqlca.sqlerrd2 ), 1)
evaluates to f 
expression:(= p_sp_cn_stat_type, "B")
evaluates to t 

execute function informix.sp_chg_cn_status[procid=5638] ( p_sp_cn_ref = 239091 ,  p_sp_cn_status = OPN ,  p_sp_cn_stat_type = U ,  p_event_ref = 7159603 ,  p_translate = N ,  p_spcnhist_to_dt = NULL. ,  updated_by = webuser ,  resume_flg = N ,  tran_flg = N )
default value  p_sp_cn_stat_type = U
default value  p_translate = N
default value  p_spcnhist_to_dt = NULL.
default value  updated_by = webuser
default value  resume_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 
expression:(and (and (<> p_sp_cn_stat_type, "U"), (<> p_sp_cn_stat_type, "S")), (<> p_sp_cn_stat_type, "B"))
evaluates to f 
expression:(= p_translate, "N")
evaluates to t 
expression:p_sp_cn_status
evaluates to OPN 
let l_new_status = OPN 
expression:(= p_sp_cn_stat_type, "B")
evaluates to f 
expression:p_sp_cn_stat_type
evaluates to U 
let l_sp_cn_stat_type = U 
expression:(= l_sp_cn_stat_type, "U")
evaluates to t 
expression:
  (select sp_cn_status, subscriber_code, srvctypecode
    from sp_connection
    where (= sp_cn_ref, p_sp_cn_ref))
evaluates to PID  ; UAT0341352 ; IDS ; 
let l_old_status = IDS 
let l_subscriber_code = UAT0341352 
let l_srvctypecode = PID  
expression:(<> (dbinfo-sqlca.sqlerrd2 ), 1)
evaluates to f 
expression:(or (null l_old_status), (<> l_old_status, l_new_status))
evaluates to t 
expression:(not-null l_old_status)
evaluates to t 

execute function informix.sp_sp_cn_hist[procid=3326] ( p_sp_cn_ref = 239091 ,  p_event_ref = 7159603 ,  p_to_dt = NULL. ,  resume_flg = N ,  tran_flg = N )
default value  p_event_ref = NULL.
default value  p_to_dt = NULL.
default value  resume_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 
let l_phone_num = NULL. 
expression:(nvl p_to_dt, (- current year to fraction(3), (units 1, 2474)))
evaluates to 2025-03-26 15:26:31.000 
let p_to_dt = 2025-03-26 15:26:31.000 
let l_sp_cn_history_id = NULL. 
expression:
  (select phone_num, sp_cn_narr, srvctypecode, sp_connected, sp_disconnected, sp_cn_status, sys_status, sp_enq_passwd, sp_mailbox_num, updated_by
    from sp_connection
    where (= sp_cn_ref, p_sp_cn_ref))
evaluates to webuser            ; NULL. ; test@333                         ; OPN ; IDS ; 2025-03-26 02:03:41 ; 2025-03-26 02:03:41 ; PID  ; Test New Service Post Ar 1 ; PD161470                                                         ; 
let l_phone_num = PD161470                                                         
let l_sp_cn_narr = Test New Service Post Ar 1 
let l_srvctypecode = PID  
let l_sp_connected = 2025-03-26 02:03:41 
let l_sp_disconnected = 2025-03-26 02:03:41 
let l_sp_cn_status = IDS 
let l_sys_status = OPN 
let l_sp_enq_passwd = test@333                         
let l_sp_mailbox_num = NULL. 
let l_updated_by = webuser            
expression:(null l_phone_num)
evaluates to f 
expression:
  (select sp_cn_history_id
    from sp_cn_history
    where (and (= sp_cn_ref, p_sp_cn_ref), (between to_dt, (- p_to_dt, (units 3, 2474)), p_to_dt)))
evaluates to 477736 ; 
let l_sp_cn_history_id = 477736 
expression:(null l_sp_cn_history_id)
evaluates to f 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
expression:l_sp_cn_history_id
evaluates to 477736 
procedure sp_sp_cn_hist returns 0 , 477736 , NULL. 

expression:(<procedure> sp_sp_cn_hist, p_sp_cn_ref as p_sp_cn_ref, p_event_ref as p_event_ref, p_spcnhist_to_dt as p_to_dt, "N" as tran_flg)
evaluates to NULL. ; 477736 ; 0 ; 
let l_result = 0 
let l_sp_cn_history_id = 477736 
let l_msg = NULL. 
expression:(= l_sp_cn_stat_type, "U")
evaluates to t 

update sp_connection set
    (sp_cn_status) = (l_new_status)
  where (= sp_cn_ref, p_sp_cn_ref);

before actions:

end before actions

for each row actions: 

execute function informix.get_upd_vals[procid=1412] ()
set_state: owner is informix - utype = 'D'procedure get_upd_vals returns webuser                          , 2025-03-26 15:26:32.000 


end for each row actions

after actions:

end after actions
expression:(<> (dbinfo-sqlca.sqlerrd2 ), 1)
evaluates to f 
expression:(= p_sp_cn_stat_type, "B")
evaluates to f 
expression:(<> l_srvctypecode, "ACCT")
evaluates to t 

execute function informix.sp_trigger_cont_stat[procid=9496] ( p_contact_code = UAT0341352 ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
let l_return_status = 100 
let l_cont_status = NULL. 
let l_new_cont_status = NULL. 

execute function informix.ss_sys_cnfg[procid=7787] ( p_cnfg_key = TRIGGER_CONT_STAT ,  p_alt_cnfg_key = NULL. ,  p_default_val = N ,  p_force_upper = Y ,  p_max_length = 1 ,  p_check_is_numeric = N ,  p_check_is_dt = N ,  trace_flg = N ,  resume_flg = N )
default value  p_alt_cnfg_key = NULL.
default value  p_default_val = NULL.
default value  p_force_upper = N
default value  p_max_length = 0
default value  p_check_is_numeric = N
default value  p_check_is_dt = N
default value  trace_flg = N
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

set lock mode to wait 30;
expression:(<procedure> upper, p_cnfg_key)
evaluates to TRIGGER_CONT_STAT                
let p_cnfg_key = TRIGGER_CONT_STAT                
let l_cnfg_val = NULL. 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_cnfg_key))
evaluates to Yes ; 
let l_cnfg_val = Yes 
expression:(and (null l_cnfg_val), (not-null p_alt_cnfg_key))
evaluates to f 
expression:(nvl l_cnfg_val, p_default_val)
evaluates to Yes 
let l_cnfg_val = Yes 
expression:(= p_force_upper, "Y")
evaluates to t 
expression:(<procedure> upper, l_cnfg_val)
evaluates to YES 
let l_cnfg_val = YES 
expression:(> p_max_length, 0)
evaluates to t 
expression:(substring l_cnfg_val, 1, p_max_length)
evaluates to Y 
let l_cnfg_val = Y 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(= p_check_is_dt, "Y")
evaluates to f 
expression:l_cnfg_val
evaluates to Y 
procedure ss_sys_cnfg returns 0 , Y , NULL. 

expression:(<procedure> ss_sys_cnfg, "TRIGGER_CONT_STAT" as p_cnfg_key, "N" as p_default_val, "Y" as p_force_upper, 1 as p_max_length)
evaluates to NULL. ; Y ; 0 ; 
let l_status = 0 
let l_trigger_on_stat = Y 
let l_msg = NULL. 
expression:(= l_trigger_on_stat, "N")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
expression:
  (select cont_status
    from contact
    where (= contact_code, p_contact_code))
evaluates to ACT ; 
let l_cont_status = ACT 
expression:
  (select (count *)
    from sp_connection
    where (and (= subscriber_code, p_contact_code), (<> srvctypecode, "ACCT")))
evaluates to 9 ; 
let l_total_services = 9 
expression:
  (select (count *)
    from sp_connection
    where (and (and (= subscriber_code, p_contact_code), (<> srvctypecode, "ACCT")), (= sys_status, "DIS")))
evaluates to 0 ; 
let l_dis_services = 0 
expression:
  (select (count *)
    from sp_connection
    where (and (and (= subscriber_code, p_contact_code), (<> srvctypecode, "ACCT")), (or (= sp_cn_status, "PDC"), (= sys_status, "DIS"))))
evaluates to 2 ; 
let l_pdc_services = 2 
expression:
  (select (count *)
    from sp_connection
    where (and (and (and (= subscriber_code, p_contact_code), (<> srvctypecode, "ACCT")), (in sys_status, "OPN", "IDS")), (in sp_cn_status, "OPN", "IDS")))
evaluates to 7 ; 
let l_opn_services = 7 
expression:
  (select (count *)
    from sp_connection
    where (and (and (= subscriber_code, p_contact_code), (<> srvctypecode, "ACCT")), (or (= sp_cn_status, "SUS"), (= sys_status, "DIS"))))
evaluates to 0 ; 
let l_sus_services = 0 
expression:(> l_opn_services, 0)
evaluates to t 
let l_new_cont_status = A 
expression:(in l_cont_status, "A", "D", "H", "P", "S")
evaluates to f 
let l_new_cont_status = NULL. 
expression:(= tran_flg, "Y")
evaluates to f 
expression:l_new_cont_status
evaluates to NULL. 
expression:l_return_status
evaluates to 100 
procedure sp_trigger_cont_stat returns 100 , NULL. , NULL. 

expression:(<procedure> sp_trigger_cont_stat, l_subscriber_code as p_contact_code, "N" as tran_flg)
evaluates to NULL. ; NULL. ; 100 ; 
let l_result = 100 
let l_new_cont_status = NULL. 
let l_msg = NULL. 
expression:(= tran_flg, "Y")
evaluates to f 
procedure sp_chg_cn_status returns 0 , NULL. 

expression:(<procedure> sp_chg_cn_status, p_sp_cn_ref as p_sp_cn_ref, l_new_status as p_sp_cn_status, p_event_ref as p_event_ref, "U" as p_sp_cn_stat_type, "N" as p_translate, p_spcnhist_to_dt as p_spcnhist_to_dt, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_result = 0 
let l_msg = NULL. 
expression:(<> l_srvctypecode, "ACCT")
evaluates to t 

execute function informix.sp_trigger_cont_stat[procid=9496] ( p_contact_code = UAT0341352 ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
let l_return_status = 100 
let l_cont_status = NULL. 
let l_new_cont_status = NULL. 

execute function informix.ss_sys_cnfg[procid=7787] ( p_cnfg_key = TRIGGER_CONT_STAT ,  p_alt_cnfg_key = NULL. ,  p_default_val = N ,  p_force_upper = Y ,  p_max_length = 1 ,  p_check_is_numeric = N ,  p_check_is_dt = N ,  trace_flg = N ,  resume_flg = N )
default value  p_alt_cnfg_key = NULL.
default value  p_default_val = NULL.
default value  p_force_upper = N
default value  p_max_length = 0
default value  p_check_is_numeric = N
default value  p_check_is_dt = N
default value  trace_flg = N
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

set lock mode to wait 30;
expression:(<procedure> upper, p_cnfg_key)
evaluates to TRIGGER_CONT_STAT                
let p_cnfg_key = TRIGGER_CONT_STAT                
let l_cnfg_val = NULL. 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_cnfg_key))
evaluates to Yes ; 
let l_cnfg_val = Yes 
expression:(and (null l_cnfg_val), (not-null p_alt_cnfg_key))
evaluates to f 
expression:(nvl l_cnfg_val, p_default_val)
evaluates to Yes 
let l_cnfg_val = Yes 
expression:(= p_force_upper, "Y")
evaluates to t 
expression:(<procedure> upper, l_cnfg_val)
evaluates to YES 
let l_cnfg_val = YES 
expression:(> p_max_length, 0)
evaluates to t 
expression:(substring l_cnfg_val, 1, p_max_length)
evaluates to Y 
let l_cnfg_val = Y 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(= p_check_is_dt, "Y")
evaluates to f 
expression:l_cnfg_val
evaluates to Y 
procedure ss_sys_cnfg returns 0 , Y , NULL. 

expression:(<procedure> ss_sys_cnfg, "TRIGGER_CONT_STAT" as p_cnfg_key, "N" as p_default_val, "Y" as p_force_upper, 1 as p_max_length)
evaluates to NULL. ; Y ; 0 ; 
let l_status = 0 
let l_trigger_on_stat = Y 
let l_msg = NULL. 
expression:(= l_trigger_on_stat, "N")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
expression:
  (select cont_status
    from contact
    where (= contact_code, p_contact_code))
evaluates to ACT ; 
let l_cont_status = ACT 
expression:
  (select (count *)
    from sp_connection
    where (and (= subscriber_code, p_contact_code), (<> srvctypecode, "ACCT")))
evaluates to 9 ; 
let l_total_services = 9 
expression:
  (select (count *)
    from sp_connection
    where (and (and (= subscriber_code, p_contact_code), (<> srvctypecode, "ACCT")), (= sys_status, "DIS")))
evaluates to 0 ; 
let l_dis_services = 0 
expression:
  (select (count *)
    from sp_connection
    where (and (and (= subscriber_code, p_contact_code), (<> srvctypecode, "ACCT")), (or (= sp_cn_status, "PDC"), (= sys_status, "DIS"))))
evaluates to 2 ; 
let l_pdc_services = 2 
expression:
  (select (count *)
    from sp_connection
    where (and (and (and (= subscriber_code, p_contact_code), (<> srvctypecode, "ACCT")), (in sys_status, "OPN", "IDS")), (in sp_cn_status, "OPN", "IDS")))
evaluates to 7 ; 
let l_opn_services = 7 
expression:
  (select (count *)
    from sp_connection
    where (and (and (= subscriber_code, p_contact_code), (<> srvctypecode, "ACCT")), (or (= sp_cn_status, "SUS"), (= sys_status, "DIS"))))
evaluates to 0 ; 
let l_sus_services = 0 
expression:(> l_opn_services, 0)
evaluates to t 
let l_new_cont_status = A 
expression:(in l_cont_status, "A", "D", "H", "P", "S")
evaluates to f 
let l_new_cont_status = NULL. 
expression:(= tran_flg, "Y")
evaluates to f 
expression:l_new_cont_status
evaluates to NULL. 
expression:l_return_status
evaluates to 100 
procedure sp_trigger_cont_stat returns 100 , NULL. , NULL. 

expression:(<procedure> sp_trigger_cont_stat, l_subscriber_code as p_contact_code, "N" as tran_flg)
evaluates to NULL. ; NULL. ; 100 ; 
let l_result = 100 
let l_new_cont_status = NULL. 
let l_msg = NULL. 
expression:(= tran_flg, "Y")
evaluates to f 
procedure sp_chg_cn_status returns 0 , NULL. 

expression:(<procedure> sp_chg_cn_status, p_sp_cn_ref as p_sp_cn_ref, l_sp_cn_status as p_sp_cn_status, p_event_ref as p_event_ref, p_mode as p_sp_cn_stat_type, p_spcnhist_to_dt as p_spcnhist_to_dt, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_return = 0 
let l_msg = NULL. 

execute function informix.sp_add_event_note[procid=1708] ( p_event_ref = 7159603 ,  p_note_text = NULL. ,  resume_flg = N ,  tran_flg = N )
default value  resume_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 
expression:(not-null p_note_text)
evaluates to f 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
procedure sp_add_event_note returns 0 , NULL. 

expression:(<procedure> sp_add_event_note, p_event_ref as p_event_ref, p_note_text as p_note_text, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_return = 0 
let l_msg = NULL. 

execute function informix.sp_add_event_note[procid=1708] ( p_event_ref = 7159603 ,  p_note_text = NULL. ,  resume_flg = N ,  tran_flg = N )
default value  resume_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 
expression:(not-null p_note_text)
evaluates to f 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
procedure sp_add_event_note returns 0 , NULL. 

expression:(<procedure> sp_add_event_note, p_event_ref as p_event_ref, p_note_text2 as p_note_text, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_return = 0 
let l_msg = NULL. 
expression:(not-null p_evnt_reas_code)
evaluates to f 
expression:(not-null p_priority_id)
evaluates to f 
expression:(not-null p_parent_event)
evaluates to f 
expression:(not-null p_evnt_oth_ref)
evaluates to f 
expression:(not-null p_bill_ref)
evaluates to f 
expression:(not-null p_bill_step_ref)
evaluates to f 
expression:(not-null p_attach_loc)
evaluates to f 
expression:(= p_alert, "Y")
evaluates to f 
expression:(not-null p_fin_ref)
evaluates to f 
let l_event_chg_ref = NULL. 
start select cursor.
(
  select event_chg_ref, chg_code
    from evnt_charge, sp_connection
    where (and (and (and (and (and (= evnt_charge.srvctypecode, sp_connection.srvctypecode), (= event_type, p_event_type)), (= event_code, p_event_code)), (= sp_connection.sp_cn_ref, p_sp_cn_ref)), (between p_created_tm, evnt_chg_wefr, evnt_chg_weto)), (not-null p_sp_cn_ref))
union 
  select event_chg_ref, chg_code
    from evnt_charge
    where (and (and (and (and (= event_type, p_event_type), (= event_code, p_event_code)), (= srvctypecode, "ALL")), (between p_created_tm, evnt_chg_wefr, evnt_chg_weto)), (null p_sp_cn_ref))
)
select cursor iteration.
end cursor
expression:(not-null l_event_chg_ref)
evaluates to f 
expression:(= p_event_triggers, "Y")
evaluates to t 

execute function informix.sp_trigger_event[procid=6257] ( p_event_ref = 7159603 ,  p_proc_na_events = Y ,  p_due_tm = NULL. ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_proc_na_events = N
default value  p_due_tm = NULL.
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
let l_insert_cnt = 0 
let l_event_type = NULL. 
expression:
  (select event_type, event_code
    from event
    where (= event_ref, p_event_ref))
evaluates to CE ; CM ; 
let l_event_type = CM 
let l_event_code = CE 
expression:(null l_event_type)
evaluates to f 
let l_sp_cn_ref = NULL. 
expression:
  (select (min sp_cn_ref), (count *)
    from evnt_sp_cn
    where (= event_ref, p_event_ref))
evaluates to 1 ; 239091 ; 
let l_sp_cn_ref = 239091 
let l_count = 1 
expression:(> l_count, 1)
evaluates to f 
let l_contact_code = NULL. 
expression:(= l_count, 0)
evaluates to f 
expression:(not-null l_sp_cn_ref)
evaluates to t 
expression:
  (select srvctypecode, subscriber_code
    from sp_connection
    where (= sp_cn_ref, l_sp_cn_ref))
evaluates to UAT0341352 ; PID  ; 
let l_srvctypecode = PID  
let l_contact_code = UAT0341352 
expression:(= p_proc_na_events, "Y")
evaluates to t 
let l_sched_stat_code = NA 
let l_due_tm = 2025-03-26 15:26:32.000 
expression:(not-null p_due_tm)
evaluates to f 
expression:(and (and (not-null l_sp_cn_ref), (= l_event_type, "CM")), (= l_event_code, "DR"))
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
start select cursor.
select trigger_type, trigger_code
  from evnt_trigger
  where (and (and (and (= event_type, l_event_type), (= event_code, l_event_code)), (= trigger_on_stat, l_sched_stat_code)), (or (= srvctypecode, "ALL"), (= srvctypecode, l_srvctypecode)))
select cursor iteration.
end cursor
expression:(= tran_flg, "Y")
evaluates to f 
expression:(= l_insert_cnt, 0)
evaluates to t 
procedure sp_trigger_event returns 100 , No events triggered 

expression:(<procedure> sp_trigger_event, p_event_ref as p_event_ref, "Y" as p_proc_na_events, p_trigger_due_tm as p_due_tm, "N" as tran_flg)
evaluates to No events triggered ; 100 ; 
let l_return = 100 
let l_msg = No events triggered 
expression:(and (= l_schedule, "Y"), (= p_event_triggers, "Y"))
evaluates to f 
expression:(= l_schedule, "Y")
evaluates to f 
expression:(and (= p_event_type, "AA"), (= p_event_code, "BR"))
evaluates to f 
expression:(and (not-null l_acct_void_event), (> (<procedure> length, l_acct_void_event), 6))
evaluates to f 
expression:(not-null p_sp_cn_ref)
evaluates to t 

execute function informix.ss_sys_cnfg[procid=7787] ( p_cnfg_key = LINK_ATTRIBUTES_TO_EVENT_CM_CE ,  p_alt_cnfg_key = NULL. ,  p_default_val = N ,  p_force_upper = Y ,  p_max_length = 1 ,  p_check_is_numeric = N ,  p_check_is_dt = N ,  trace_flg = N ,  resume_flg = N )
default value  p_alt_cnfg_key = NULL.
default value  p_default_val = NULL.
default value  p_force_upper = N
default value  p_max_length = 0
default value  p_check_is_numeric = N
default value  p_check_is_dt = N
default value  trace_flg = N
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

set lock mode to wait 30;
expression:(<procedure> upper, p_cnfg_key)
evaluates to LINK_ATTRIBUTES_TO_EVENT_CM_CE   
let p_cnfg_key = LINK_ATTRIBUTES_TO_EVENT_CM_CE   
let l_cnfg_val = NULL. 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_cnfg_key))
evaluates to NULL. ; 
let l_cnfg_val = NULL. 
expression:(and (null l_cnfg_val), (not-null p_alt_cnfg_key))
evaluates to f 
expression:(nvl l_cnfg_val, p_default_val)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_force_upper, "Y")
evaluates to t 
expression:(<procedure> upper, l_cnfg_val)
evaluates to N 
let l_cnfg_val = N 
expression:(> p_max_length, 0)
evaluates to t 
expression:(substring l_cnfg_val, 1, p_max_length)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(= p_check_is_dt, "Y")
evaluates to f 
expression:l_cnfg_val
evaluates to N 
procedure ss_sys_cnfg returns 0 , N , NULL. 

expression:(<procedure> ss_sys_cnfg, (|| (|| (|| "LINK_ATTRIBUTES_TO_EVENT_", l_event_type), "_"), l_event_code) as p_cnfg_key, "N" as p_default_val, 1 as p_max_length, "Y" as p_force_upper)
evaluates to NULL. ; N ; 0 ; 
let l_return = 0 
let l_link_attributes = N 
let l_msg = NULL. 
expression:(= l_link_attributes, "Y")
evaluates to f 
expression:(and (= l_schedule, "Y"), (= p_create_sms, "Y"))
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
expression:p_event_ref
evaluates to 7159603 
procedure sp_new_event returns 0 , 7159603 

expression:(<procedure> sp_new_event, 0 as p_event_ref, "CM" as p_event_type, "CE" as p_event_code, <USER> as p_created_by, l_sp_cn_ref as p_sp_cn_ref, p_actual_change_dt as p_created_tm, "Y" as p_translate, "B" as p_mode, "N" as tran_flg)
evaluates to 7159603 ; 0 ; 
let l_return = 0 
let l_event_ref = 7159603 
expression:(= l_return, 0)
evaluates to t 

execute function informix.ss_sms_alert_cnfg[procid=8089] ( p_sp_cn_ref = 239091 ,  resume_flg = N ,  trace_flg = N )
default value  resume_flg = N
default value  trace_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
let l_bus_unit_code = NULL. 
expression:
  (select contact.bus_unit_code, contact.firstname, contact.name, srvctype.srvctypenarr, sp_connection.srvctypecode
    from contact, sp_connection, srvctype
    where (and (and (= contact.contact_code, sp_connection.subscriber_code), (= srvctype.srvctypecode, sp_connection.srvctypecode)), (= sp_connection.sp_cn_ref, p_sp_cn_ref)))
evaluates to PID  ; RPP ; TradeTest2TradeTest2TradeTest2TradeTest2TradeTest2TradeTest20676767              ; NULL. ; RP ; 
let l_bus_unit_code = RP 
let l_firstname = NULL. 
let l_name = TradeTest2TradeTest2TradeTest2TradeTest2TradeTest2TradeTest20676767              
let l_srvctypenarr = RPP 
let l_srvctypecode = PID  
expression:(null l_firstname)
evaluates to t 
expression:l_name
evaluates to TradeTest2TradeTest2TradeTest2TradeTest2TradeTest2TradeTest20676767              
let l_firstname = TradeTest2TradeTest2TradeTest2TradeTest2TradeTest2TradeTest20676767              
expression:(|| "_", TRIM ( BOTH ' ' FROM l_bus_unit_code))
evaluates to _RP 
let l_incl_bus_unit = _RP 
expression:(|| "SRVC_ACTV_SMS_ENABLE", TRIM ( BOTH ' ' FROM l_incl_bus_unit))
evaluates to SRVC_ACTV_SMS_ENABLE_RP 
let l_cnfg_key = SRVC_ACTV_SMS_ENABLE_RP 

execute function informix.ss_sys_cnfg[procid=7787] ( p_cnfg_key = SRVC_ACTV_SMS_ENABLE_RP ,  p_alt_cnfg_key = SRVC_ACTV_SMS_ENABLE ,  p_default_val = N ,  p_force_upper = N ,  p_max_length = 0 ,  p_check_is_numeric = N ,  p_check_is_dt = N ,  trace_flg = N ,  resume_flg = N )
default value  p_alt_cnfg_key = NULL.
default value  p_default_val = NULL.
default value  p_force_upper = N
default value  p_max_length = 0
default value  p_check_is_numeric = N
default value  p_check_is_dt = N
default value  trace_flg = N
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

set lock mode to wait 30;
expression:(<procedure> upper, p_cnfg_key)
evaluates to SRVC_ACTV_SMS_ENABLE_RP          
let p_cnfg_key = SRVC_ACTV_SMS_ENABLE_RP          
let l_cnfg_val = NULL. 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_cnfg_key))
evaluates to NULL. ; 
let l_cnfg_val = NULL. 
expression:(and (null l_cnfg_val), (not-null p_alt_cnfg_key))
evaluates to t 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_alt_cnfg_key))
evaluates to NULL. ; 
let l_cnfg_val = NULL. 
expression:(nvl l_cnfg_val, p_default_val)
evaluates to N 
let l_cnfg_val = N 
expression:(= p_force_upper, "Y")
evaluates to f 
expression:(> p_max_length, 0)
evaluates to f 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(= p_check_is_dt, "Y")
evaluates to f 
expression:l_cnfg_val
evaluates to N 
procedure ss_sys_cnfg returns 0 , N , NULL. 

expression:(<procedure> ss_sys_cnfg, TRIM ( BOTH ' ' FROM l_cnfg_key) as p_cnfg_key, "SRVC_ACTV_SMS_ENABLE" as p_alt_cnfg_key, "N" as p_default_val)
evaluates to NULL. ; N ; 0 ; 
let l_return = 0 
let l_sms_alert_enabled = N 
let l_msg = NULL. 
expression:(= l_srvctypecode, "ACCT")
evaluates to f 
expression:(|| "SRVC_ACTV_SMS_MESSAGE", TRIM ( BOTH ' ' FROM l_incl_bus_unit))
evaluates to SRVC_ACTV_SMS_MESSAGE_RP 
let l_cnfg_key = SRVC_ACTV_SMS_MESSAGE_RP 

execute function informix.ss_sys_cnfg[procid=7787] ( p_cnfg_key = SRVC_ACTV_SMS_MESSAGE_RP ,  p_alt_cnfg_key = SRVC_ACTV_SMS_MESSAGE ,  p_default_val = n/a ,  p_force_upper = N ,  p_max_length = 0 ,  p_check_is_numeric = N ,  p_check_is_dt = N ,  trace_flg = N ,  resume_flg = N )
default value  p_alt_cnfg_key = NULL.
default value  p_default_val = NULL.
default value  p_force_upper = N
default value  p_max_length = 0
default value  p_check_is_numeric = N
default value  p_check_is_dt = N
default value  trace_flg = N
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

set lock mode to wait 30;
expression:(<procedure> upper, p_cnfg_key)
evaluates to SRVC_ACTV_SMS_MESSAGE_RP         
let p_cnfg_key = SRVC_ACTV_SMS_MESSAGE_RP         
let l_cnfg_val = NULL. 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_cnfg_key))
evaluates to NULL. ; 
let l_cnfg_val = NULL. 
expression:(and (null l_cnfg_val), (not-null p_alt_cnfg_key))
evaluates to t 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_alt_cnfg_key))
evaluates to NULL. ; 
let l_cnfg_val = NULL. 
expression:(nvl l_cnfg_val, p_default_val)
evaluates to n/a 
let l_cnfg_val = n/a 
expression:(= p_force_upper, "Y")
evaluates to f 
expression:(> p_max_length, 0)
evaluates to f 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(= p_check_is_dt, "Y")
evaluates to f 
expression:l_cnfg_val
evaluates to n/a 
procedure ss_sys_cnfg returns 0 , n/a , NULL. 

expression:(<procedure> ss_sys_cnfg, TRIM ( BOTH ' ' FROM l_cnfg_key) as p_cnfg_key, "SRVC_ACTV_SMS_MESSAGE" as p_alt_cnfg_key, "n/a" as p_default_val)
evaluates to NULL. ; n/a ; 0 ; 
let l_return = 0 
let l_narrative = n/a 
let l_msg = NULL. 
expression:(|| "SRVC_ACTV_SMS_EVENTCODE", TRIM ( BOTH ' ' FROM l_incl_bus_unit))
evaluates to SRVC_ACTV_SMS_EVENTCODE_RP 
let l_cnfg_key = SRVC_ACTV_SMS_EVENTCODE_RP 

execute function informix.ss_sys_cnfg[procid=7787] ( p_cnfg_key = SRVC_ACTV_SMS_EVENTCODE_RP ,  p_alt_cnfg_key = SRVC_ACTV_SMS_EVENTCODE ,  p_default_val = TX ,  p_force_upper = N ,  p_max_length = 0 ,  p_check_is_numeric = N ,  p_check_is_dt = N ,  trace_flg = N ,  resume_flg = N )
default value  p_alt_cnfg_key = NULL.
default value  p_default_val = NULL.
default value  p_force_upper = N
default value  p_max_length = 0
default value  p_check_is_numeric = N
default value  p_check_is_dt = N
default value  trace_flg = N
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

set lock mode to wait 30;
expression:(<procedure> upper, p_cnfg_key)
evaluates to SRVC_ACTV_SMS_EVENTCODE_RP       
let p_cnfg_key = SRVC_ACTV_SMS_EVENTCODE_RP       
let l_cnfg_val = NULL. 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_cnfg_key))
evaluates to NULL. ; 
let l_cnfg_val = NULL. 
expression:(and (null l_cnfg_val), (not-null p_alt_cnfg_key))
evaluates to t 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_alt_cnfg_key))
evaluates to NULL. ; 
let l_cnfg_val = NULL. 
expression:(nvl l_cnfg_val, p_default_val)
evaluates to TX 
let l_cnfg_val = TX 
expression:(= p_force_upper, "Y")
evaluates to f 
expression:(> p_max_length, 0)
evaluates to f 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(= p_check_is_dt, "Y")
evaluates to f 
expression:l_cnfg_val
evaluates to TX 
procedure ss_sys_cnfg returns 0 , TX , NULL. 

expression:(<procedure> ss_sys_cnfg, TRIM ( BOTH ' ' FROM l_cnfg_key) as p_cnfg_key, "SRVC_ACTV_SMS_EVENTCODE" as p_alt_cnfg_key, "TX" as p_default_val)
evaluates to NULL. ; TX ; 0 ; 
let l_return = 0 
let l_event_code = TX 
let l_msg = NULL. 
expression:(|| "SRVC_ACTV_SMS_EVENTTYPE", TRIM ( BOTH ' ' FROM l_incl_bus_unit))
evaluates to SRVC_ACTV_SMS_EVENTTYPE_RP 
let l_cnfg_key = SRVC_ACTV_SMS_EVENTTYPE_RP 

execute function informix.ss_sys_cnfg[procid=7787] ( p_cnfg_key = SRVC_ACTV_SMS_EVENTTYPE_RP ,  p_alt_cnfg_key = SRVC_ACTV_SMS_EVENTTYPE ,  p_default_val = AA ,  p_force_upper = N ,  p_max_length = 0 ,  p_check_is_numeric = N ,  p_check_is_dt = N ,  trace_flg = N ,  resume_flg = N )
default value  p_alt_cnfg_key = NULL.
default value  p_default_val = NULL.
default value  p_force_upper = N
default value  p_max_length = 0
default value  p_check_is_numeric = N
default value  p_check_is_dt = N
default value  trace_flg = N
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

set lock mode to wait 30;
expression:(<procedure> upper, p_cnfg_key)
evaluates to SRVC_ACTV_SMS_EVENTTYPE_RP       
let p_cnfg_key = SRVC_ACTV_SMS_EVENTTYPE_RP       
let l_cnfg_val = NULL. 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_cnfg_key))
evaluates to NULL. ; 
let l_cnfg_val = NULL. 
expression:(and (null l_cnfg_val), (not-null p_alt_cnfg_key))
evaluates to t 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_alt_cnfg_key))
evaluates to NULL. ; 
let l_cnfg_val = NULL. 
expression:(nvl l_cnfg_val, p_default_val)
evaluates to AA 
let l_cnfg_val = AA 
expression:(= p_force_upper, "Y")
evaluates to f 
expression:(> p_max_length, 0)
evaluates to f 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(= p_check_is_dt, "Y")
evaluates to f 
expression:l_cnfg_val
evaluates to AA 
procedure ss_sys_cnfg returns 0 , AA , NULL. 

expression:(<procedure> ss_sys_cnfg, TRIM ( BOTH ' ' FROM l_cnfg_key) as p_cnfg_key, "SRVC_ACTV_SMS_EVENTTYPE" as p_alt_cnfg_key, "AA" as p_default_val)
evaluates to NULL. ; AA ; 0 ; 
let l_return = 0 
let l_event_type = AA 
let l_msg = NULL. 
expression:(<procedure> replace, l_narrative, "<<FIRST_NAME>>", TRIM ( BOTH ' ' FROM l_firstname))
evaluates to n/a 
let l_narrative = n/a 
expression:(<procedure> replace, l_narrative, "<<SRVC_TYPE>>", TRIM ( BOTH ' ' FROM l_srvctypenarr))
evaluates to n/a 
let l_narrative = n/a 
expression:l_event_type
evaluates to AA 
expression:l_event_code
evaluates to TX 
expression:l_narrative
evaluates to n/a 
expression:l_sms_alert_enabled
evaluates to N 
procedure ss_sms_alert_cnfg returns 0 , N , n/a , TX , AA , NULL. 

expression:(<procedure> ss_sms_alert_cnfg, l_sp_cn_ref as p_sp_cn_ref)
evaluates to NULL. ; AA ; TX ; n/a ; N ; 0 ; 
let l_return = 0 
let l_sms_alert_enabled = N 
let l_narrative = n/a 
let l_event_code = TX 
let l_event_type = AA 
let l_msg = NULL. 
expression:(= l_sms_alert_enabled, "Y")
evaluates to f 

execute function informix.sp_sp_cn_hist[procid=3326] ( p_sp_cn_ref = 239091 ,  p_event_ref = 7159603 ,  p_to_dt = NULL. ,  resume_flg = N ,  tran_flg = N )
default value  p_event_ref = NULL.
default value  p_to_dt = NULL.
default value  resume_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 
let l_phone_num = NULL. 
expression:(nvl p_to_dt, (- current year to fraction(3), (units 1, 2474)))
evaluates to 2025-03-26 15:26:31.000 
let p_to_dt = 2025-03-26 15:26:31.000 
let l_sp_cn_history_id = NULL. 
expression:
  (select phone_num, sp_cn_narr, srvctypecode, sp_connected, sp_disconnected, sp_cn_status, sys_status, sp_enq_passwd, sp_mailbox_num, updated_by
    from sp_connection
    where (= sp_cn_ref, p_sp_cn_ref))
evaluates to webuser            ; NULL. ; test@333                         ; OPN ; OPN ; 2025-03-26 02:03:41 ; 2025-03-26 02:03:41 ; PID  ; Test New Service Post Ar 1 ; PD161470                                                         ; 
let l_phone_num = PD161470                                                         
let l_sp_cn_narr = Test New Service Post Ar 1 
let l_srvctypecode = PID  
let l_sp_connected = 2025-03-26 02:03:41 
let l_sp_disconnected = 2025-03-26 02:03:41 
let l_sp_cn_status = OPN 
let l_sys_status = OPN 
let l_sp_enq_passwd = test@333                         
let l_sp_mailbox_num = NULL. 
let l_updated_by = webuser            
expression:(null l_phone_num)
evaluates to f 
expression:
  (select sp_cn_history_id
    from sp_cn_history
    where (and (= sp_cn_ref, p_sp_cn_ref), (between to_dt, (- p_to_dt, (units 3, 2474)), p_to_dt)))
evaluates to 477736 ; 
let l_sp_cn_history_id = 477736 
expression:(null l_sp_cn_history_id)
evaluates to f 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
expression:l_sp_cn_history_id
evaluates to 477736 
procedure sp_sp_cn_hist returns 0 , 477736 , NULL. 

expression:(<procedure> sp_sp_cn_hist, l_sp_cn_ref as p_sp_cn_ref, l_event_ref as p_event_ref, "N" as tran_flg)
evaluates to NULL. ; 477736 ; 0 ; 
let l_return = 0 
let l_sp_cn_history_id = 477736 
let l_msg = NULL. 

update sp_connection set
    (sp_connected) = (p_actual_change_dt),
    (sp_disconnected) = ("9999-01-01 00:00:00")
  where (= sp_cn_ref, l_sp_cn_ref);

before actions:

end before actions

for each row actions: 

execute function informix.get_upd_vals[procid=1412] ()
set_state: owner is informix - utype = 'D'procedure get_upd_vals returns webuser                          , 2025-03-26 15:26:32.000 


end for each row actions

after actions:

end after actions
expression:(<> (dbinfo-sqlca.sqlerrd2 ), 1)
evaluates to f 
expression:(not-null p_source)
evaluates to f 

execute function informix.ss_sys_cnfg[procid=7787] ( p_cnfg_key = ADJUST_CYCLE_ON_FIRST_CONNECTION ,  p_alt_cnfg_key = NULL. ,  p_default_val = N ,  p_force_upper = Y ,  p_max_length = 1 ,  p_check_is_numeric = N ,  p_check_is_dt = N ,  trace_flg = N ,  resume_flg = N )
default value  p_alt_cnfg_key = NULL.
default value  p_default_val = NULL.
default value  p_force_upper = N
default value  p_max_length = 0
default value  p_check_is_numeric = N
default value  p_check_is_dt = N
default value  trace_flg = N
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

set lock mode to wait 30;
expression:(<procedure> upper, p_cnfg_key)
evaluates to ADJUST_CYCLE_ON_FIRST_CONNECTION 
let p_cnfg_key = ADJUST_CYCLE_ON_FIRST_CONNECTION 
let l_cnfg_val = NULL. 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_cnfg_key))
evaluates to Y ; 
let l_cnfg_val = Y 
expression:(and (null l_cnfg_val), (not-null p_alt_cnfg_key))
evaluates to f 
expression:(nvl l_cnfg_val, p_default_val)
evaluates to Y 
let l_cnfg_val = Y 
expression:(= p_force_upper, "Y")
evaluates to t 
expression:(<procedure> upper, l_cnfg_val)
evaluates to Y 
let l_cnfg_val = Y 
expression:(> p_max_length, 0)
evaluates to t 
expression:(substring l_cnfg_val, 1, p_max_length)
evaluates to Y 
let l_cnfg_val = Y 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(= p_check_is_dt, "Y")
evaluates to f 
expression:l_cnfg_val
evaluates to Y 
procedure ss_sys_cnfg returns 0 , Y , NULL. 

expression:(<procedure> ss_sys_cnfg, "ADJUST_CYCLE_ON_FIRST_CONNECTION" as p_cnfg_key, "N" as p_default_val, "Y" as p_force_upper, 1 as p_max_length)
evaluates to NULL. ; Y ; 0 ; 
let l_return = 0 
let l_adjust_bill_cycle = Y 
let l_msg = NULL. 
expression:(= l_adjust_bill_cycle, "Y")
evaluates to t 

execute function informix.ss_sys_cnfg[procid=7787] ( p_cnfg_key = ADJUST_CYCLE_OFC_AVOID_ACCT ,  p_alt_cnfg_key = NULL. ,  p_default_val = N ,  p_force_upper = Y ,  p_max_length = 1 ,  p_check_is_numeric = N ,  p_check_is_dt = N ,  trace_flg = N ,  resume_flg = N )
default value  p_alt_cnfg_key = NULL.
default value  p_default_val = NULL.
default value  p_force_upper = N
default value  p_max_length = 0
default value  p_check_is_numeric = N
default value  p_check_is_dt = N
default value  trace_flg = N
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

set lock mode to wait 30;
expression:(<procedure> upper, p_cnfg_key)
evaluates to ADJUST_CYCLE_OFC_AVOID_ACCT      
let p_cnfg_key = ADJUST_CYCLE_OFC_AVOID_ACCT      
let l_cnfg_val = NULL. 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_cnfg_key))
evaluates to Y ; 
let l_cnfg_val = Y 
expression:(and (null l_cnfg_val), (not-null p_alt_cnfg_key))
evaluates to f 
expression:(nvl l_cnfg_val, p_default_val)
evaluates to Y 
let l_cnfg_val = Y 
expression:(= p_force_upper, "Y")
evaluates to t 
expression:(<procedure> upper, l_cnfg_val)
evaluates to Y 
let l_cnfg_val = Y 
expression:(> p_max_length, 0)
evaluates to t 
expression:(substring l_cnfg_val, 1, p_max_length)
evaluates to Y 
let l_cnfg_val = Y 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(= p_check_is_dt, "Y")
evaluates to f 
expression:l_cnfg_val
evaluates to Y 
procedure ss_sys_cnfg returns 0 , Y , NULL. 

expression:(<procedure> ss_sys_cnfg, "ADJUST_CYCLE_OFC_AVOID_ACCT" as p_cnfg_key, "N" as p_default_val, "Y" as p_force_upper, 1 as p_max_length)
evaluates to NULL. ; Y ; 0 ; 
let l_return = 0 
let l_avoid_acct = Y 
let l_msg = NULL. 
expression:
  (select (count *)
    from sp_connection
    where (and (and (= subscriber_code, l_subscriber_code), (or (and (= l_avoid_acct, "Y"), (not-in srvctypecode, "ACCT")), (= l_avoid_acct, "N"))), (in sys_status, "OPN", "DIS")))
evaluates to 9 ; 
let l_count = 9 
expression:(= l_count, 1)
evaluates to f 

execute function informix.sp_backdate_conn[procid=7089] ( p_sp_cn_ref = 239091 ,  p_sp_plan_ref = 385186 ,  p_back_dt = 2025-03-26 02:03:41 ,  p_sp_connected = 2025-03-26 02:03:41 ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_sp_plan_ref = NULL.
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
let l_debtor_code = NULL. 
expression:
  (select subscriber_code, srvctypecode
    from sp_connection
    where (= sp_cn_ref, p_sp_cn_ref))
evaluates to PID  ; UAT0341352 ; 
let l_debtor_code = UAT0341352 
let l_srvctypecode = PID  
expression:(null l_debtor_code)
evaluates to f 
expression:
  (select nt_cn_ref
    from sp_connection
    where (= sp_cn_ref, p_sp_cn_ref))
evaluates to 168093 ; 
let l_nt_cn_ref = 168093 
expression:(not-null l_nt_cn_ref)
evaluates to t 

execute function informix.sp_upd_nt_cn[procid=1361] ( p_nt_cn_ref = 168093 ,  p_new_date = 2025-03-26 02:03:41 ,  p_sp_cn_ref = 239091 ,  resume_flg = N ,  tran_flg = N )
default value  p_sp_cn_ref = NULL.
default value  resume_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 
expression:(null p_nt_cn_ref)
evaluates to f 
expression:(null p_new_date)
evaluates to f 
let l_nt_connected = NULL. 
expression:
  (select nt_connected
    from nt_connection
    where (= nt_cn_ref, p_nt_cn_ref))
evaluates to 2025-03-26 02:03:41 ; 
let l_nt_connected = 2025-03-26 02:03:41 
expression:(null l_nt_connected)
evaluates to f 
let l_nt_cn_changed = N 
expression:(or (< p_new_date, l_nt_connected), (and (> p_new_date, l_nt_connected), (null p_sp_cn_ref)))
evaluates to f 
expression:(= l_nt_cn_changed, "Y")
evaluates to f 

execute function informix.sp_backdt_sim_usg[procid=1328] ( p_nt_cn_ref = 168093 ,  p_new_nt_connected = 2025-03-26 02:03:41 ,  p_old_nt_connected = 2025-03-26 02:03:41 ,  p_sp_cn_ref = 239091 ,  resume_flg = N ,  tran_flg = N )
default value  p_sp_cn_ref = NULL.
default value  resume_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= tran_flg, "Y")
evaluates to f 
let l_back_dating = N 
let l_forward_dating = N 
expression:p_old_nt_connected
evaluates to 2025-03-26 02:03:41 
let l_nt_connected = 2025-03-26 02:03:41 
expression:(< p_new_nt_connected, p_old_nt_connected)
evaluates to f 
expression:(and (> p_new_nt_connected, p_old_nt_connected), (null p_sp_cn_ref))
evaluates to f 
expression:(not-null p_sp_cn_ref)
evaluates to t 
let l_old_link_start = NULL. 
expression:
  (select (min sim_link_start)
    from sim_usage
    where (and (= sim_usage.sp_cn_ref, p_sp_cn_ref), (in sim_status, "L", "E")))
evaluates to NULL. ; 
let l_old_link_start = NULL. 
expression:(< p_new_nt_connected, l_old_link_start)
evaluates to NULL. 
expression:(> p_new_nt_connected, l_old_link_start)
evaluates to NULL. 
let l_first = Y 
expression:(or (= l_back_dating, "Y"), (= l_forward_dating, "Y"))
evaluates to f 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
procedure sp_backdt_sim_usg returns 0 

expression:(<procedure> sp_backdt_sim_usg, p_nt_cn_ref as p_nt_cn_ref, p_new_date as p_new_nt_connected, l_nt_connected as p_old_nt_connected, p_sp_cn_ref as p_sp_cn_ref, "N" as tran_flg)
evaluates to 0 
let l_return = 0 
expression:(= l_nt_cn_changed, "Y")
evaluates to f 
expression:(or (= tran_flg, "Y"), (= tran_flg, "C"))
evaluates to f 
procedure sp_upd_nt_cn returns 0 

expression:(<procedure> sp_upd_nt_cn, l_nt_cn_ref as p_nt_cn_ref, p_back_dt as p_new_date, p_sp_cn_ref as p_sp_cn_ref, "N" as tran_flg)
evaluates to 0 
let l_return = 0 
start select cursor.
select spcncontract_ref, term, term_units, start_date
  from sp_cn_contract, contract
  where (and (= sp_cn_contract.contract_code, contract.contract_code), (= sp_cn_ref, p_sp_cn_ref))
  order by start_dateasc
select cursor iteration.
select cursor returns 239089 , 0 , M , 2025-03-26 02:03:41 
expression:(<> l_start_date, p_sp_connected)
evaluates to f 
expression:
  (select (count *)
    from sp_contr_ext
    where (= spcncontract_ref, l_spcncontract_ref))
evaluates to 0 ; 
let l_count = 0 
expression:(> l_count, 0)
evaluates to f 

execute function informix.ss_add_period[procid=3522] ( p_start = 2025-03-26 02:03:41 ,  p_term = 0 ,  p_units = M )
default value  p_units = D
set_state: owner is informix - utype = 'D'expression:(not (in p_units, "D", "W", "M", "Y"))
evaluates to f 
expression:(= p_units, "Y")
evaluates to f 
expression:(= p_units, "W")
evaluates to f 
expression:(= p_units, "D")
evaluates to f 

execute function informix.ss_add_months[procid=3689] ( p_dt = 2025-03-26 02:03:41 ,  p_months = 0 ,  p_check_eom = N ,  resume_flg = N )
default value  p_dt = NULL.
default value  p_months = NULL.
default value  p_check_eom = N
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(or (null p_dt), (null p_months))
evaluates to f 
expression:(and (= p_check_eom, "Y"), (<> (month p_dt), (month (+ p_dt, (units 1, 2474)))))
evaluates to f 
let l_is_eom = N 
let l_adj_days = 0 
expression:(= 1, 1)
evaluates to t 
expression:(> (day p_dt), 28)
evaluates to f 
expression:(+ p_dt, (units p_months, 2338))
evaluates to 2025-03-26 02:03:41 
let l_calc_dt = 2025-03-26 02:03:41 
expression:(= l_is_eom, "Y")
evaluates to f 
expression:l_calc_dt
evaluates to 2025-03-26 02:03:41 
procedure ss_add_months returns 0 , 2025-03-26 02:03:41 , NULL. 

expression:(<procedure> ss_add_months, p_start as p_dt, p_term as p_months)
evaluates to NULL. ; 2025-03-26 02:03:41 ; 0 ; 
let l_return = 0 
let l_date = 2025-03-26 02:03:41 
let l_msg = NULL. 
expression:l_date
evaluates to 2025-03-26 02:03:41 
procedure ss_add_period returns 2025-03-26 02:03:41 

expression:(<procedure> ss_add_period, p_back_dt as p_start, l_term as p_term, l_term_units as p_units)
evaluates to 2025-03-26 02:03:41 
let l_end_date = 2025-03-26 02:03:41 
expression:(<> l_term, 0)
evaluates to f 

update sp_cn_contract set
    (start_date) = (p_back_dt),
    (end_date) = (l_end_date)
  where (= spcncontract_ref, l_spcncontract_ref);

before actions:

end before actions

for each row actions: 

execute function informix.get_upd_vals[procid=1412] ()
set_state: owner is informix - utype = 'D'procedure get_upd_vals returns webuser                          , 2025-03-26 15:26:32.000 


end for each row actions

after actions:

end after actions
end cursor
start select cursor.
select sp_plan_ref, sp_plan_start
  from sp_cn_plan
  where (and (and (and (and (= sp_cn_ref, p_sp_cn_ref), (= sp_plan_start, sp_plan_stop)), (= sp_plan_start, p_sp_connected)), (> sp_plan_start, current year to fraction(3))), (null sched_ref))
  order by sp_plan_start
select cursor iteration.
end cursor
let l_found = N 
expression:(<> l_srvctypecode, "ACCT")
evaluates to t 
start select cursor.
select acc_pay_method.acc_pay_meth_ref, pm_usage_ref, pm_usagewefr
  from acc_pay_method, pay_meth_usage
  where (and (and (= acc_pay_method.acc_pay_meth_ref, pay_meth_usage.acc_pay_meth_ref), (= debtor_code, l_debtor_code)), (null sp_cn_ref))
  order by pm_usagewefr
select cursor iteration.
select cursor returns 750255 , 308599 , 2025-03-24 00:00:00 
expression:(> l_pm_usagewefr, p_back_dt)
evaluates to f 
start select cursor.
select acc_pay_stat_ref, acc_pay_stat_wef
  from acc_pay_status
  where (= acc_pay_meth_ref, l_acc_pay_meth_ref)
  order by acc_pay_stat_wef
select cursor iteration.
select cursor returns 738694 , 2025-03-24 00:00:00 
expression:(> l_acc_pay_stat_wef, p_back_dt)
evaluates to f 
end cursor
let l_found = Y 
end cursor
expression:(= l_found, "N")
evaluates to f 
let l_pm_usage_ref = NULL. 
expression:
  (select pm_usage_ref
    from pay_meth_usage
    where (and (and (= sp_cn_ref, p_sp_cn_ref), (<= pm_usagewefr, p_sp_connected)), (>= pm_usageweto, p_sp_connected)))
evaluates to NULL. ; 
let l_pm_usage_ref = NULL. 
expression:(not-null l_pm_usage_ref)
evaluates to f 
start select cursor.
select attribref, attribweto
  from attrib
  where (and (= key_value, p_sp_cn_ref), (= attribwefr, p_sp_connected))
select cursor iteration.
end cursor
expression:(= tran_flg, "Y")
evaluates to f 
procedure sp_backdate_conn returns 0 , NULL. 

expression:(<procedure> sp_backdate_conn, l_sp_cn_ref as p_sp_cn_ref, l_sp_plan_ref as p_sp_plan_ref, p_actual_change_dt as p_back_dt, l_sp_connected as p_sp_connected, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_return = 0 
let l_msg = NULL. 

execute function informix.sp_set_package[procid=6961] ( p_sp_plan_ref = 385186 ,  p_actual_change_dt = 2025-03-26 02:03:41 ,  p_plan_code = NULL. ,  p_process_sae = X ,  p_new_connection = Y ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_actual_change_dt = 2025-03-26 15:26:32
default value  p_plan_code = NULL.
default value  p_process_sae = X
default value  p_new_connection = N
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 

execute function informix.ss_flex_code[procid=1382] ( p_sys_table = charge_code ,  p_sys_hard_group = LIN ,  p_sys_hard_code = LR ,  p_multiple_rows = N ,  p_msg = No charge code defined for line rental ,  resume_flg = Z )
default value  p_multiple_rows = N
default value  p_msg = NULL.
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(not-in resume_flg, "Y", "N", "Z")
evaluates to f 
let l_found = N 
let l_tmp_key1 = NULL. 
expression:(not-null p_msg)
evaluates to t 
expression:p_msg
evaluates to No charge code defined for line rental 
let l_msg = No charge code defined for line rental 
start select cursor.
select flex_key1, flex_key2
  from sys_code
  where (and (and (= sys_table, p_sys_table), (or (= sys_hard_group, p_sys_hard_group), (null p_sys_hard_group))), (or (= sys_hard_code, p_sys_hard_code), (null p_sys_hard_code)))
  order by flex_key2
select cursor iteration.
select cursor returns LR , LR 
expression:(= l_found, "N")
evaluates to t 
expression:l_flex_key1
evaluates to LR 
let l_tmp_key1 = LR 
expression:l_flex_key2
evaluates to LR 
let l_tmp_key2 = LR 
let l_found = Y 
select cursor iteration.
end cursor
expression:(not-null l_tmp_key1)
evaluates to t 
expression:l_tmp_key2
evaluates to LR 
expression:l_tmp_key1
evaluates to LR 
procedure ss_flex_code returns 0 , LR , LR 

expression:(<procedure> ss_flex_code, "charge_code" as p_sys_table, "LIN" as p_sys_hard_group, "LR" as p_sys_hard_code, "No charge code defined for line rental" as p_msg, "Z" as resume_flg)
evaluates to LR                               ; LR                               ; 0 ; 
let l_return = 0 
let l_line_rent_code = LR                               
let l_flex_key2 = LR                               
let l_sp_cn_ref = NULL. 
expression:
  (select subscriber_code, sp_cn_plan.sp_cn_ref, sp_cn_plan.pkg_code, sp_cn_plan.option, sp_plan_start, sp_plan_stop, sp_cn_plan.sched_ref, sp_cn_plan.sched_flags, sp_connected, package.packtypecd, packtypedflt, pkg_narr, sched_stat_code
    from sp_cn_plan, sp_connection, package, packtype, outer(schedule)
    where (and (and (and (and (= sp_cn_plan.sp_cn_ref, sp_connection.sp_cn_ref), (= sp_cn_plan.pkg_code, package.pkg_code)), (= package.packtypecd, packtype.packtypecd)), (= sp_cn_plan.sched_ref, schedule.event_ref)), (= sp_plan_ref, p_sp_plan_ref)))
evaluates to NULL. ; Short Form ING ; Y ; VR ; 2025-03-26 02:03:41 ; NYP ; NULL. ; 2025-03-26 02:03:41 ; 2025-03-26 02:03:41 ; 1 ; 4401 ; 239091 ; UAT0341352 ; 
let l_subscriber_code = UAT0341352 
let l_sp_cn_ref = 239091 
let l_pkg_code = 4401 
let l_option = 1 
let l_sp_plan_start = 2025-03-26 02:03:41 
let l_sp_plan_stop = 2025-03-26 02:03:41 
let l_sched_ref = NULL. 
let l_sched_flags = NYP 
let l_sp_connected = 2025-03-26 02:03:41 
let l_packtypecd = VR 
let l_packtypedflt = Y 
let l_pkg_narr = Short Form ING 
let l_sched_stat_code = NULL. 
expression:(null l_sp_cn_ref)
evaluates to f 
expression:(and (null l_sched_stat_code), (<> l_sp_plan_start, l_sp_plan_stop))
evaluates to f 
expression:(not-in l_sched_stat_code, "O", "R")
evaluates to NULL. 
expression:
  (select sys_status
    from sp_connection
    where (= sp_cn_ref, l_sp_cn_ref))
evaluates to OPN ; 
let l_sys_status = OPN 
expression:(= l_sys_status, "IDS")
evaluates to f 
expression:(<> l_sys_status, "OPN")
evaluates to f 
expression:(substring l_sched_flags, 1, 1)
evaluates to N 
let l_reprocess_calls = N 
expression:(substring l_sched_flags, 2, 1)
evaluates to Y 
let l_apply_one_offs = Y 
expression:(= p_process_sae, "X")
evaluates to t 
expression:(substring l_sched_flags, 3, 1)
evaluates to P 
let l_process_sae = P 

execute function informix.ss_sched_disc_date[procid=5687] ( p_sp_cn_ref = 239091 ,  trace_flg = N ,  resume_flg = N )
default value  trace_flg = N
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

execute function informix.ss_flex_code[procid=1382] ( p_sys_table = evnt_code ,  p_sys_hard_group = CM ,  p_sys_hard_code = DR ,  p_multiple_rows = N ,  p_msg = No disconnection request event code defined. ,  resume_flg = Z )
default value  p_multiple_rows = N
default value  p_msg = NULL.
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(not-in resume_flg, "Y", "N", "Z")
evaluates to f 
let l_found = N 
let l_tmp_key1 = NULL. 
expression:(not-null p_msg)
evaluates to t 
expression:p_msg
evaluates to No disconnection request event code defined. 
let l_msg = No disconnection request event code defined. 
start select cursor.
select flex_key1, flex_key2
  from sys_code
  where (and (and (= sys_table, p_sys_table), (or (= sys_hard_group, p_sys_hard_group), (null p_sys_hard_group))), (or (= sys_hard_code, p_sys_hard_code), (null p_sys_hard_code)))
  order by flex_key2
select cursor iteration.
select cursor returns CM , DR 
expression:(= l_found, "N")
evaluates to t 
expression:l_flex_key1
evaluates to CM 
let l_tmp_key1 = CM 
expression:l_flex_key2
evaluates to DR 
let l_tmp_key2 = DR 
let l_found = Y 
select cursor iteration.
end cursor
expression:(not-null l_tmp_key1)
evaluates to t 
expression:l_tmp_key2
evaluates to DR 
expression:l_tmp_key1
evaluates to CM 
procedure ss_flex_code returns 0 , CM , DR 

expression:(<procedure> ss_flex_code, "evnt_code" as p_sys_table, "CM" as p_sys_hard_group, "DR" as p_sys_hard_code, "No disconnection request event code defined." as p_msg, "Z" as resume_flg)
evaluates to DR                               ; CM                               ; 0 ; 
let l_return = 0 
let l_event_type = CM                               
let l_event_code = DR                               

execute function informix.ss_flex_code[procid=1382] ( p_sys_table = charge_code ,  p_sys_hard_group = DP ,  p_sys_hard_code = DP ,  p_multiple_rows = N ,  p_msg = No disconnection charge defined in sys_code. ,  resume_flg = Z )
default value  p_multiple_rows = N
default value  p_msg = NULL.
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(not-in resume_flg, "Y", "N", "Z")
evaluates to f 
let l_found = N 
let l_tmp_key1 = NULL. 
expression:(not-null p_msg)
evaluates to t 
expression:p_msg
evaluates to No disconnection charge defined in sys_code. 
let l_msg = No disconnection charge defined in sys_code. 
start select cursor.
select flex_key1, flex_key2
  from sys_code
  where (and (and (= sys_table, p_sys_table), (or (= sys_hard_group, p_sys_hard_group), (null p_sys_hard_group))), (or (= sys_hard_code, p_sys_hard_code), (null p_sys_hard_code)))
  order by flex_key2
select cursor iteration.
select cursor returns DP , DP 
expression:(= l_found, "N")
evaluates to t 
expression:l_flex_key1
evaluates to DP 
let l_tmp_key1 = DP 
expression:l_flex_key2
evaluates to DP 
let l_tmp_key2 = DP 
let l_found = Y 
select cursor iteration.
end cursor
expression:(not-null l_tmp_key1)
evaluates to t 
expression:l_tmp_key2
evaluates to DP 
expression:l_tmp_key1
evaluates to DP 
procedure ss_flex_code returns 0 , DP , DP 

expression:(<procedure> ss_flex_code, "charge_code" as p_sys_table, "DP" as p_sys_hard_group, "DP" as p_sys_hard_code, "No disconnection charge defined in sys_code." as p_msg, "Z" as resume_flg)
evaluates to DP                               ; DP                               ; 0 ; 
let l_return = 0 
let l_disc_code = DP                               
let l_dummy = DP                               
let l_event_ref = NULL. 
start select cursor.
select event_ref, due_tm
  from sched_dimension
  where (and (and (= sp_cn_ref, p_sp_cn_ref), (= event_type, l_event_type)), (= event_code, l_event_code))
select cursor iteration.
end cursor
expression:(null l_event_ref)
evaluates to t 
expression:(= resume_flg, "Z")
evaluates to f 
procedure ss_sched_disc_date returns 100 , NULL. , NULL. , NULL. , No record found 

expression:(<procedure> ss_sched_disc_date, l_sp_cn_ref as p_sp_cn_ref)
evaluates to No record found ; NULL. ; NULL. ; NULL. ; 100 ; 
let l_disc_flg = 100 
let l_disc_dt = NULL. 
let l_disc_event_ref = NULL. 
let l_penalty = NULL. 
let l_msg = No record found 
expression:(= l_disc_flg, 0)
evaluates to f 
let l_prev_plan_exists = N 
start select cursor.
select sp_plan_ref, sp_plan_start, sp_plan_stop
  from sp_cn_plan, package
  where (and (and (and (and (and (= sp_cn_plan.pkg_code, package.pkg_code), (= sp_cn_ref, l_sp_cn_ref)), (= packtypecd, l_packtypecd)), (null sched_ref)), (<> sp_plan_start, sp_plan_stop)), (<> sp_plan_ref, p_sp_plan_ref))
  order by sp_plan_stopdesc
select cursor iteration.
end cursor
expression:(= l_prev_plan_exists, "Y")
evaluates to f 
expression:(and (= l_packtypedflt, "Y"), (<> p_actual_change_dt, l_sp_connected))
evaluates to f 

execute function informix.sp_open_plan[procid=4476] ( p_sp_plan_ref = 385186 ,  p_open_dt = 2025-03-26 02:03:41 ,  p_apply_one_offs = Y ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_apply_one_offs = Y
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
expression:
  (select pkg_code, option, sched_ref, sp_cn_ref
    from sp_cn_plan
    where (= sp_plan_ref, p_sp_plan_ref))
evaluates to 239091 ; NULL. ; 1 ; 4401 ; 
let l_pkg_code = 4401 
let l_option = 1 
let l_sched_ref = NULL. 
let l_sp_cn_ref = 239091 
expression:(<> (dbinfo-sqlca.sqlerrd2 ), 1)
evaluates to f 
expression:(not-null l_sched_ref)
evaluates to f 
let l_sp_plan_start = NULL. 
expression:
  (select sp_plan_start, sp_plan_stop
    from sp_cn_plan
    where (= sp_plan_ref, p_sp_plan_ref))
evaluates to 2025-03-26 02:03:41 ; 2025-03-26 02:03:41 ; 
let l_sp_plan_start = 2025-03-26 02:03:41 
let l_sp_plan_stop = 2025-03-26 02:03:41 
expression:(null l_sp_plan_start)
evaluates to f 
expression:(<> l_sp_plan_start, l_sp_plan_stop)
evaluates to f 

update sp_cn_plan set
    (sp_plan_start) = (p_open_dt),
    (sp_plan_stop) = ("9999-01-01 00:00:00"),
    (sched_ref) = ( <NULL> )
  where (and (= sp_plan_ref, p_sp_plan_ref), (= sp_plan_start, sp_plan_stop));

before actions:

end before actions

for each row actions: 

execute function informix.get_upd_vals[procid=1412] ()
set_state: owner is informix - utype = 'D'procedure get_upd_vals returns webuser                          , 2025-03-26 15:26:32.000 


end for each row actions

after actions:

end after actions
expression:(<> (dbinfo-sqlca.sqlerrd2 ), 1)
evaluates to f 

execute function informix.sp_updt_subsdisc[procid=7343] ( p_sp_plan_ref = 385186 ,  p_sp_plan_start = 2025-03-26 02:03:41 ,  p_sp_plan_stop = 9999-01-01 00:00:00 ,  p_reverse = N ,  p_backdate = N ,  p_disconnect = N ,  p_discid = NULL. ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_reverse = N
default value  p_backdate = N
default value  p_disconnect = N
default value  p_discid = NULL.
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
let l_sp_cn_ref = NULL. 
expression:
  (select sp_cn_ref, packtypecd
    from sp_cn_plan, package
    where (and (= sp_cn_plan.pkg_code, package.pkg_code), (= sp_plan_ref, p_sp_plan_ref)))
evaluates to VR ; 239091 ; 
let l_sp_cn_ref = 239091 
let l_packtypecd = VR 
expression:(null l_sp_cn_ref)
evaluates to f 
let l_pre_sp_plan_ref = NULL. 
expression:
  (select (max sp_plan_ref)
    from sp_cn_plan, package
    where (and (and (and (and (= sp_cn_plan.pkg_code, package.pkg_code), (< sp_plan_ref, p_sp_plan_ref)), (<> sp_plan_start, sp_plan_stop)), (= sp_cn_ref, l_sp_cn_ref)), (= packtypecd, l_packtypecd)))
evaluates to NULL. ; 
let l_pre_sp_plan_ref = NULL. 
expression:(= (dbinfo-sqlca.sqlerrd2 ), 0)
evaluates to f 
start select cursor.
select subsdiscid, discid, subsdiscwefr, subsdiscweto, subsdiscprevweto, subsdiscauto
  from subsdisc
  where (and (= sp_plan_ref, p_sp_plan_ref), (or (null p_discid), (= discid, p_discid)))
select cursor iteration.
end cursor

execute function informix.ss_sys_cnfg[procid=7787] ( p_cnfg_key = CHG_PKG_CARRY_DISC ,  p_alt_cnfg_key = NULL. ,  p_default_val = Y ,  p_force_upper = Y ,  p_max_length = 1 ,  p_check_is_numeric = N ,  p_check_is_dt = N ,  trace_flg = N ,  resume_flg = N )
default value  p_alt_cnfg_key = NULL.
default value  p_default_val = NULL.
default value  p_force_upper = N
default value  p_max_length = 0
default value  p_check_is_numeric = N
default value  p_check_is_dt = N
default value  trace_flg = N
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

set lock mode to wait 30;
expression:(<procedure> upper, p_cnfg_key)
evaluates to CHG_PKG_CARRY_DISC               
let p_cnfg_key = CHG_PKG_CARRY_DISC               
let l_cnfg_val = NULL. 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_cnfg_key))
evaluates to Yes ; 
let l_cnfg_val = Yes 
expression:(and (null l_cnfg_val), (not-null p_alt_cnfg_key))
evaluates to f 
expression:(nvl l_cnfg_val, p_default_val)
evaluates to Yes 
let l_cnfg_val = Yes 
expression:(= p_force_upper, "Y")
evaluates to t 
expression:(<procedure> upper, l_cnfg_val)
evaluates to YES 
let l_cnfg_val = YES 
expression:(> p_max_length, 0)
evaluates to t 
expression:(substring l_cnfg_val, 1, p_max_length)
evaluates to Y 
let l_cnfg_val = Y 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(= p_check_is_dt, "Y")
evaluates to f 
expression:l_cnfg_val
evaluates to Y 
procedure ss_sys_cnfg returns 0 , Y , NULL. 

expression:(<procedure> ss_sys_cnfg, "CHG_PKG_CARRY_DISC" as p_cnfg_key, "Y" as p_default_val, 1 as p_max_length, "Y" as p_force_upper)
evaluates to NULL. ; Y ; 0 ; 
let l_return = 0 
let l_chg_pkg_carry_disc = Y 
let l_msg = NULL. 
expression:(<> l_chg_pkg_carry_disc, "N")
evaluates to t 
start select cursor.
select disc.discid, chlddiscid
  from sp_cn_plan, packdisc, disc
  where (and (and (and (and (and (and (and (= sp_cn_plan.pkg_code, packdisc.pkg_code), (= packdisc.discid, disc.discid)), (= sp_plan_ref, p_sp_plan_ref)), (<= packdiscwefr, p_sp_plan_start)), (>= packdiscweto, p_sp_plan_start)), (= packdiscauto, "N")), (or (= packdisc.option, sp_cn_plan.option), (= packdisc.option, 0))), (or (null p_discid), (= packdisc.discid, p_discid)))
select cursor iteration.
select cursor returns 1001 , NULL. 
let l_discid = 0 
expression:
  (select (count *)
    from subsdisc
    where (and (= sp_plan_ref, p_sp_plan_ref), (= discid, l_manual_discid)))
evaluates to 0 ; 
let l_discid = 0 
expression:(>= l_discid, 1)
evaluates to f 
expression:(not-null l_pre_sp_plan_ref)
evaluates to f 
select cursor iteration.
select cursor returns 1008 , NULL. 
let l_discid = 0 
expression:
  (select (count *)
    from subsdisc
    where (and (= sp_plan_ref, p_sp_plan_ref), (= discid, l_manual_discid)))
evaluates to 0 ; 
let l_discid = 0 
expression:(>= l_discid, 1)
evaluates to f 
expression:(not-null l_pre_sp_plan_ref)
evaluates to f 
select cursor iteration.
select cursor returns 3113 , NULL. 
let l_discid = 0 
expression:
  (select (count *)
    from subsdisc
    where (and (= sp_plan_ref, p_sp_plan_ref), (= discid, l_manual_discid)))
evaluates to 0 ; 
let l_discid = 0 
expression:(>= l_discid, 1)
evaluates to f 
expression:(not-null l_pre_sp_plan_ref)
evaluates to f 
select cursor iteration.
end cursor
expression:(<> p_sp_plan_start, p_sp_plan_stop)
evaluates to t 

execute function informix.sp_prop_disc_prnt[procid=7299] ( p_chld_sp_cn_ref = NULL. ,  p_chld_sp_plan_ref = 385186 ,  p_sp_plan_start = 2025-03-26 02:03:41 ,  p_sp_plan_stop = 9999-01-01 00:00:00 ,  p_prnt_sp_cn_ref = NULL. ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_chld_sp_cn_ref = NULL.
default value  p_chld_sp_plan_ref = NULL.
default value  p_sp_plan_start = NULL.
default value  p_sp_plan_stop = NULL.
default value  p_prnt_sp_cn_ref = NULL.
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
expression:(and (null p_chld_sp_plan_ref), (null p_chld_sp_cn_ref))
evaluates to f 
expression:(not-null p_chld_sp_cn_ref)
evaluates to f 
let l_chld_sp_cn_ref = NULL. 
expression:p_chld_sp_plan_ref
evaluates to 385186 
let l_chld_sp_plan_ref = 385186 
expression:
  (select sp_cn_ref, sp_plan_start, sp_plan_stop
    from sp_cn_plan, package, packtype
    where (and (and (and (= sp_cn_plan.pkg_code, package.pkg_code), (= package.packtypecd, packtype.packtypecd)), (= sp_plan_ref, l_chld_sp_plan_ref)), (= packtypedflt, "Y")))
evaluates to 9999-01-01 00:00:00 ; 2025-03-26 02:03:41 ; 239091 ; 
let l_chld_sp_cn_ref = 239091 
let l_chld_plan_start = 2025-03-26 02:03:41 
let l_chld_plan_stop = 9999-01-01 00:00:00 
expression:(nvl p_sp_plan_start, l_chld_plan_start)
evaluates to 2025-03-26 02:03:41 
let l_chld_plan_start = 2025-03-26 02:03:41 
expression:(nvl p_sp_plan_stop, l_chld_plan_stop)
evaluates to 9999-01-01 00:00:00 
let l_chld_plan_stop = 9999-01-01 00:00:00 
expression:(null l_chld_sp_cn_ref)
evaluates to f 
expression:(null p_prnt_sp_cn_ref)
evaluates to t 
start select cursor.
select subsdiscid, prntsubsdiscid
  from subsdisc
  where (and (= sp_plan_ref, l_chld_sp_plan_ref), (not-null prntsubsdiscid))
select cursor iteration.
end cursor
expression:(not-null p_prnt_sp_cn_ref)
evaluates to f 
expression:l_chld_sp_cn_ref
evaluates to 239091 
let l_sp_cn_ref = 239091 
let l_prnt_sp_cn_ref = NULL. 
expression:
  (select sp_cn_ref1
    from sp_reln
    where (= sp_cn_ref2, l_sp_cn_ref))
evaluates to NULL. ; 
let l_prnt_sp_cn_ref = NULL. 
expression:(null l_prnt_sp_cn_ref)
evaluates to t 
let l_msg = No parent service. 
expression:(= tran_flg, "Y")
evaluates to f 
expression:l_msg
evaluates to No parent service. 
procedure sp_prop_disc_prnt returns 0 , No parent service. 

expression:(<procedure> sp_prop_disc_prnt, p_sp_plan_ref as p_chld_sp_plan_ref, p_sp_plan_start as p_sp_plan_start, p_sp_plan_stop as p_sp_plan_stop, "N" as tran_flg)
evaluates to No parent service. ; 0 ; 
let l_return = 0 
let l_msg = No parent service. 
expression:(= tran_flg, "Y")
evaluates to f 
procedure sp_updt_subsdisc returns 0 , NULL. 

expression:(<procedure> sp_updt_subsdisc, p_sp_plan_ref as p_sp_plan_ref, p_open_dt as p_sp_plan_start, "9999-01-01 00:00:00" as p_sp_plan_stop, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_return = 0 
let l_msg = NULL. 

execute function informix.sp_apply_pkg_chgs[procid=6482] ( p_sp_plan_ref = 385186 ,  p_fix_mode = N ,  p_start_dt = NULL. ,  p_apply_one_offs = Y ,  p_open_only = Y ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_fix_mode = N
default value  p_start_dt = NULL.
default value  p_apply_one_offs = Y
default value  p_open_only = Y
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
expression:(and (not-null p_start_dt), (<> p_fix_mode, "Y"))
evaluates to f 
expression:(not-in p_fix_mode, "Y", "N")
evaluates to f 
let l_sp_plan_start = NULL. 
expression:
  (select sp_cn_ref, sp_plan_start, sp_plan_stop, pkg_code, option
    from sp_cn_plan
    where (= sp_plan_ref, p_sp_plan_ref))
evaluates to 1 ; 4401 ; 9999-01-01 00:00:00 ; 2025-03-26 02:03:41 ; 239091 ; 
let l_sp_cn_ref = 239091 
let l_sp_plan_start = 2025-03-26 02:03:41 
let l_sp_plan_stop = 9999-01-01 00:00:00 
let l_pkg_code = 4401 
let l_option = 1 
expression:(null l_sp_plan_start)
evaluates to f 
expression:(= l_sp_plan_start, l_sp_plan_stop)
evaluates to f 
expression:(and (< l_sp_plan_stop, "9999-01-01 00:00:00"), (= p_open_only, "Y"))
evaluates to f 
expression:(not-null p_start_dt)
evaluates to f 
start procedure cursor.
execute (<procedure> ss_pkg_chgs, l_pkg_code as p_pkg_code, l_option as p_option, l_sp_plan_start as p_dt)
default value  p_dt = 2025-03-26 15:26:32
default value  p_return_dflt_narr = N
default value  resume_flg = N
default value  trace_flg = N
iteration of cursory procedure ss_pkg_chgs

execute function informix.ss_pkg_chgs[procid=7894] ( p_pkg_code = 4401 ,  p_option = 1 ,  p_dt = 2025-03-26 02:03:41 ,  p_return_dflt_narr = N ,  resume_flg = N ,  trace_flg = N )
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
let l_found = N 
start select cursor.
select pkg_chgh.pkg_chg_num, pkg_chgh.chg_code, pkg_chgh.cost_ex, pkg_chgd.chg_amount, pkg_chgd.mth_since_plan, charge_code.chg_narr, charge_code.frequency
  from pkg_chgh, pkg_chgd, charge_code
  where (and (and (and (and (and (= pkg_chgh.pkg_chg_num, pkg_chgd.pkg_chg_num), (= charge_code.chg_code, pkg_chgh.chg_code)), (= pkg_chgh.pkg_code, p_pkg_code)), (or (= option, p_option), (= option, 0))), (between (date p_dt), start_date, end_date)), (= auto_apply, "Y"))
  order by pkg_chgh.pkg_chg_num, mth_since_plan
select cursor iteration.
end cursor
expression:(= l_found, "N")
evaluates to t 
procedure ss_pkg_chgs returns 100 , NULL. , NULL. , NULL. , NULL. , NULL. , NULL. , NULL. , NULL. , NULL. , No records found 

expression:(<> l_return, 0)
evaluates to t 
end cursor
expression:(= tran_flg, "Y")
evaluates to f 
procedure sp_apply_pkg_chgs returns 0 , NULL. 

expression:(<procedure> sp_apply_pkg_chgs, p_sp_plan_ref as p_sp_plan_ref, p_apply_one_offs as p_apply_one_offs, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_return = 0 
let l_msg = NULL. 
start select cursor.
select sp_cn_chg_ref
  from ntfl_chgdtl
  where (and (and (and (= sp_cn_ref, l_sp_cn_ref), (between p_open_dt, start_date, end_date)), (= status_id, 100)), (not-null sp_plan_ref))
select cursor iteration.
end cursor
start select cursor.
select geo_entity_ref
  from packgeo
  where (and (and (and (= pkg_code, l_pkg_code), (or (= option, l_option), (= option, 0))), (not-null geo_entity_ref)), (between (date p_open_dt), stat_wefr, stat_weto))
select cursor iteration.
end cursor

execute function informix.sp_crt_child_pkg[procid=4455] ( p_sp_cn_ref = 239091 ,  p_pkg_code = 4401 ,  p_child_pkg_code = NULL. ,  p_sp_plan_start = 2025-03-26 02:03:41 ,  p_sp_plan_stop = 9999-01-01 00:00:00 ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_child_pkg_code = NULL.
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
start select cursor.
select pkg_reln.chldpkg_code, pkg_reln.chldpkg_option, packtypecd
  from pkg_reln, package
  where (and (= pkg_reln.chldpkg_code, package.pkg_code), (= prntpkg_code, p_pkg_code))
select cursor iteration.
end cursor
expression:(= tran_flg, "Y")
evaluates to f 
procedure sp_crt_child_pkg returns 0 , NULL. 

expression:(<procedure> sp_crt_child_pkg, l_sp_cn_ref as p_sp_cn_ref, l_pkg_code as p_pkg_code, p_open_dt as p_sp_plan_start, "9999-01-01 00:00:00" as p_sp_plan_stop, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_return = 0 
let l_msg = NULL. 
expression:(= tran_flg, "Y")
evaluates to f 
procedure sp_open_plan returns 0 

expression:(<procedure> sp_open_plan, p_sp_plan_ref as p_sp_plan_ref, p_actual_change_dt as p_open_dt, l_apply_one_offs as p_apply_one_offs, "N" as tran_flg)
evaluates to 0 
let l_return = 0 
expression:(not-null p_plan_code)
evaluates to f 
expression:(= l_disc_flg, 0)
evaluates to f 
expression:(- 1)
evaluates to -1 
let l_prev_attribid = -1 
start select cursor.
select attribid, attribvalue, lockedattrib
  from packattrdef
  where (and (and (and (= pkg_code, l_pkg_code), (= enabled, "Y")), (not-null attribvalue)), (or (= pkg_option, 0), (= pkg_option, l_option)))
  order by attribid, pkg_optiondesc
select cursor iteration.
end cursor
expression:(and (<= p_actual_change_dt, (- current year to fraction(3), (units 30, 2440))), (= l_reprocess_calls, "Y"))
evaluates to f 
expression:(= l_prev_plan_exists, "Y")
evaluates to f 

execute function informix.ss_sys_cnfg[procid=7787] ( p_cnfg_key = DEFAULT_SRVC_NARR_TO_PACK_NARR ,  p_alt_cnfg_key = NULL. ,  p_default_val = N ,  p_force_upper = N ,  p_max_length = 1 ,  p_check_is_numeric = N ,  p_check_is_dt = N ,  trace_flg = N ,  resume_flg = N )
default value  p_alt_cnfg_key = NULL.
default value  p_default_val = NULL.
default value  p_force_upper = N
default value  p_max_length = 0
default value  p_check_is_numeric = N
default value  p_check_is_dt = N
default value  trace_flg = N
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 

set lock mode to wait 30;
expression:(<procedure> upper, p_cnfg_key)
evaluates to DEFAULT_SRVC_NARR_TO_PACK_NARR   
let p_cnfg_key = DEFAULT_SRVC_NARR_TO_PACK_NARR   
let l_cnfg_val = NULL. 
expression:
  (select cnfg_val
    from sys_cnfg
    where (= cnfg_key, p_cnfg_key))
evaluates to Yes ; 
let l_cnfg_val = Yes 
expression:(and (null l_cnfg_val), (not-null p_alt_cnfg_key))
evaluates to f 
expression:(nvl l_cnfg_val, p_default_val)
evaluates to Yes 
let l_cnfg_val = Yes 
expression:(= p_force_upper, "Y")
evaluates to f 
expression:(> p_max_length, 0)
evaluates to t 
expression:(substring l_cnfg_val, 1, p_max_length)
evaluates to Y 
let l_cnfg_val = Y 
expression:(= p_check_is_numeric, "Y")
evaluates to f 
expression:(= p_check_is_dt, "Y")
evaluates to f 
expression:l_cnfg_val
evaluates to Y 
procedure ss_sys_cnfg returns 0 , Y , NULL. 

expression:(<procedure> ss_sys_cnfg, "DEFAULT_SRVC_NARR_TO_PACK_NARR" as p_cnfg_key, "N" as p_default_val, 1 as p_max_length)
evaluates to NULL. ; Y ; 0 ; 
let l_return = 0 
let l_use_pkg_narr = Y 
let l_msg = NULL. 
expression:(and (= l_use_pkg_narr, "Y"), (= l_packtypedflt, "Y"))
evaluates to t 

update sp_connection set
    (sp_cn_narr) = (l_pkg_narr)
  where (= sp_cn_ref, l_sp_cn_ref);

before actions:

end before actions

for each row actions: 

execute function informix.get_upd_vals[procid=1412] ()
set_state: owner is informix - utype = 'D'procedure get_upd_vals returns webuser                          , 2025-03-26 15:26:32.000 


end for each row actions

after actions:

end after actions
expression:(= l_packtypedflt, "Y")
evaluates to t 

execute function informix.sp_geo_change_pack[procid=4458] ( p_sp_plan_ref = 385186 ,  trace_flg = N ,  resume_flg = N ,  tran_flg = N )
default value  trace_flg = N
default value  resume_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
let l_sp_cn_ref = NULL. 
expression:
  (select sp_cn_plan.sp_cn_ref, sp_cn_plan.pkg_code, sp_plan_start
    from sp_cn_plan
    where (= sp_plan_ref, p_sp_plan_ref))
evaluates to 2025-03-26 02:03:41 ; 4401 ; 239091 ; 
let l_sp_cn_ref = 239091 
let l_pkg_code = 4401 
let l_sp_plan_start = 2025-03-26 02:03:41 
expression:(null l_sp_cn_ref)
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 
let l_prev_geo_cat_code = n/a 
start select cursor.
select spcn_geo_ref, geo_cat_code
  from sp_cn_geo, geo_entity
  where (and (and (= sp_cn_geo.geo_entity_ref, geo_entity.geo_entity_ref), (= sp_cn_ref, l_sp_cn_ref)), (between l_sp_plan_start, assigned_fr, assigned_to))
  order by geo_cat_code, spcn_geo_ref
select cursor iteration.
end cursor
expression:(= tran_flg, "Y")
evaluates to f 
procedure sp_geo_change_pack returns 0 , NULL. 

expression:(<procedure> sp_geo_change_pack, p_sp_plan_ref as p_sp_plan_ref, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_return = 0 
let l_msg = NULL. 
expression:(= tran_flg, "Y")
evaluates to f 
procedure sp_set_package returns 0 , NULL. 

expression:(<procedure> sp_set_package, l_sp_plan_ref as p_sp_plan_ref, p_actual_change_dt as p_actual_change_dt, p_plan_code as p_plan_code, "Y" as p_new_connection, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_return = 0 
let l_msg = NULL. 

execute function informix.ss_flex_code[procid=1382] ( p_sys_table = charge_code ,  p_sys_hard_group = IP ,  p_sys_hard_code = IP ,  p_multiple_rows = N ,  p_msg = NULL. ,  resume_flg = N )
default value  p_multiple_rows = N
default value  p_msg = NULL.
default value  resume_flg = N
set_state: owner is informix - utype = 'D'expression:(not-in resume_flg, "Y", "N", "Z")
evaluates to f 
let l_found = N 
let l_tmp_key1 = NULL. 
expression:(not-null p_msg)
evaluates to f 
expression:(|| (|| "Flex key not found: ", TRIM ( BOTH ' ' FROM p_sys_table)), " | ")
evaluates to Flex key not found: charge_code |  
let l_msg = Flex key not found: charge_code |  
expression:(not-null p_sys_hard_group)
evaluates to t 
expression:(|| (|| l_msg, TRIM ( BOTH ' ' FROM p_sys_hard_group)), " | ")
evaluates to Flex key not found: charge_code | IP |  
let l_msg = Flex key not found: charge_code | IP |  
expression:(not-null p_sys_hard_code)
evaluates to t 
expression:(|| (|| l_msg, TRIM ( BOTH ' ' FROM p_sys_hard_code)), ". ")
evaluates to Flex key not found: charge_code | IP | IP.  
let l_msg = Flex key not found: charge_code | IP | IP.  
start select cursor.
select flex_key1, flex_key2
  from sys_code
  where (and (and (= sys_table, p_sys_table), (or (= sys_hard_group, p_sys_hard_group), (null p_sys_hard_group))), (or (= sys_hard_code, p_sys_hard_code), (null p_sys_hard_code)))
  order by flex_key2
select cursor iteration.
end cursor
expression:(not-null l_tmp_key1)
evaluates to f 
expression:(= l_found, "N")
evaluates to t 
expression:(= resume_flg, "Z")
evaluates to f 
procedure ss_flex_code returns 100 , NULL. , NULL. 

expression:(<procedure> ss_flex_code, "charge_code" as p_sys_table, "IP" as p_sys_hard_group, "IP" as p_sys_hard_code)
evaluates to NULL. ; NULL. ; 100 ; 
let l_return = 100 
let l_initial_payment = NULL. 
let l_flex_key2 = NULL. 
expression:(= l_return, 0)
evaluates to f 
expression:(not-null p_sp_code)
evaluates to f 

execute function informix.sp_attrib_chg[procid=7713] ( p_attribid = NULL. ,  p_attribvalue = NULL. ,  p_sp_cn_ref = 239091 ,  p_dt = 2025-03-26 02:03:41 ,  resume_flg = N ,  trace_flg = N ,  tran_flg = N )
default value  p_attribid = NULL.
default value  p_attribvalue = NULL.
default value  p_dt = 2025-03-26 15:26:32
default value  resume_flg = N
default value  trace_flg = N
default value  tran_flg = Y
set_state: owner is informix - utype = 'D'expression:(= trace_flg, "Y")
evaluates to f 
let l_srvctypecode = NULL. 
expression:
  (select srvctypecode, sys_status
    from sp_connection
    where (= sp_cn_ref, p_sp_cn_ref))
evaluates to OPN ; PID  ; 
let l_srvctypecode = PID  
let l_sys_status = OPN 
expression:(null l_srvctypecode)
evaluates to f 
expression:(<> l_sys_status, "OPN")
evaluates to f 
expression:(= tran_flg, "Y")
evaluates to f 

set lock mode to wait 5;
let l_updated = N 
start select cursor.
(
  select p_attribid, p_attribvalue
    from sp_connection
    where (and (= sp_cn_ref, p_sp_cn_ref), (not-null p_attribid))
union 
  select attribid, attribvalue
    from attrib
    where (and (and (= key_value, p_sp_cn_ref), (between p_dt, attribwefr, attribweto)), (null p_attribid))
)
  order by 1
select cursor iteration.
end cursor
expression:(= tran_flg, "Y")
evaluates to f 
expression:(= l_updated, "N")
evaluates to t 
procedure sp_attrib_chg returns 100 , Nothing to do 

expression:(<procedure> sp_attrib_chg, l_sp_cn_ref as p_sp_cn_ref, p_actual_change_dt as p_dt, "N" as tran_flg)
evaluates to Nothing to do ; 100 ; 
let l_return = 100 
let l_msg = Nothing to do 
expression:(= tran_flg, "Y")
evaluates to f 
procedure sp_set_connect returns 0 , NULL. 

expression:(<procedure> sp_set_connect, l_event_ref as p_event_ref, p_scheduled_dt as p_actual_change_dt, p_event_triggers as p_event_triggers, p_source as p_source, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_result = 0 
let l_msg = NULL. 
expression:(= tran_flg, "Y")
evaluates to f 
procedure sp_connect returns 0 , NULL. 

expression:(<procedure> sp_connect, p_sp_cn_ref as p_sp_cn_ref, p_connect_dt as p_scheduled_dt, p_set_connect as p_set_connect, <USER> as p_user, p_event_triggers as p_event_triggers, "N" as tran_flg)
evaluates to NULL. ; 0 ; 
let l_return = 0 
let l_msg = NULL. 
expression:(<> p_disconnect_dt, "9999-01-01 00:00:00")
evaluates to f 
expression:(and (= l_update_bill_cycle, "Y"), (<> p_srvctypecode, "ACCT"))
evaluates to f 
let l_srvc_evnt_ref = NULL. 
expression:
  (select a.event_ref
    from evnt_sp_cn as a, event as b
    where (and (and (and (= a.sp_cn_ref, p_sp_cn_ref), (= a.event_ref, b.event_ref)), (= b.event_type, l_event_type)), (= b.event_code, l_event_code)))
evaluates to 7159600 ; 
let l_srvc_evnt_ref = 7159600 
expression:
  (select phone_num, sp_connected
    from sp_connection
    where (= sp_cn_ref, p_sp_cn_ref))
evaluates to 2025-03-26 02:03:41 ; PD161470                                                         ; 
let l_phone_num = PD161470                                                         
let l_sp_connected = 2025-03-26 02:03:41 

execute function informix.sf_json_get_array[procid=9539] ( p_json = {"Activate":"CREATEASACTIVATED","ServiceId":null,"ServiceTypeId":"PID","NetworkId":null,"ContactCode":"UAT0341352","ConnectDatetime":"2025-03-26T02:03:41.019+00:00","EnquiryPassword":"test@333","PIN":111222,"UserLabel":"Test New Service Post Ar 1","ParentServiceReference":null,"Plans":[{"Id":4401,"OptionId":1}],"NetworkIdentifiers":null,"Attributes":null,"PortingInformation":null,"Sites":null,"Addresses":[{"TypeId":"BA","Address1":"222 Clarence St","Address2":"Old Office","Suburb":"Sydney","City":"Sydney","PostCode":"2000","StateCode":"NSW","CountryCode":"AU","Validate":true}],"CostCenters":[{"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"}],"RelatedContacts":null,"Contracts":null,"ServiceGroups":null,"Charges":[{"DefinitionId":"DAF","UnitPrice":4.00,"Price":4.00,"From":"2025-03-26T02:03:41.019+00:00","To":"2025-03-26T02:03:41.019+00:00","Unit":"Each","Description":"/service#post charge test","ServiceProviderId":null}],"ChargeOverrides":[{"DefinitionId":"CRED","Price":2.00,"From":"2025-03-26T02:03:41.019+00:00","To":"2026-03-26T02:03:41.019+00:00"}],"Hardware":null,"SalesStakeholders":null} ,  p_array_name = CostCenters )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_array_start_pos = 0 
let l_array_start_count = 0 
let l_array_end_pos = 0 
let l_array_name_len = 0 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_array_name)), """)
evaluates to "CostCenters" 
let p_array_name = "CostCenters" 
expression:(<procedure> length, p_array_name)
evaluates to 13 
let l_array_name_len = 13 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_array_name))
evaluates to 585 
let l_pos = 585 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_array_name_len), 1)
evaluates to 597 
let l_pos = 597 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 598 
let l_pos = 598 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to t 
expression:(or (= l_char, """), (= l_char, ","))
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 599 
let l_pos = 599 
expression:(substring p_json, l_pos, 1)
evaluates to [ 
let l_char = [ 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to f 
expression:(= l_char, "[")
evaluates to t 
expression:(<unknown op>: 87 l_escaped)
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 600 
let l_array_start_pos = 600 
expression:(+ l_array_start_count, 1)
evaluates to 1 
let l_array_start_count = 1 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 600 
let l_pos = 600 
expression:(substring p_json, l_pos, 1)
evaluates to { 
let l_char = { 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 601 
let l_pos = 601 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 602 
let l_pos = 602 
expression:(substring p_json, l_pos, 1)
evaluates to N 
let l_char = N 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 603 
let l_pos = 603 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 604 
let l_pos = 604 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 605 
let l_pos = 605 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 606 
let l_pos = 606 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 607 
let l_pos = 607 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 608 
let l_pos = 608 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 609 
let l_pos = 609 
expression:(substring p_json, l_pos, 1)
evaluates to T 
let l_char = T 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 610 
let l_pos = 610 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 611 
let l_pos = 611 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 612 
let l_pos = 612 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 613 
let l_pos = 613 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 614 
let l_pos = 614 
expression:(substring p_json, l_pos, 1)
evaluates to / 
let l_char = / 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 615 
let l_pos = 615 
expression:(substring p_json, l_pos, 1)
evaluates to S 
let l_char = S 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 616 
let l_pos = 616 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 617 
let l_pos = 617 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 618 
let l_pos = 618 
expression:(substring p_json, l_pos, 1)
evaluates to v 
let l_char = v 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 619 
let l_pos = 619 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 620 
let l_pos = 620 
expression:(substring p_json, l_pos, 1)
evaluates to c 
let l_char = c 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 621 
let l_pos = 621 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 622 
let l_pos = 622 
expression:(substring p_json, l_pos, 1)
evaluates to # 
let l_char = # 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 623 
let l_pos = 623 
expression:(substring p_json, l_pos, 1)
evaluates to p 
let l_char = p 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 624 
let l_pos = 624 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 625 
let l_pos = 625 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 626 
let l_pos = 626 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 627 
let l_pos = 627 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 628 
let l_pos = 628 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 629 
let l_pos = 629 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 630 
let l_pos = 630 
expression:(substring p_json, l_pos, 1)
evaluates to C 
let l_char = C 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 631 
let l_pos = 631 
expression:(substring p_json, l_pos, 1)
evaluates to u 
let l_char = u 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 632 
let l_pos = 632 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 633 
let l_pos = 633 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 634 
let l_pos = 634 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 635 
let l_pos = 635 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 636 
let l_pos = 636 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 637 
let l_pos = 637 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 638 
let l_pos = 638 
expression:(substring p_json, l_pos, 1)
evaluates to R 
let l_char = R 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 639 
let l_pos = 639 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 640 
let l_pos = 640 
expression:(substring p_json, l_pos, 1)
evaluates to f 
let l_char = f 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 641 
let l_pos = 641 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 642 
let l_pos = 642 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 643 
let l_pos = 643 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 644 
let l_pos = 644 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 645 
let l_pos = 645 
expression:(substring p_json, l_pos, 1)
evaluates to c 
let l_char = c 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 646 
let l_pos = 646 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 647 
let l_pos = 647 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 648 
let l_pos = 648 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 649 
let l_pos = 649 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 650 
let l_pos = 650 
expression:(substring p_json, l_pos, 1)
evaluates to T 
let l_char = T 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 651 
let l_pos = 651 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 652 
let l_pos = 652 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 653 
let l_pos = 653 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 654 
let l_pos = 654 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 655 
let l_pos = 655 
expression:(substring p_json, l_pos, 1)
evaluates to / 
let l_char = / 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 656 
let l_pos = 656 
expression:(substring p_json, l_pos, 1)
evaluates to S 
let l_char = S 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 657 
let l_pos = 657 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 658 
let l_pos = 658 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 659 
let l_pos = 659 
expression:(substring p_json, l_pos, 1)
evaluates to v 
let l_char = v 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 660 
let l_pos = 660 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 661 
let l_pos = 661 
expression:(substring p_json, l_pos, 1)
evaluates to c 
let l_char = c 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 662 
let l_pos = 662 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 663 
let l_pos = 663 
expression:(substring p_json, l_pos, 1)
evaluates to # 
let l_char = # 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 664 
let l_pos = 664 
expression:(substring p_json, l_pos, 1)
evaluates to p 
let l_char = p 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 665 
let l_pos = 665 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 666 
let l_pos = 666 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 667 
let l_pos = 667 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 668 
let l_pos = 668 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 669 
let l_pos = 669 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 670 
let l_pos = 670 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 671 
let l_pos = 671 
expression:(substring p_json, l_pos, 1)
evaluates to C 
let l_char = C 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 672 
let l_pos = 672 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 673 
let l_pos = 673 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 674 
let l_pos = 674 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 675 
let l_pos = 675 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 676 
let l_pos = 676 
expression:(substring p_json, l_pos, 1)
evaluates to c 
let l_char = c 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 677 
let l_pos = 677 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 678 
let l_pos = 678 
expression:(substring p_json, l_pos, 1)
evaluates to C 
let l_char = C 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 679 
let l_pos = 679 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 680 
let l_pos = 680 
expression:(substring p_json, l_pos, 1)
evaluates to d 
let l_char = d 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 681 
let l_pos = 681 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 682 
let l_pos = 682 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 683 
let l_pos = 683 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 684 
let l_pos = 684 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 685 
let l_pos = 685 
expression:(substring p_json, l_pos, 1)
evaluates to 4 
let l_char = 4 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 686 
let l_pos = 686 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 687 
let l_pos = 687 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 688 
let l_pos = 688 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 689 
let l_pos = 689 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 690 
let l_pos = 690 
expression:(substring p_json, l_pos, 1)
evaluates to 1 
let l_char = 1 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 691 
let l_pos = 691 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 692 
let l_pos = 692 
expression:(substring p_json, l_pos, 1)
evaluates to 6 
let l_char = 6 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 693 
let l_pos = 693 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 694 
let l_pos = 694 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 695 
let l_pos = 695 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 696 
let l_pos = 696 
expression:(substring p_json, l_pos, 1)
evaluates to U 
let l_char = U 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 697 
let l_pos = 697 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 698 
let l_pos = 698 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 699 
let l_pos = 699 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 700 
let l_pos = 700 
expression:(substring p_json, l_pos, 1)
evaluates to I 
let l_char = I 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 701 
let l_pos = 701 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 702 
let l_pos = 702 
expression:(substring p_json, l_pos, 1)
evaluates to f 
let l_char = f 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 703 
let l_pos = 703 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 704 
let l_pos = 704 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 705 
let l_pos = 705 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 706 
let l_pos = 706 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 707 
let l_pos = 707 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 708 
let l_pos = 708 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 709 
let l_pos = 709 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 710 
let l_pos = 710 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 711 
let l_pos = 711 
expression:(substring p_json, l_pos, 1)
evaluates to 1 
let l_char = 1 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 712 
let l_pos = 712 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 713 
let l_pos = 713 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 714 
let l_pos = 714 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 715 
let l_pos = 715 
expression:(substring p_json, l_pos, 1)
evaluates to U 
let l_char = U 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 716 
let l_pos = 716 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 717 
let l_pos = 717 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 718 
let l_pos = 718 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 719 
let l_pos = 719 
expression:(substring p_json, l_pos, 1)
evaluates to I 
let l_char = I 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 720 
let l_pos = 720 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 721 
let l_pos = 721 
expression:(substring p_json, l_pos, 1)
evaluates to f 
let l_char = f 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 722 
let l_pos = 722 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 723 
let l_pos = 723 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 724 
let l_pos = 724 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 725 
let l_pos = 725 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 726 
let l_pos = 726 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 727 
let l_pos = 727 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 728 
let l_pos = 728 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 729 
let l_pos = 729 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 730 
let l_pos = 730 
expression:(substring p_json, l_pos, 1)
evaluates to 1 
let l_char = 1 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 731 
let l_pos = 731 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 732 
let l_pos = 732 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 733 
let l_pos = 733 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 734 
let l_pos = 734 
expression:(substring p_json, l_pos, 1)
evaluates to U 
let l_char = U 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 735 
let l_pos = 735 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 736 
let l_pos = 736 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 737 
let l_pos = 737 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 738 
let l_pos = 738 
expression:(substring p_json, l_pos, 1)
evaluates to I 
let l_char = I 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 739 
let l_pos = 739 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 740 
let l_pos = 740 
expression:(substring p_json, l_pos, 1)
evaluates to f 
let l_char = f 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 741 
let l_pos = 741 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 742 
let l_pos = 742 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 743 
let l_pos = 743 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 744 
let l_pos = 744 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 745 
let l_pos = 745 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 746 
let l_pos = 746 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 747 
let l_pos = 747 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 748 
let l_pos = 748 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 749 
let l_pos = 749 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 750 
let l_pos = 750 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 751 
let l_pos = 751 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 752 
let l_pos = 752 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 753 
let l_pos = 753 
expression:(substring p_json, l_pos, 1)
evaluates to U 
let l_char = U 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 754 
let l_pos = 754 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 755 
let l_pos = 755 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 756 
let l_pos = 756 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 757 
let l_pos = 757 
expression:(substring p_json, l_pos, 1)
evaluates to I 
let l_char = I 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 758 
let l_pos = 758 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 759 
let l_pos = 759 
expression:(substring p_json, l_pos, 1)
evaluates to f 
let l_char = f 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 760 
let l_pos = 760 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 761 
let l_pos = 761 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 762 
let l_pos = 762 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 763 
let l_pos = 763 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 764 
let l_pos = 764 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 765 
let l_pos = 765 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 766 
let l_pos = 766 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 767 
let l_pos = 767 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 768 
let l_pos = 768 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 769 
let l_pos = 769 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 770 
let l_pos = 770 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 771 
let l_pos = 771 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 772 
let l_pos = 772 
expression:(substring p_json, l_pos, 1)
evaluates to U 
let l_char = U 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 773 
let l_pos = 773 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 774 
let l_pos = 774 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 775 
let l_pos = 775 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 776 
let l_pos = 776 
expression:(substring p_json, l_pos, 1)
evaluates to I 
let l_char = I 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 777 
let l_pos = 777 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 778 
let l_pos = 778 
expression:(substring p_json, l_pos, 1)
evaluates to f 
let l_char = f 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 779 
let l_pos = 779 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 780 
let l_pos = 780 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 781 
let l_pos = 781 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 782 
let l_pos = 782 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 783 
let l_pos = 783 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 784 
let l_pos = 784 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 785 
let l_pos = 785 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 786 
let l_pos = 786 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 787 
let l_pos = 787 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 788 
let l_pos = 788 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 789 
let l_pos = 789 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 790 
let l_pos = 790 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 791 
let l_pos = 791 
expression:(substring p_json, l_pos, 1)
evaluates to U 
let l_char = U 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 792 
let l_pos = 792 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 793 
let l_pos = 793 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 794 
let l_pos = 794 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 795 
let l_pos = 795 
expression:(substring p_json, l_pos, 1)
evaluates to I 
let l_char = I 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 796 
let l_pos = 796 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 797 
let l_pos = 797 
expression:(substring p_json, l_pos, 1)
evaluates to f 
let l_char = f 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 798 
let l_pos = 798 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 799 
let l_pos = 799 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 800 
let l_pos = 800 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 801 
let l_pos = 801 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 802 
let l_pos = 802 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 803 
let l_pos = 803 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 804 
let l_pos = 804 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 805 
let l_pos = 805 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 806 
let l_pos = 806 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 807 
let l_pos = 807 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 808 
let l_pos = 808 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 809 
let l_pos = 809 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 810 
let l_pos = 810 
expression:(substring p_json, l_pos, 1)
evaluates to G 
let l_char = G 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 811 
let l_pos = 811 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 812 
let l_pos = 812 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 813 
let l_pos = 813 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 814 
let l_pos = 814 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 815 
let l_pos = 815 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 816 
let l_pos = 816 
expression:(substring p_json, l_pos, 1)
evaluates to l 
let l_char = l 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 817 
let l_pos = 817 
expression:(substring p_json, l_pos, 1)
evaluates to L 
let l_char = L 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 818 
let l_pos = 818 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 819 
let l_pos = 819 
expression:(substring p_json, l_pos, 1)
evaluates to d 
let l_char = d 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 820 
let l_pos = 820 
expression:(substring p_json, l_pos, 1)
evaluates to g 
let l_char = g 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 821 
let l_pos = 821 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 822 
let l_pos = 822 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 823 
let l_pos = 823 
expression:(substring p_json, l_pos, 1)
evaluates to A 
let l_char = A 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 824 
let l_pos = 824 
expression:(substring p_json, l_pos, 1)
evaluates to c 
let l_char = c 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 825 
let l_pos = 825 
expression:(substring p_json, l_pos, 1)
evaluates to c 
let l_char = c 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 826 
let l_pos = 826 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 827 
let l_pos = 827 
expression:(substring p_json, l_pos, 1)
evaluates to u 
let l_char = u 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 828 
let l_pos = 828 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 829 
let l_pos = 829 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 830 
let l_pos = 830 
expression:(substring p_json, l_pos, 1)
evaluates to C 
let l_char = C 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 831 
let l_pos = 831 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 832 
let l_pos = 832 
expression:(substring p_json, l_pos, 1)
evaluates to d 
let l_char = d 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 833 
let l_pos = 833 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 834 
let l_pos = 834 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 835 
let l_pos = 835 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 836 
let l_pos = 836 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 837 
let l_pos = 837 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 838 
let l_pos = 838 
expression:(substring p_json, l_pos, 1)
evaluates to - 
let l_char = - 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 839 
let l_pos = 839 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 840 
let l_pos = 840 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 841 
let l_pos = 841 
expression:(substring p_json, l_pos, 1)
evaluates to - 
let l_char = - 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 842 
let l_pos = 842 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 843 
let l_pos = 843 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 844 
let l_pos = 844 
expression:(substring p_json, l_pos, 1)
evaluates to - 
let l_char = - 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 845 
let l_pos = 845 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 846 
let l_pos = 846 
expression:(substring p_json, l_pos, 1)
evaluates to 1 
let l_char = 1 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 847 
let l_pos = 847 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 848 
let l_pos = 848 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 849 
let l_pos = 849 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 850 
let l_pos = 850 
expression:(substring p_json, l_pos, 1)
evaluates to A 
let l_char = A 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 851 
let l_pos = 851 
expression:(substring p_json, l_pos, 1)
evaluates to g 
let l_char = g 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 852 
let l_pos = 852 
expression:(substring p_json, l_pos, 1)
evaluates to g 
let l_char = g 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 853 
let l_pos = 853 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 854 
let l_pos = 854 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 855 
let l_pos = 855 
expression:(substring p_json, l_pos, 1)
evaluates to g 
let l_char = g 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 856 
let l_pos = 856 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 857 
let l_pos = 857 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 858 
let l_pos = 858 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 859 
let l_pos = 859 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 860 
let l_pos = 860 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 861 
let l_pos = 861 
expression:(substring p_json, l_pos, 1)
evaluates to P 
let l_char = P 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 862 
let l_pos = 862 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 863 
let l_pos = 863 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 864 
let l_pos = 864 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 865 
let l_pos = 865 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 866 
let l_pos = 866 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 867 
let l_pos = 867 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 868 
let l_pos = 868 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 869 
let l_pos = 869 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 870 
let l_pos = 870 
expression:(substring p_json, l_pos, 1)
evaluates to u 
let l_char = u 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 871 
let l_pos = 871 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 872 
let l_pos = 872 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 873 
let l_pos = 873 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 874 
let l_pos = 874 
expression:(substring p_json, l_pos, 1)
evaluates to A 
let l_char = A 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 875 
let l_pos = 875 
expression:(substring p_json, l_pos, 1)
evaluates to l 
let l_char = l 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 876 
let l_pos = 876 
expression:(substring p_json, l_pos, 1)
evaluates to l 
let l_char = l 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 877 
let l_pos = 877 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 878 
let l_pos = 878 
expression:(substring p_json, l_pos, 1)
evaluates to c 
let l_char = c 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 879 
let l_pos = 879 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 880 
let l_pos = 880 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 881 
let l_pos = 881 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 882 
let l_pos = 882 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 883 
let l_pos = 883 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 884 
let l_pos = 884 
expression:(substring p_json, l_pos, 1)
evaluates to T 
let l_char = T 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 885 
let l_pos = 885 
expression:(substring p_json, l_pos, 1)
evaluates to y 
let l_char = y 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 886 
let l_pos = 886 
expression:(substring p_json, l_pos, 1)
evaluates to p 
let l_char = p 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 887 
let l_pos = 887 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 888 
let l_pos = 888 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 889 
let l_pos = 889 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 890 
let l_pos = 890 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 891 
let l_pos = 891 
expression:(substring p_json, l_pos, 1)
evaluates to D 
let l_char = D 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 892 
let l_pos = 892 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 893 
let l_pos = 893 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 894 
let l_pos = 894 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 895 
let l_pos = 895 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 896 
let l_pos = 896 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 897 
let l_pos = 897 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 898 
let l_pos = 898 
expression:(substring p_json, l_pos, 1)
evaluates to S 
let l_char = S 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 899 
let l_pos = 899 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 900 
let l_pos = 900 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 901 
let l_pos = 901 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 902 
let l_pos = 902 
expression:(substring p_json, l_pos, 1)
evaluates to u 
let l_char = u 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 903 
let l_pos = 903 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 904 
let l_pos = 904 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 905 
let l_pos = 905 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 906 
let l_pos = 906 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 907 
let l_pos = 907 
expression:(substring p_json, l_pos, 1)
evaluates to O 
let l_char = O 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 908 
let l_pos = 908 
expression:(substring p_json, l_pos, 1)
evaluates to p 
let l_char = p 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 909 
let l_pos = 909 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 910 
let l_pos = 910 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 911 
let l_pos = 911 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 912 
let l_pos = 912 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 913 
let l_pos = 913 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 914 
let l_pos = 914 
expression:(substring p_json, l_pos, 1)
evaluates to S 
let l_char = S 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 915 
let l_pos = 915 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 916 
let l_pos = 916 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 917 
let l_pos = 917 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 918 
let l_pos = 918 
expression:(substring p_json, l_pos, 1)
evaluates to u 
let l_char = u 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 919 
let l_pos = 919 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 920 
let l_pos = 920 
expression:(substring p_json, l_pos, 1)
evaluates to U 
let l_char = U 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 921 
let l_pos = 921 
expression:(substring p_json, l_pos, 1)
evaluates to p 
let l_char = p 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 922 
let l_pos = 922 
expression:(substring p_json, l_pos, 1)
evaluates to d 
let l_char = d 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 923 
let l_pos = 923 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 924 
let l_pos = 924 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 925 
let l_pos = 925 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 926 
let l_pos = 926 
expression:(substring p_json, l_pos, 1)
evaluates to d 
let l_char = d 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 927 
let l_pos = 927 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 928 
let l_pos = 928 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 929 
let l_pos = 929 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 930 
let l_pos = 930 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 931 
let l_pos = 931 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 932 
let l_pos = 932 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 933 
let l_pos = 933 
expression:(substring p_json, l_pos, 1)
evaluates to 5 
let l_char = 5 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 934 
let l_pos = 934 
expression:(substring p_json, l_pos, 1)
evaluates to - 
let l_char = - 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 935 
let l_pos = 935 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 936 
let l_pos = 936 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 937 
let l_pos = 937 
expression:(substring p_json, l_pos, 1)
evaluates to - 
let l_char = - 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 938 
let l_pos = 938 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 939 
let l_pos = 939 
expression:(substring p_json, l_pos, 1)
evaluates to 6 
let l_char = 6 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 940 
let l_pos = 940 
expression:(substring p_json, l_pos, 1)
evaluates to T 
let l_char = T 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 941 
let l_pos = 941 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 942 
let l_pos = 942 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 943 
let l_pos = 943 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 944 
let l_pos = 944 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 945 
let l_pos = 945 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 946 
let l_pos = 946 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 947 
let l_pos = 947 
expression:(substring p_json, l_pos, 1)
evaluates to 4 
let l_char = 4 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 948 
let l_pos = 948 
expression:(substring p_json, l_pos, 1)
evaluates to 1 
let l_char = 1 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 949 
let l_pos = 949 
expression:(substring p_json, l_pos, 1)
evaluates to . 
let l_char = . 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 950 
let l_pos = 950 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 951 
let l_pos = 951 
expression:(substring p_json, l_pos, 1)
evaluates to 1 
let l_char = 1 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 952 
let l_pos = 952 
expression:(substring p_json, l_pos, 1)
evaluates to 9 
let l_char = 9 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 953 
let l_pos = 953 
expression:(substring p_json, l_pos, 1)
evaluates to + 
let l_char = + 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 954 
let l_pos = 954 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 955 
let l_pos = 955 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 956 
let l_pos = 956 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 957 
let l_pos = 957 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 958 
let l_pos = 958 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 959 
let l_pos = 959 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 960 
let l_pos = 960 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 961 
let l_pos = 961 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 962 
let l_pos = 962 
expression:(substring p_json, l_pos, 1)
evaluates to P 
let l_char = P 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 963 
let l_pos = 963 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 964 
let l_pos = 964 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 965 
let l_pos = 965 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 966 
let l_pos = 966 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 967 
let l_pos = 967 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 968 
let l_pos = 968 
expression:(substring p_json, l_pos, 1)
evaluates to I 
let l_char = I 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 969 
let l_pos = 969 
expression:(substring p_json, l_pos, 1)
evaluates to d 
let l_char = d 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 970 
let l_pos = 970 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 971 
let l_pos = 971 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 972 
let l_pos = 972 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 973 
let l_pos = 973 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 974 
let l_pos = 974 
expression:(substring p_json, l_pos, 1)
evaluates to 5 
let l_char = 5 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 975 
let l_pos = 975 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 976 
let l_pos = 976 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 977 
let l_pos = 977 
expression:(substring p_json, l_pos, 1)
evaluates to E 
let l_char = E 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 978 
let l_pos = 978 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 979 
let l_pos = 979 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 980 
let l_pos = 980 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 981 
let l_pos = 981 
expression:(substring p_json, l_pos, 1)
evaluates to l 
let l_char = l 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 982 
let l_pos = 982 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 983 
let l_pos = 983 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 984 
let l_pos = 984 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 985 
let l_pos = 985 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 986 
let l_pos = 986 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 987 
let l_pos = 987 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 988 
let l_pos = 988 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 989 
let l_pos = 989 
expression:(substring p_json, l_pos, 1)
evaluates to @ 
let l_char = @ 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 990 
let l_pos = 990 
expression:(substring p_json, l_pos, 1)
evaluates to g 
let l_char = g 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 991 
let l_pos = 991 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 992 
let l_pos = 992 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 993 
let l_pos = 993 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 994 
let l_pos = 994 
expression:(substring p_json, l_pos, 1)
evaluates to l 
let l_char = l 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 995 
let l_pos = 995 
expression:(substring p_json, l_pos, 1)
evaluates to . 
let l_char = . 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 996 
let l_pos = 996 
expression:(substring p_json, l_pos, 1)
evaluates to c 
let l_char = c 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 997 
let l_pos = 997 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 998 
let l_pos = 998 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 999 
let l_pos = 999 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 1000 
let l_pos = 1000 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 1001 
let l_pos = 1001 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 1002 
let l_pos = 1002 
expression:(substring p_json, l_pos, 1)
evaluates to E 
let l_char = E 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 1003 
let l_pos = 1003 
expression:(substring p_json, l_pos, 1)
evaluates to F 
let l_char = F 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 1004 
let l_pos = 1004 
expression:(substring p_json, l_pos, 1)
evaluates to X 
let l_char = X 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 1005 
let l_pos = 1005 
expression:(substring p_json, l_pos, 1)
evaluates to I 
let l_char = I 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 1006 
let l_pos = 1006 
expression:(substring p_json, l_pos, 1)
evaluates to d 
let l_char = d 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 1007 
let l_pos = 1007 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 1008 
let l_pos = 1008 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 1009 
let l_pos = 1009 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 1010 
let l_pos = 1010 
expression:(substring p_json, l_pos, 1)
evaluates to E 
let l_char = E 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 1011 
let l_pos = 1011 
expression:(substring p_json, l_pos, 1)
evaluates to F 
let l_char = F 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 1012 
let l_pos = 1012 
expression:(substring p_json, l_pos, 1)
evaluates to X 
let l_char = X 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 1013 
let l_pos = 1013 
expression:(substring p_json, l_pos, 1)
evaluates to - 
let l_char = - 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 1014 
let l_pos = 1014 
expression:(substring p_json, l_pos, 1)
evaluates to 5 
let l_char = 5 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 1015 
let l_pos = 1015 
expression:(substring p_json, l_pos, 1)
evaluates to 5 
let l_char = 5 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 1016 
let l_pos = 1016 
expression:(substring p_json, l_pos, 1)
evaluates to 5 
let l_char = 5 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 1017 
let l_pos = 1017 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 1018 
let l_pos = 1018 
expression:(substring p_json, l_pos, 1)
evaluates to } 
let l_char = } 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to t 
let l_escaped = f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 1019 
let l_pos = 1019 
expression:(substring p_json, l_pos, 1)
evaluates to ] 
let l_char = ] 
expression:(and (not (<unknown op>: 87 l_escaped)), (= l_char, "\"))
evaluates to f 
expression:(and (<> l_char, "["), (<> l_char, "]"))
evaluates to f 
expression:(= l_char, "[")
evaluates to f 
expression:(= l_array_start_pos, 0)
evaluates to f 
expression:(= l_char, "]")
evaluates to t 
expression:(<unknown op>: 87 l_escaped)
evaluates to f 
expression:(= l_array_start_count, 1)
evaluates to t 
expression:(substring p_json, l_array_start_pos, (- l_pos, l_array_start_pos))
evaluates to {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} 
let l_array_str = {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} 
expression:l_array_str
evaluates to {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} 
procedure sf_json_get_array returns {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} 

expression:(<procedure> sf_json_get_array, p_request_body, "CostCenters")
evaluates to {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} 
let l_array = {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} 
expression:(not-null l_array)
evaluates to t 
start procedure cursor.
execute (<procedure> sf_json_get_obj, l_array)
default value  p_name = NULL.
iteration of cursory procedure sf_json_get_obj

execute function informix.sf_json_get_obj[procid=9599] ( p_json = {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} ,  p_name = NULL. )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_obj_start_counter = 0 
let l_obj_start_pos = 0 
let l_obj_end_pos = 0 
expression: LIST{}
evaluates to 
execute function informix.collectionoutput[procid=19] ( arg[0] =  )
LIST{} 
let l_object_array = 
execute function informix.collectionoutput[procid=19] ( arg[0] =  )
LIST{} 
expression:(not-null p_name)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 1 
let l_pos = 1 
expression:(substring p_json, l_pos, 1)
evaluates to { 
let l_char = { 
expression:(= l_char, "{")
evaluates to t 
expression:(+ l_obj_start_counter, 1)
evaluates to 1 
let l_obj_start_counter = 1 
expression:(= l_obj_start_counter, 1)
evaluates to t 
expression:l_pos
evaluates to 1 
let l_obj_start_pos = 1 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 2 
let l_pos = 2 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 3 
let l_pos = 3 
expression:(substring p_json, l_pos, 1)
evaluates to N 
let l_char = N 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 4 
let l_pos = 4 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 5 
let l_pos = 5 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 6 
let l_pos = 6 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 7 
let l_pos = 7 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 8 
let l_pos = 8 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 9 
let l_pos = 9 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 10 
let l_pos = 10 
expression:(substring p_json, l_pos, 1)
evaluates to T 
let l_char = T 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 11 
let l_pos = 11 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 12 
let l_pos = 12 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 13 
let l_pos = 13 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 14 
let l_pos = 14 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 15 
let l_pos = 15 
expression:(substring p_json, l_pos, 1)
evaluates to / 
let l_char = / 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 16 
let l_pos = 16 
expression:(substring p_json, l_pos, 1)
evaluates to S 
let l_char = S 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 17 
let l_pos = 17 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 18 
let l_pos = 18 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 19 
let l_pos = 19 
expression:(substring p_json, l_pos, 1)
evaluates to v 
let l_char = v 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 20 
let l_pos = 20 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 21 
let l_pos = 21 
expression:(substring p_json, l_pos, 1)
evaluates to c 
let l_char = c 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 22 
let l_pos = 22 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 23 
let l_pos = 23 
expression:(substring p_json, l_pos, 1)
evaluates to # 
let l_char = # 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 24 
let l_pos = 24 
expression:(substring p_json, l_pos, 1)
evaluates to p 
let l_char = p 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 25 
let l_pos = 25 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 26 
let l_pos = 26 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 27 
let l_pos = 27 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 28 
let l_pos = 28 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 29 
let l_pos = 29 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 30 
let l_pos = 30 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 31 
let l_pos = 31 
expression:(substring p_json, l_pos, 1)
evaluates to C 
let l_char = C 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 32 
let l_pos = 32 
expression:(substring p_json, l_pos, 1)
evaluates to u 
let l_char = u 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 33 
let l_pos = 33 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 34 
let l_pos = 34 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 35 
let l_pos = 35 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 36 
let l_pos = 36 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 37 
let l_pos = 37 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 38 
let l_pos = 38 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 39 
let l_pos = 39 
expression:(substring p_json, l_pos, 1)
evaluates to R 
let l_char = R 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 40 
let l_pos = 40 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 41 
let l_pos = 41 
expression:(substring p_json, l_pos, 1)
evaluates to f 
let l_char = f 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 42 
let l_pos = 42 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 43 
let l_pos = 43 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 44 
let l_pos = 44 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 45 
let l_pos = 45 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 46 
let l_pos = 46 
expression:(substring p_json, l_pos, 1)
evaluates to c 
let l_char = c 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 47 
let l_pos = 47 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 48 
let l_pos = 48 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 49 
let l_pos = 49 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 50 
let l_pos = 50 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 51 
let l_pos = 51 
expression:(substring p_json, l_pos, 1)
evaluates to T 
let l_char = T 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 52 
let l_pos = 52 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 53 
let l_pos = 53 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 54 
let l_pos = 54 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 55 
let l_pos = 55 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 56 
let l_pos = 56 
expression:(substring p_json, l_pos, 1)
evaluates to / 
let l_char = / 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 57 
let l_pos = 57 
expression:(substring p_json, l_pos, 1)
evaluates to S 
let l_char = S 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 58 
let l_pos = 58 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 59 
let l_pos = 59 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 60 
let l_pos = 60 
expression:(substring p_json, l_pos, 1)
evaluates to v 
let l_char = v 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 61 
let l_pos = 61 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 62 
let l_pos = 62 
expression:(substring p_json, l_pos, 1)
evaluates to c 
let l_char = c 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 63 
let l_pos = 63 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 64 
let l_pos = 64 
expression:(substring p_json, l_pos, 1)
evaluates to # 
let l_char = # 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 65 
let l_pos = 65 
expression:(substring p_json, l_pos, 1)
evaluates to p 
let l_char = p 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 66 
let l_pos = 66 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 67 
let l_pos = 67 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 68 
let l_pos = 68 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 69 
let l_pos = 69 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 70 
let l_pos = 70 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 71 
let l_pos = 71 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 72 
let l_pos = 72 
expression:(substring p_json, l_pos, 1)
evaluates to C 
let l_char = C 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 73 
let l_pos = 73 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 74 
let l_pos = 74 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 75 
let l_pos = 75 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 76 
let l_pos = 76 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 77 
let l_pos = 77 
expression:(substring p_json, l_pos, 1)
evaluates to c 
let l_char = c 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 78 
let l_pos = 78 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 79 
let l_pos = 79 
expression:(substring p_json, l_pos, 1)
evaluates to C 
let l_char = C 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 80 
let l_pos = 80 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 81 
let l_pos = 81 
expression:(substring p_json, l_pos, 1)
evaluates to d 
let l_char = d 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 82 
let l_pos = 82 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 83 
let l_pos = 83 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 84 
let l_pos = 84 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 85 
let l_pos = 85 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 86 
let l_pos = 86 
expression:(substring p_json, l_pos, 1)
evaluates to 4 
let l_char = 4 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 87 
let l_pos = 87 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 88 
let l_pos = 88 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 89 
let l_pos = 89 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 90 
let l_pos = 90 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 91 
let l_pos = 91 
expression:(substring p_json, l_pos, 1)
evaluates to 1 
let l_char = 1 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 92 
let l_pos = 92 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 93 
let l_pos = 93 
expression:(substring p_json, l_pos, 1)
evaluates to 6 
let l_char = 6 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 94 
let l_pos = 94 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 95 
let l_pos = 95 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 96 
let l_pos = 96 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 97 
let l_pos = 97 
expression:(substring p_json, l_pos, 1)
evaluates to U 
let l_char = U 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 98 
let l_pos = 98 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 99 
let l_pos = 99 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 100 
let l_pos = 100 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 101 
let l_pos = 101 
expression:(substring p_json, l_pos, 1)
evaluates to I 
let l_char = I 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 102 
let l_pos = 102 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 103 
let l_pos = 103 
expression:(substring p_json, l_pos, 1)
evaluates to f 
let l_char = f 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 104 
let l_pos = 104 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 105 
let l_pos = 105 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 106 
let l_pos = 106 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 107 
let l_pos = 107 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 108 
let l_pos = 108 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 109 
let l_pos = 109 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 110 
let l_pos = 110 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 111 
let l_pos = 111 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 112 
let l_pos = 112 
expression:(substring p_json, l_pos, 1)
evaluates to 1 
let l_char = 1 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 113 
let l_pos = 113 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 114 
let l_pos = 114 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 115 
let l_pos = 115 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 116 
let l_pos = 116 
expression:(substring p_json, l_pos, 1)
evaluates to U 
let l_char = U 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 117 
let l_pos = 117 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 118 
let l_pos = 118 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 119 
let l_pos = 119 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 120 
let l_pos = 120 
expression:(substring p_json, l_pos, 1)
evaluates to I 
let l_char = I 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 121 
let l_pos = 121 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 122 
let l_pos = 122 
expression:(substring p_json, l_pos, 1)
evaluates to f 
let l_char = f 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 123 
let l_pos = 123 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 124 
let l_pos = 124 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 125 
let l_pos = 125 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 126 
let l_pos = 126 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 127 
let l_pos = 127 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 128 
let l_pos = 128 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 129 
let l_pos = 129 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 130 
let l_pos = 130 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 131 
let l_pos = 131 
expression:(substring p_json, l_pos, 1)
evaluates to 1 
let l_char = 1 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 132 
let l_pos = 132 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 133 
let l_pos = 133 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 134 
let l_pos = 134 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 135 
let l_pos = 135 
expression:(substring p_json, l_pos, 1)
evaluates to U 
let l_char = U 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 136 
let l_pos = 136 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 137 
let l_pos = 137 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 138 
let l_pos = 138 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 139 
let l_pos = 139 
expression:(substring p_json, l_pos, 1)
evaluates to I 
let l_char = I 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 140 
let l_pos = 140 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 141 
let l_pos = 141 
expression:(substring p_json, l_pos, 1)
evaluates to f 
let l_char = f 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 142 
let l_pos = 142 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 143 
let l_pos = 143 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 144 
let l_pos = 144 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 145 
let l_pos = 145 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 146 
let l_pos = 146 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 147 
let l_pos = 147 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 148 
let l_pos = 148 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 149 
let l_pos = 149 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 150 
let l_pos = 150 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 151 
let l_pos = 151 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 152 
let l_pos = 152 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 153 
let l_pos = 153 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 154 
let l_pos = 154 
expression:(substring p_json, l_pos, 1)
evaluates to U 
let l_char = U 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 155 
let l_pos = 155 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 156 
let l_pos = 156 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 157 
let l_pos = 157 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 158 
let l_pos = 158 
expression:(substring p_json, l_pos, 1)
evaluates to I 
let l_char = I 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 159 
let l_pos = 159 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 160 
let l_pos = 160 
expression:(substring p_json, l_pos, 1)
evaluates to f 
let l_char = f 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 161 
let l_pos = 161 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 162 
let l_pos = 162 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 163 
let l_pos = 163 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 164 
let l_pos = 164 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 165 
let l_pos = 165 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 166 
let l_pos = 166 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 167 
let l_pos = 167 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 168 
let l_pos = 168 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 169 
let l_pos = 169 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 170 
let l_pos = 170 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 171 
let l_pos = 171 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 172 
let l_pos = 172 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 173 
let l_pos = 173 
expression:(substring p_json, l_pos, 1)
evaluates to U 
let l_char = U 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 174 
let l_pos = 174 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 175 
let l_pos = 175 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 176 
let l_pos = 176 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 177 
let l_pos = 177 
expression:(substring p_json, l_pos, 1)
evaluates to I 
let l_char = I 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 178 
let l_pos = 178 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 179 
let l_pos = 179 
expression:(substring p_json, l_pos, 1)
evaluates to f 
let l_char = f 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 180 
let l_pos = 180 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 181 
let l_pos = 181 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 182 
let l_pos = 182 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 183 
let l_pos = 183 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 184 
let l_pos = 184 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 185 
let l_pos = 185 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 186 
let l_pos = 186 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 187 
let l_pos = 187 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 188 
let l_pos = 188 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 189 
let l_pos = 189 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 190 
let l_pos = 190 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 191 
let l_pos = 191 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 192 
let l_pos = 192 
expression:(substring p_json, l_pos, 1)
evaluates to U 
let l_char = U 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 193 
let l_pos = 193 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 194 
let l_pos = 194 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 195 
let l_pos = 195 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 196 
let l_pos = 196 
expression:(substring p_json, l_pos, 1)
evaluates to I 
let l_char = I 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 197 
let l_pos = 197 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 198 
let l_pos = 198 
expression:(substring p_json, l_pos, 1)
evaluates to f 
let l_char = f 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 199 
let l_pos = 199 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 200 
let l_pos = 200 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 201 
let l_pos = 201 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 202 
let l_pos = 202 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 203 
let l_pos = 203 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 204 
let l_pos = 204 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 205 
let l_pos = 205 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 206 
let l_pos = 206 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 207 
let l_pos = 207 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 208 
let l_pos = 208 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 209 
let l_pos = 209 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 210 
let l_pos = 210 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 211 
let l_pos = 211 
expression:(substring p_json, l_pos, 1)
evaluates to G 
let l_char = G 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 212 
let l_pos = 212 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 213 
let l_pos = 213 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 214 
let l_pos = 214 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 215 
let l_pos = 215 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 216 
let l_pos = 216 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 217 
let l_pos = 217 
expression:(substring p_json, l_pos, 1)
evaluates to l 
let l_char = l 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 218 
let l_pos = 218 
expression:(substring p_json, l_pos, 1)
evaluates to L 
let l_char = L 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 219 
let l_pos = 219 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 220 
let l_pos = 220 
expression:(substring p_json, l_pos, 1)
evaluates to d 
let l_char = d 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 221 
let l_pos = 221 
expression:(substring p_json, l_pos, 1)
evaluates to g 
let l_char = g 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 222 
let l_pos = 222 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 223 
let l_pos = 223 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 224 
let l_pos = 224 
expression:(substring p_json, l_pos, 1)
evaluates to A 
let l_char = A 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 225 
let l_pos = 225 
expression:(substring p_json, l_pos, 1)
evaluates to c 
let l_char = c 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 226 
let l_pos = 226 
expression:(substring p_json, l_pos, 1)
evaluates to c 
let l_char = c 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 227 
let l_pos = 227 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 228 
let l_pos = 228 
expression:(substring p_json, l_pos, 1)
evaluates to u 
let l_char = u 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 229 
let l_pos = 229 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 230 
let l_pos = 230 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 231 
let l_pos = 231 
expression:(substring p_json, l_pos, 1)
evaluates to C 
let l_char = C 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 232 
let l_pos = 232 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 233 
let l_pos = 233 
expression:(substring p_json, l_pos, 1)
evaluates to d 
let l_char = d 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 234 
let l_pos = 234 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 235 
let l_pos = 235 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 236 
let l_pos = 236 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 237 
let l_pos = 237 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 238 
let l_pos = 238 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 239 
let l_pos = 239 
expression:(substring p_json, l_pos, 1)
evaluates to - 
let l_char = - 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 240 
let l_pos = 240 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 241 
let l_pos = 241 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 242 
let l_pos = 242 
expression:(substring p_json, l_pos, 1)
evaluates to - 
let l_char = - 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 243 
let l_pos = 243 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 244 
let l_pos = 244 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 245 
let l_pos = 245 
expression:(substring p_json, l_pos, 1)
evaluates to - 
let l_char = - 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 246 
let l_pos = 246 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 247 
let l_pos = 247 
expression:(substring p_json, l_pos, 1)
evaluates to 1 
let l_char = 1 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 248 
let l_pos = 248 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 249 
let l_pos = 249 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 250 
let l_pos = 250 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 251 
let l_pos = 251 
expression:(substring p_json, l_pos, 1)
evaluates to A 
let l_char = A 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 252 
let l_pos = 252 
expression:(substring p_json, l_pos, 1)
evaluates to g 
let l_char = g 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 253 
let l_pos = 253 
expression:(substring p_json, l_pos, 1)
evaluates to g 
let l_char = g 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 254 
let l_pos = 254 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 255 
let l_pos = 255 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 256 
let l_pos = 256 
expression:(substring p_json, l_pos, 1)
evaluates to g 
let l_char = g 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 257 
let l_pos = 257 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 258 
let l_pos = 258 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 259 
let l_pos = 259 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 260 
let l_pos = 260 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 261 
let l_pos = 261 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 262 
let l_pos = 262 
expression:(substring p_json, l_pos, 1)
evaluates to P 
let l_char = P 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 263 
let l_pos = 263 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 264 
let l_pos = 264 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 265 
let l_pos = 265 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 266 
let l_pos = 266 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 267 
let l_pos = 267 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 268 
let l_pos = 268 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 269 
let l_pos = 269 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 270 
let l_pos = 270 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 271 
let l_pos = 271 
expression:(substring p_json, l_pos, 1)
evaluates to u 
let l_char = u 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 272 
let l_pos = 272 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 273 
let l_pos = 273 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 274 
let l_pos = 274 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 275 
let l_pos = 275 
expression:(substring p_json, l_pos, 1)
evaluates to A 
let l_char = A 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 276 
let l_pos = 276 
expression:(substring p_json, l_pos, 1)
evaluates to l 
let l_char = l 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 277 
let l_pos = 277 
expression:(substring p_json, l_pos, 1)
evaluates to l 
let l_char = l 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 278 
let l_pos = 278 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 279 
let l_pos = 279 
expression:(substring p_json, l_pos, 1)
evaluates to c 
let l_char = c 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 280 
let l_pos = 280 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 281 
let l_pos = 281 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 282 
let l_pos = 282 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 283 
let l_pos = 283 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 284 
let l_pos = 284 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 285 
let l_pos = 285 
expression:(substring p_json, l_pos, 1)
evaluates to T 
let l_char = T 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 286 
let l_pos = 286 
expression:(substring p_json, l_pos, 1)
evaluates to y 
let l_char = y 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 287 
let l_pos = 287 
expression:(substring p_json, l_pos, 1)
evaluates to p 
let l_char = p 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 288 
let l_pos = 288 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 289 
let l_pos = 289 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 290 
let l_pos = 290 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 291 
let l_pos = 291 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 292 
let l_pos = 292 
expression:(substring p_json, l_pos, 1)
evaluates to D 
let l_char = D 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 293 
let l_pos = 293 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 294 
let l_pos = 294 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 295 
let l_pos = 295 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 296 
let l_pos = 296 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 297 
let l_pos = 297 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 298 
let l_pos = 298 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 299 
let l_pos = 299 
expression:(substring p_json, l_pos, 1)
evaluates to S 
let l_char = S 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 300 
let l_pos = 300 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 301 
let l_pos = 301 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 302 
let l_pos = 302 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 303 
let l_pos = 303 
expression:(substring p_json, l_pos, 1)
evaluates to u 
let l_char = u 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 304 
let l_pos = 304 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 305 
let l_pos = 305 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 306 
let l_pos = 306 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 307 
let l_pos = 307 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 308 
let l_pos = 308 
expression:(substring p_json, l_pos, 1)
evaluates to O 
let l_char = O 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 309 
let l_pos = 309 
expression:(substring p_json, l_pos, 1)
evaluates to p 
let l_char = p 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 310 
let l_pos = 310 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 311 
let l_pos = 311 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 312 
let l_pos = 312 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 313 
let l_pos = 313 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 314 
let l_pos = 314 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 315 
let l_pos = 315 
expression:(substring p_json, l_pos, 1)
evaluates to S 
let l_char = S 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 316 
let l_pos = 316 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 317 
let l_pos = 317 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 318 
let l_pos = 318 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 319 
let l_pos = 319 
expression:(substring p_json, l_pos, 1)
evaluates to u 
let l_char = u 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 320 
let l_pos = 320 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 321 
let l_pos = 321 
expression:(substring p_json, l_pos, 1)
evaluates to U 
let l_char = U 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 322 
let l_pos = 322 
expression:(substring p_json, l_pos, 1)
evaluates to p 
let l_char = p 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 323 
let l_pos = 323 
expression:(substring p_json, l_pos, 1)
evaluates to d 
let l_char = d 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 324 
let l_pos = 324 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 325 
let l_pos = 325 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 326 
let l_pos = 326 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 327 
let l_pos = 327 
expression:(substring p_json, l_pos, 1)
evaluates to d 
let l_char = d 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 328 
let l_pos = 328 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 329 
let l_pos = 329 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 330 
let l_pos = 330 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 331 
let l_pos = 331 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 332 
let l_pos = 332 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 333 
let l_pos = 333 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 334 
let l_pos = 334 
expression:(substring p_json, l_pos, 1)
evaluates to 5 
let l_char = 5 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 335 
let l_pos = 335 
expression:(substring p_json, l_pos, 1)
evaluates to - 
let l_char = - 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 336 
let l_pos = 336 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 337 
let l_pos = 337 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 338 
let l_pos = 338 
expression:(substring p_json, l_pos, 1)
evaluates to - 
let l_char = - 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 339 
let l_pos = 339 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 340 
let l_pos = 340 
expression:(substring p_json, l_pos, 1)
evaluates to 6 
let l_char = 6 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 341 
let l_pos = 341 
expression:(substring p_json, l_pos, 1)
evaluates to T 
let l_char = T 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 342 
let l_pos = 342 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 343 
let l_pos = 343 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 344 
let l_pos = 344 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 345 
let l_pos = 345 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 346 
let l_pos = 346 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 347 
let l_pos = 347 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 348 
let l_pos = 348 
expression:(substring p_json, l_pos, 1)
evaluates to 4 
let l_char = 4 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 349 
let l_pos = 349 
expression:(substring p_json, l_pos, 1)
evaluates to 1 
let l_char = 1 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 350 
let l_pos = 350 
expression:(substring p_json, l_pos, 1)
evaluates to . 
let l_char = . 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 351 
let l_pos = 351 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 352 
let l_pos = 352 
expression:(substring p_json, l_pos, 1)
evaluates to 1 
let l_char = 1 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 353 
let l_pos = 353 
expression:(substring p_json, l_pos, 1)
evaluates to 9 
let l_char = 9 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 354 
let l_pos = 354 
expression:(substring p_json, l_pos, 1)
evaluates to + 
let l_char = + 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 355 
let l_pos = 355 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 356 
let l_pos = 356 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 357 
let l_pos = 357 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 358 
let l_pos = 358 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 359 
let l_pos = 359 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 360 
let l_pos = 360 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 361 
let l_pos = 361 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 362 
let l_pos = 362 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 363 
let l_pos = 363 
expression:(substring p_json, l_pos, 1)
evaluates to P 
let l_char = P 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 364 
let l_pos = 364 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 365 
let l_pos = 365 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 366 
let l_pos = 366 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 367 
let l_pos = 367 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 368 
let l_pos = 368 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 369 
let l_pos = 369 
expression:(substring p_json, l_pos, 1)
evaluates to I 
let l_char = I 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 370 
let l_pos = 370 
expression:(substring p_json, l_pos, 1)
evaluates to d 
let l_char = d 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 371 
let l_pos = 371 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 372 
let l_pos = 372 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 373 
let l_pos = 373 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 374 
let l_pos = 374 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 375 
let l_pos = 375 
expression:(substring p_json, l_pos, 1)
evaluates to 5 
let l_char = 5 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 376 
let l_pos = 376 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 377 
let l_pos = 377 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 378 
let l_pos = 378 
expression:(substring p_json, l_pos, 1)
evaluates to E 
let l_char = E 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 379 
let l_pos = 379 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 380 
let l_pos = 380 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 381 
let l_pos = 381 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 382 
let l_pos = 382 
expression:(substring p_json, l_pos, 1)
evaluates to l 
let l_char = l 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 383 
let l_pos = 383 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 384 
let l_pos = 384 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 385 
let l_pos = 385 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 386 
let l_pos = 386 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 387 
let l_pos = 387 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 388 
let l_pos = 388 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 389 
let l_pos = 389 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 390 
let l_pos = 390 
expression:(substring p_json, l_pos, 1)
evaluates to @ 
let l_char = @ 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 391 
let l_pos = 391 
expression:(substring p_json, l_pos, 1)
evaluates to g 
let l_char = g 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 392 
let l_pos = 392 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 393 
let l_pos = 393 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 394 
let l_pos = 394 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 395 
let l_pos = 395 
expression:(substring p_json, l_pos, 1)
evaluates to l 
let l_char = l 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 396 
let l_pos = 396 
expression:(substring p_json, l_pos, 1)
evaluates to . 
let l_char = . 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 397 
let l_pos = 397 
expression:(substring p_json, l_pos, 1)
evaluates to c 
let l_char = c 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 398 
let l_pos = 398 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 399 
let l_pos = 399 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 400 
let l_pos = 400 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 401 
let l_pos = 401 
expression:(substring p_json, l_pos, 1)
evaluates to , 
let l_char = , 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 402 
let l_pos = 402 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 403 
let l_pos = 403 
expression:(substring p_json, l_pos, 1)
evaluates to E 
let l_char = E 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 404 
let l_pos = 404 
expression:(substring p_json, l_pos, 1)
evaluates to F 
let l_char = F 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 405 
let l_pos = 405 
expression:(substring p_json, l_pos, 1)
evaluates to X 
let l_char = X 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 406 
let l_pos = 406 
expression:(substring p_json, l_pos, 1)
evaluates to I 
let l_char = I 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 407 
let l_pos = 407 
expression:(substring p_json, l_pos, 1)
evaluates to d 
let l_char = d 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 408 
let l_pos = 408 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 409 
let l_pos = 409 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 410 
let l_pos = 410 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 411 
let l_pos = 411 
expression:(substring p_json, l_pos, 1)
evaluates to E 
let l_char = E 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 412 
let l_pos = 412 
expression:(substring p_json, l_pos, 1)
evaluates to F 
let l_char = F 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 413 
let l_pos = 413 
expression:(substring p_json, l_pos, 1)
evaluates to X 
let l_char = X 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 414 
let l_pos = 414 
expression:(substring p_json, l_pos, 1)
evaluates to - 
let l_char = - 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 415 
let l_pos = 415 
expression:(substring p_json, l_pos, 1)
evaluates to 5 
let l_char = 5 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 416 
let l_pos = 416 
expression:(substring p_json, l_pos, 1)
evaluates to 5 
let l_char = 5 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 417 
let l_pos = 417 
expression:(substring p_json, l_pos, 1)
evaluates to 5 
let l_char = 5 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 418 
let l_pos = 418 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 419 
let l_pos = 419 
expression:(substring p_json, l_pos, 1)
evaluates to } 
let l_char = } 
expression:(= l_char, "{")
evaluates to f 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to t 
expression:(= l_obj_start_counter, 1)
evaluates to t 
expression:l_pos
evaluates to 419 
let l_obj_end_pos = 419 
expression:(substring p_json, l_obj_start_pos, (+ (- l_obj_end_pos, l_obj_start_pos), 1))
evaluates to {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} 
let l_object_str = {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} 

insert into  table(l_object_array) 
  values (l_object_str);
expression:(- l_obj_start_counter, 1)
evaluates to 0 
let l_obj_start_counter = 0 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 420 
let l_pos = 420 
expression:(substring p_json, l_pos, 1)
evaluates to NULL. 
let l_char = NULL. 
expression:(= l_char, "{")
evaluates to NULL. 
expression:(and (= l_obj_start_counter, 0), (not-null p_name))
evaluates to f 
expression:(= l_char, "}")
evaluates to NULL. 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to f 
start select cursor.
select *
  from  table(l_object_array) 
select cursor iteration.
select cursor returns {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} 
expression:l_object_str
evaluates to {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} 
procedure sf_json_get_obj returns {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} 


execute function informix.sf_get_property[procid=9798] ( p_json = {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} ,  p_name = Id ,  p_data_type = INTEGER ,  p_raise_exception = t ,  p_errorcode = 24024 ,  p_validations = NULL. ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to f 
expression:(= p_data_type, "BOOLEAN")
evaluates to f 
expression:(= p_data_type, "BOOLEAN_YN")
evaluates to f 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} ,  p_attrib_name = Id ,  p_quoted = f )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "Id" 
let p_attrib_name = "Id" 
expression:(<procedure> length, p_attrib_name)
evaluates to 4 
let l_attrib_name_len = 4 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "f")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to t 
expression:(in p_data_type, "INTEGER")
evaluates to t 
expression:l_property_value
evaluates to NULL. 
let l_integer = NULL. 
expression:(not-null p_validations)
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to NULL. 
procedure sf_get_property returns NULL. 

expression:(<procedure> sf_get_property, l_cost_center, "Id", "INTEGER", "t", 24024)
evaluates to NULL. 
let p_cost_centreid = NULL. 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} ,  p_name = Name ,  p_data_type = STRING ,  p_raise_exception = t ,  p_errorcode = 24025 ,  p_validations = LIST{'MAX_LENGTH','254'} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} ,  p_attrib_name = Name ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "Name" 
let p_attrib_name = "Name" 
expression:(<procedure> length, p_attrib_name)
evaluates to 6 
let l_attrib_name_len = 6 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 2 
let l_pos = 2 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 7 
let l_pos = 7 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 8 
let l_pos = 8 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 9 
let l_pos = 9 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = "TES ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to f 
expression:(<unknown op>: 87 p_quoted)
evaluates to t 
expression:(= l_char, """)
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 10 
let l_attrib_start_pos = 10 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 10 
let l_pos = 10 
expression:(substring p_json, l_pos, 1)
evaluates to T 
let l_char = T 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 11 
let l_pos = 11 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 12 
let l_pos = 12 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 13 
let l_pos = 13 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 14 
let l_pos = 14 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 15 
let l_pos = 15 
expression:(substring p_json, l_pos, 1)
evaluates to / 
let l_char = / 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 16 
let l_pos = 16 
expression:(substring p_json, l_pos, 1)
evaluates to S 
let l_char = S 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 17 
let l_pos = 17 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 18 
let l_pos = 18 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 19 
let l_pos = 19 
expression:(substring p_json, l_pos, 1)
evaluates to v 
let l_char = v 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 20 
let l_pos = 20 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 21 
let l_pos = 21 
expression:(substring p_json, l_pos, 1)
evaluates to c 
let l_char = c 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 22 
let l_pos = 22 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 23 
let l_pos = 23 
expression:(substring p_json, l_pos, 1)
evaluates to # 
let l_char = # 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 24 
let l_pos = 24 
expression:(substring p_json, l_pos, 1)
evaluates to p 
let l_char = p 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 25 
let l_pos = 25 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 26 
let l_pos = 26 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 27 
let l_pos = 27 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 28 
let l_pos = 28 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to t 
expression:(null l_attrib_str)
evaluates to t 
expression:(substring p_json, l_attrib_start_pos, (- l_pos, l_attrib_start_pos))
evaluates to Test /Service#post 
let l_attrib_str = Test /Service#post 
expression:TRIM ( BOTH ' ' FROM l_attrib_str)
evaluates to Test /Service#post 
procedure sf_json_get_attrib returns Test /Service#post 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to Test /Service#post 
let l_property_value = Test /Service#post 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 

execute function informix.equal[procid=-114] (   = Test /Service#post ,    =  )
expression:(= l_property_value, "")
evaluates to f 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to t 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns MAX_LENGTH 
expression:(= l_value, "MIN_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_min_length)
evaluates to f 
expression:(= l_value, "MAX_LENGTH")
evaluates to t 
let l_max_length = t 
select cursor iteration.
select cursor returns 254 
expression:(= l_value, "MIN_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_min_length)
evaluates to f 
expression:(= l_value, "MAX_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_max_length)
evaluates to t 
expression:(> (<procedure> length, l_property_value), l_value)
evaluates to f 
let l_max_length = f 
select cursor iteration.
end cursor
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to Test /Service#post 
procedure sf_get_property returns Test /Service#post 

expression:(<procedure> sf_get_property, l_cost_center, "Name", "STRING", "t", 24025,  LIST{"MAX_LENGTH", "254"})
evaluates to Test /Service#post 
let p_cost_centrenarr = Test /Service#post 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} ,  p_name = Percentage ,  p_data_type = NUMBER ,  p_raise_exception = t ,  p_errorcode = 24026 ,  p_validations = LIST{'DEFAULT','100'} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to f 
expression:(= p_data_type, "BOOLEAN")
evaluates to f 
expression:(= p_data_type, "BOOLEAN_YN")
evaluates to f 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} ,  p_attrib_name = Percentage ,  p_quoted = f )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "Percentage" 
let p_attrib_name = "Percentage" 
expression:(<procedure> length, p_attrib_name)
evaluates to 12 
let l_attrib_name_len = 12 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 0 
let l_pos = 0 
expression:(= l_pos, 0)
evaluates to t 
procedure sf_json_get_attrib returns NULL. 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "f")
evaluates to NULL. 
let l_property_value = NULL. 
expression:(= l_property_value, "")
evaluates to NULL. 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to f 
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to t 
expression:(in p_data_type, "INTEGER")
evaluates to f 
expression:(in p_data_type, "DECIMAL", "NUMBER")
evaluates to t 
expression:l_property_value
evaluates to NULL. 
let l_decimal = NULL. 
expression:(not-null p_validations)
evaluates to t 
let l_min_value = f 
let l_max_value = f 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns DEFAULT 
expression:(= l_value, "MIN_VALUE")
evaluates to f 
expression:(<unknown op>: 87 l_min_value)
evaluates to f 
expression:(= l_value, "MAX_VALUE")
evaluates to f 
expression:(<unknown op>: 87 l_max_value)
evaluates to f 
select cursor iteration.
select cursor returns 100 
expression:(= l_value, "MIN_VALUE")
evaluates to f 
expression:(<unknown op>: 87 l_min_value)
evaluates to f 
expression:(= l_value, "MAX_VALUE")
evaluates to f 
expression:(<unknown op>: 87 l_max_value)
evaluates to f 
select cursor iteration.
end cursor
expression:(and (null l_property_value), (not-null p_validations))
evaluates to t 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns DEFAULT 
expression:(= l_value, "DEFAULT")
evaluates to t 
let l_default = t 
select cursor iteration.
select cursor returns 100 
expression:(= l_value, "DEFAULT")
evaluates to f 
expression:(<unknown op>: 87 l_default)
evaluates to t 
expression:(in p_data_type, "DATE", "DATETIME")
evaluates to f 
expression:l_value
evaluates to 100 
let l_property_value = 100 
let l_null = f 
select cursor iteration.
end cursor
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to 100 
procedure sf_get_property returns 100 

expression:(<procedure> sf_get_property, l_cost_center, "Percentage", "NUMBER", "t", 24026,  LIST{"DEFAULT", "100"})
evaluates to 100.0000 
let p_percentage = 100.0000 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} ,  p_name = CustomerReference ,  p_data_type = STRING ,  p_raise_exception = t ,  p_errorcode = 24138 ,  p_validations = LIST{'MAX_LENGTH','254'} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} ,  p_attrib_name = CustomerReference ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "CustomerReference" 
let p_attrib_name = "CustomerReference" 
expression:(<procedure> length, p_attrib_name)
evaluates to 19 
let l_attrib_name_len = 19 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 30 
let l_pos = 30 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 48 
let l_pos = 48 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 49 
let l_pos = 49 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 50 
let l_pos = 50 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = "TES ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to f 
expression:(<unknown op>: 87 p_quoted)
evaluates to t 
expression:(= l_char, """)
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 51 
let l_attrib_start_pos = 51 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 51 
let l_pos = 51 
expression:(substring p_json, l_pos, 1)
evaluates to T 
let l_char = T 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 52 
let l_pos = 52 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 53 
let l_pos = 53 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 54 
let l_pos = 54 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 55 
let l_pos = 55 
expression:(substring p_json, l_pos, 1)
evaluates to   
let l_char =   
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 56 
let l_pos = 56 
expression:(substring p_json, l_pos, 1)
evaluates to / 
let l_char = / 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 57 
let l_pos = 57 
expression:(substring p_json, l_pos, 1)
evaluates to S 
let l_char = S 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 58 
let l_pos = 58 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 59 
let l_pos = 59 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 60 
let l_pos = 60 
expression:(substring p_json, l_pos, 1)
evaluates to v 
let l_char = v 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 61 
let l_pos = 61 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 62 
let l_pos = 62 
expression:(substring p_json, l_pos, 1)
evaluates to c 
let l_char = c 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 63 
let l_pos = 63 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 64 
let l_pos = 64 
expression:(substring p_json, l_pos, 1)
evaluates to # 
let l_char = # 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 65 
let l_pos = 65 
expression:(substring p_json, l_pos, 1)
evaluates to p 
let l_char = p 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 66 
let l_pos = 66 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 67 
let l_pos = 67 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 68 
let l_pos = 68 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 69 
let l_pos = 69 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to t 
expression:(null l_attrib_str)
evaluates to t 
expression:(substring p_json, l_attrib_start_pos, (- l_pos, l_attrib_start_pos))
evaluates to Test /Service#post 
let l_attrib_str = Test /Service#post 
expression:TRIM ( BOTH ' ' FROM l_attrib_str)
evaluates to Test /Service#post 
procedure sf_json_get_attrib returns Test /Service#post 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to Test /Service#post 
let l_property_value = Test /Service#post 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 

execute function informix.equal[procid=-114] (   = Test /Service#post ,    =  )
expression:(= l_property_value, "")
evaluates to f 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to t 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns MAX_LENGTH 
expression:(= l_value, "MIN_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_min_length)
evaluates to f 
expression:(= l_value, "MAX_LENGTH")
evaluates to t 
let l_max_length = t 
select cursor iteration.
select cursor returns 254 
expression:(= l_value, "MIN_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_min_length)
evaluates to f 
expression:(= l_value, "MAX_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_max_length)
evaluates to t 
expression:(> (<procedure> length, l_property_value), l_value)
evaluates to f 
let l_max_length = f 
select cursor iteration.
end cursor
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to Test /Service#post 
procedure sf_get_property returns Test /Service#post 

expression:(<procedure> sf_get_property, l_cost_center, "CustomerReference", "STRING", "t", 24138,  LIST{"MAX_LENGTH", "254"})
evaluates to Test /Service#post 
let p_cost_centre_code = Test /Service#post 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} ,  p_name = UserInformation1 ,  p_data_type = STRING ,  p_raise_exception = t ,  p_errorcode = 24139 ,  p_validations = LIST{'MAX_LENGTH','254'} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} ,  p_attrib_name = UserInformation1 ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "UserInformation1" 
let p_attrib_name = "UserInformation1" 
expression:(<procedure> length, p_attrib_name)
evaluates to 18 
let l_attrib_name_len = 18 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 96 
let l_pos = 96 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 113 
let l_pos = 113 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 114 
let l_pos = 114 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 115 
let l_pos = 115 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = "USE ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to f 
expression:(<unknown op>: 87 p_quoted)
evaluates to t 
expression:(= l_char, """)
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 116 
let l_attrib_start_pos = 116 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 116 
let l_pos = 116 
expression:(substring p_json, l_pos, 1)
evaluates to U 
let l_char = U 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 117 
let l_pos = 117 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 118 
let l_pos = 118 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 119 
let l_pos = 119 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 120 
let l_pos = 120 
expression:(substring p_json, l_pos, 1)
evaluates to I 
let l_char = I 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 121 
let l_pos = 121 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 122 
let l_pos = 122 
expression:(substring p_json, l_pos, 1)
evaluates to f 
let l_char = f 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 123 
let l_pos = 123 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 124 
let l_pos = 124 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 125 
let l_pos = 125 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 126 
let l_pos = 126 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 127 
let l_pos = 127 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 128 
let l_pos = 128 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 129 
let l_pos = 129 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 130 
let l_pos = 130 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 131 
let l_pos = 131 
expression:(substring p_json, l_pos, 1)
evaluates to 1 
let l_char = 1 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 132 
let l_pos = 132 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to t 
expression:(null l_attrib_str)
evaluates to t 
expression:(substring p_json, l_attrib_start_pos, (- l_pos, l_attrib_start_pos))
evaluates to UserInformation1 
let l_attrib_str = UserInformation1 
expression:TRIM ( BOTH ' ' FROM l_attrib_str)
evaluates to UserInformation1 
procedure sf_json_get_attrib returns UserInformation1 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to UserInformation1 
let l_property_value = UserInformation1 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 

execute function informix.equal[procid=-114] (   = UserInformation1 ,    =  )
expression:(= l_property_value, "")
evaluates to f 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to t 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns MAX_LENGTH 
expression:(= l_value, "MIN_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_min_length)
evaluates to f 
expression:(= l_value, "MAX_LENGTH")
evaluates to t 
let l_max_length = t 
select cursor iteration.
select cursor returns 254 
expression:(= l_value, "MIN_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_min_length)
evaluates to f 
expression:(= l_value, "MAX_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_max_length)
evaluates to t 
expression:(> (<procedure> length, l_property_value), l_value)
evaluates to f 
let l_max_length = f 
select cursor iteration.
end cursor
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to UserInformation1 
procedure sf_get_property returns UserInformation1 

expression:(<procedure> sf_get_property, l_cost_center, "UserInformation1", "STRING", "t", 24139,  LIST{"MAX_LENGTH", "254"})
evaluates to UserInformation1 
let p_user_info1 = UserInformation1 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} ,  p_name = UserInformation2 ,  p_data_type = STRING ,  p_raise_exception = t ,  p_errorcode = 24140 ,  p_validations = LIST{'MAX_LENGTH','254'} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} ,  p_attrib_name = UserInformation2 ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "UserInformation2" 
let p_attrib_name = "UserInformation2" 
expression:(<procedure> length, p_attrib_name)
evaluates to 18 
let l_attrib_name_len = 18 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 134 
let l_pos = 134 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 151 
let l_pos = 151 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 152 
let l_pos = 152 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 153 
let l_pos = 153 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = "USE ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to f 
expression:(<unknown op>: 87 p_quoted)
evaluates to t 
expression:(= l_char, """)
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 154 
let l_attrib_start_pos = 154 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 154 
let l_pos = 154 
expression:(substring p_json, l_pos, 1)
evaluates to U 
let l_char = U 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 155 
let l_pos = 155 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 156 
let l_pos = 156 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 157 
let l_pos = 157 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 158 
let l_pos = 158 
expression:(substring p_json, l_pos, 1)
evaluates to I 
let l_char = I 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 159 
let l_pos = 159 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 160 
let l_pos = 160 
expression:(substring p_json, l_pos, 1)
evaluates to f 
let l_char = f 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 161 
let l_pos = 161 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 162 
let l_pos = 162 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 163 
let l_pos = 163 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 164 
let l_pos = 164 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 165 
let l_pos = 165 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 166 
let l_pos = 166 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 167 
let l_pos = 167 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 168 
let l_pos = 168 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 169 
let l_pos = 169 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 170 
let l_pos = 170 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to t 
expression:(null l_attrib_str)
evaluates to t 
expression:(substring p_json, l_attrib_start_pos, (- l_pos, l_attrib_start_pos))
evaluates to UserInformation2 
let l_attrib_str = UserInformation2 
expression:TRIM ( BOTH ' ' FROM l_attrib_str)
evaluates to UserInformation2 
procedure sf_json_get_attrib returns UserInformation2 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to UserInformation2 
let l_property_value = UserInformation2 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 

execute function informix.equal[procid=-114] (   = UserInformation2 ,    =  )
expression:(= l_property_value, "")
evaluates to f 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to t 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns MAX_LENGTH 
expression:(= l_value, "MIN_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_min_length)
evaluates to f 
expression:(= l_value, "MAX_LENGTH")
evaluates to t 
let l_max_length = t 
select cursor iteration.
select cursor returns 254 
expression:(= l_value, "MIN_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_min_length)
evaluates to f 
expression:(= l_value, "MAX_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_max_length)
evaluates to t 
expression:(> (<procedure> length, l_property_value), l_value)
evaluates to f 
let l_max_length = f 
select cursor iteration.
end cursor
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to UserInformation2 
procedure sf_get_property returns UserInformation2 

expression:(<procedure> sf_get_property, l_cost_center, "UserInformation2", "STRING", "t", 24140,  LIST{"MAX_LENGTH", "254"})
evaluates to UserInformation2 
let p_user_info2 = UserInformation2 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} ,  p_name = UserInformation3 ,  p_data_type = STRING ,  p_raise_exception = t ,  p_errorcode = 24141 ,  p_validations = LIST{'MAX_LENGTH','254'} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} ,  p_attrib_name = UserInformation3 ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "UserInformation3" 
let p_attrib_name = "UserInformation3" 
expression:(<procedure> length, p_attrib_name)
evaluates to 18 
let l_attrib_name_len = 18 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 172 
let l_pos = 172 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 189 
let l_pos = 189 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 190 
let l_pos = 190 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 191 
let l_pos = 191 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = "USE ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to f 
expression:(<unknown op>: 87 p_quoted)
evaluates to t 
expression:(= l_char, """)
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 192 
let l_attrib_start_pos = 192 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 192 
let l_pos = 192 
expression:(substring p_json, l_pos, 1)
evaluates to U 
let l_char = U 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 193 
let l_pos = 193 
expression:(substring p_json, l_pos, 1)
evaluates to s 
let l_char = s 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 194 
let l_pos = 194 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 195 
let l_pos = 195 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 196 
let l_pos = 196 
expression:(substring p_json, l_pos, 1)
evaluates to I 
let l_char = I 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 197 
let l_pos = 197 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 198 
let l_pos = 198 
expression:(substring p_json, l_pos, 1)
evaluates to f 
let l_char = f 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 199 
let l_pos = 199 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 200 
let l_pos = 200 
expression:(substring p_json, l_pos, 1)
evaluates to r 
let l_char = r 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 201 
let l_pos = 201 
expression:(substring p_json, l_pos, 1)
evaluates to m 
let l_char = m 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 202 
let l_pos = 202 
expression:(substring p_json, l_pos, 1)
evaluates to a 
let l_char = a 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 203 
let l_pos = 203 
expression:(substring p_json, l_pos, 1)
evaluates to t 
let l_char = t 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 204 
let l_pos = 204 
expression:(substring p_json, l_pos, 1)
evaluates to i 
let l_char = i 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 205 
let l_pos = 205 
expression:(substring p_json, l_pos, 1)
evaluates to o 
let l_char = o 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 206 
let l_pos = 206 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 207 
let l_pos = 207 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 208 
let l_pos = 208 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to t 
expression:(null l_attrib_str)
evaluates to t 
expression:(substring p_json, l_attrib_start_pos, (- l_pos, l_attrib_start_pos))
evaluates to UserInformation3 
let l_attrib_str = UserInformation3 
expression:TRIM ( BOTH ' ' FROM l_attrib_str)
evaluates to UserInformation3 
procedure sf_json_get_attrib returns UserInformation3 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to UserInformation3 
let l_property_value = UserInformation3 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 

execute function informix.equal[procid=-114] (   = UserInformation3 ,    =  )
expression:(= l_property_value, "")
evaluates to f 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to t 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns MAX_LENGTH 
expression:(= l_value, "MIN_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_min_length)
evaluates to f 
expression:(= l_value, "MAX_LENGTH")
evaluates to t 
let l_max_length = t 
select cursor iteration.
select cursor returns 254 
expression:(= l_value, "MIN_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_min_length)
evaluates to f 
expression:(= l_value, "MAX_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_max_length)
evaluates to t 
expression:(> (<procedure> length, l_property_value), l_value)
evaluates to f 
let l_max_length = f 
select cursor iteration.
end cursor
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to UserInformation3 
procedure sf_get_property returns UserInformation3 

expression:(<procedure> sf_get_property, l_cost_center, "UserInformation3", "STRING", "t", 24141,  LIST{"MAX_LENGTH", "254"})
evaluates to UserInformation3 
let p_user_info3 = UserInformation3 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} ,  p_name = GeneralLedgerAccountCode ,  p_data_type = STRING ,  p_raise_exception = t ,  p_errorcode = 24142 ,  p_validations = LIST{'MAX_LENGTH','254'} ,  p_enums_map = NULL. ,  p_enums = NULL. )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} ,  p_attrib_name = GeneralLedgerAccountCode ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "GeneralLedgerAccountCode" 
let p_attrib_name = "GeneralLedgerAccountCode" 
expression:(<procedure> length, p_attrib_name)
evaluates to 26 
let l_attrib_name_len = 26 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 210 
let l_pos = 210 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 235 
let l_pos = 235 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 236 
let l_pos = 236 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 237 
let l_pos = 237 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = "2-3 ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to f 
expression:(<unknown op>: 87 p_quoted)
evaluates to t 
expression:(= l_char, """)
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 238 
let l_attrib_start_pos = 238 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 238 
let l_pos = 238 
expression:(substring p_json, l_pos, 1)
evaluates to 2 
let l_char = 2 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 239 
let l_pos = 239 
expression:(substring p_json, l_pos, 1)
evaluates to - 
let l_char = - 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 240 
let l_pos = 240 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 241 
let l_pos = 241 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 242 
let l_pos = 242 
expression:(substring p_json, l_pos, 1)
evaluates to - 
let l_char = - 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 243 
let l_pos = 243 
expression:(substring p_json, l_pos, 1)
evaluates to 3 
let l_char = 3 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 244 
let l_pos = 244 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 245 
let l_pos = 245 
expression:(substring p_json, l_pos, 1)
evaluates to - 
let l_char = - 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 246 
let l_pos = 246 
expression:(substring p_json, l_pos, 1)
evaluates to 0 
let l_char = 0 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 247 
let l_pos = 247 
expression:(substring p_json, l_pos, 1)
evaluates to 1 
let l_char = 1 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 248 
let l_pos = 248 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to t 
expression:(null l_attrib_str)
evaluates to t 
expression:(substring p_json, l_attrib_start_pos, (- l_pos, l_attrib_start_pos))
evaluates to 2-30-30-01 
let l_attrib_str = 2-30-30-01 
expression:TRIM ( BOTH ' ' FROM l_attrib_str)
evaluates to 2-30-30-01 
procedure sf_json_get_attrib returns 2-30-30-01 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to 2-30-30-01 
let l_property_value = 2-30-30-01 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 

execute function informix.equal[procid=-114] (   = 2-30-30-01 ,    =  )
expression:(= l_property_value, "")
evaluates to f 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to t 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns MAX_LENGTH 
expression:(= l_value, "MIN_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_min_length)
evaluates to f 
expression:(= l_value, "MAX_LENGTH")
evaluates to t 
let l_max_length = t 
select cursor iteration.
select cursor returns 254 
expression:(= l_value, "MIN_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_min_length)
evaluates to f 
expression:(= l_value, "MAX_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_max_length)
evaluates to t 
expression:(> (<procedure> length, l_property_value), l_value)
evaluates to f 
let l_max_length = f 
select cursor iteration.
end cursor
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to 2-30-30-01 
procedure sf_get_property returns 2-30-30-01 

expression:(<procedure> sf_get_property, l_cost_center, "GeneralLedgerAccountCode", "STRING", "t", 24142,  LIST{"MAX_LENGTH", "254"})
evaluates to 2-30-30-01 
let p_gl_acctcode = 2-30-30-01 

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.collcast[procid=15] ( arg[0] =  )

execute function informix.sf_get_property[procid=9798] ( p_json = {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} ,  p_name = Status ,  p_data_type = STRING ,  p_raise_exception = t ,  p_errorcode = 24143 ,  p_validations = LIST{'DEFAULT','Open'} ,  p_enums_map = NULL. ,  p_enums = LIST{'Open','Closed','Cancelled','OnHold'} )
default value  p_data_type = STRING
default value  p_raise_exception = f
default value  p_errorcode = NULL.
default value  p_validations = NULL.
default value  p_enums_map = NULL.
default value  p_enums = NULL.
set_state: owner is informix - utype = 'D'let l_property_value = NULL. 
let l_null = f 
let l_min_length = f 
let l_max_length = f 
let l_min_value = f 
let l_max_value = f 
let l_default = f 
expression:(or (or (= p_data_type, "STRING"), (= p_data_type, "DATETIME")), (= p_data_type, "DATE"))
evaluates to t 

execute function informix.sf_json_get_attrib[procid=9799] ( p_json = {"Name":"Test /Service#post","CustomerReference":"Test /Service#post","ContactCode":"40003106","UserInformation1":"UserInformation1","UserInformation2":"UserInformation2","UserInformation3":"UserInformation3","GeneralLedgerAccountCode":"2-30-30-01","AggregationPoint":true,"AllocationType":"Date","Status":"Open","StatusUpdated":"2025-03-26T02:03:41.019+00:00","ParentId":205,"Email":"test@gmail.com","EFXId":"EFX-555"} ,  p_attrib_name = Status ,  p_quoted = t )
set_state: owner is informix - utype = 'D'let l_pos = 0 
let l_char = NULL. 
let l_attrib_start_pos = 0 
let l_attrib_end_pos = 0 
let l_attrib_name_len = 0 
let l_attrib_str = NULL. 
let l_escaped = f 
expression:(|| (|| """, TRIM ( BOTH ' ' FROM p_attrib_name)), """)
evaluates to "Status" 
let p_attrib_name = "Status" 
expression:(<procedure> length, p_attrib_name)
evaluates to 8 
let l_attrib_name_len = 8 
expression:(<procedure> instr, p_json, TRIM ( BOTH ' ' FROM p_attrib_name))
evaluates to 298 
let l_pos = 298 
expression:(= l_pos, 0)
evaluates to f 
expression:(- (+ l_pos, l_attrib_name_len), 1)
evaluates to 305 
let l_pos = 305 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 306 
let l_pos = 306 
expression:(substring p_json, l_pos, 1)
evaluates to : 
let l_char = : 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to t 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 307 
let l_pos = 307 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to t 
expression:(or (= l_char, ":"), (= l_char, " "))
evaluates to f 

execute function informix.equal[procid=-114] (   = "OPE ,    = NULL )
expression:(= (<procedure> upper, (substring p_json, l_pos, 4)), "NULL")
evaluates to f 
expression:(<unknown op>: 87 p_quoted)
evaluates to t 
expression:(= l_char, """)
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 308 
let l_attrib_start_pos = 308 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 308 
let l_pos = 308 
expression:(substring p_json, l_pos, 1)
evaluates to O 
let l_char = O 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 309 
let l_pos = 309 
expression:(substring p_json, l_pos, 1)
evaluates to p 
let l_char = p 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 310 
let l_pos = 310 
expression:(substring p_json, l_pos, 1)
evaluates to e 
let l_char = e 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 311 
let l_pos = 311 
expression:(substring p_json, l_pos, 1)
evaluates to n 
let l_char = n 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to f 
expression:(<= l_pos, (<procedure> length, p_json))
evaluates to t 
expression:(+ l_pos, 1)
evaluates to 312 
let l_pos = 312 
expression:(substring p_json, l_pos, 1)
evaluates to " 
let l_char = " 
expression:(= l_char, "\")
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(= l_attrib_start_pos, 0)
evaluates to f 
expression:(and (not (<unknown op>: 87 p_quoted)), (or (= l_char, ","), (= l_char, "}")))
evaluates to f 
expression:(and (= l_char, """), (<unknown op>: 87 l_escaped))
evaluates to f 
expression:(and (and (<unknown op>: 87 l_escaped), (<> l_char, """)), (<> l_char, "\"))
evaluates to f 
expression:(= l_char, """)
evaluates to t 
expression:(null l_attrib_str)
evaluates to t 
expression:(substring p_json, l_attrib_start_pos, (- l_pos, l_attrib_start_pos))
evaluates to Open 
let l_attrib_str = Open 
expression:TRIM ( BOTH ' ' FROM l_attrib_str)
evaluates to Open 
procedure sf_json_get_attrib returns Open 

expression:(<procedure> sf_json_get_attrib, p_json, p_name, "t")
evaluates to Open 
let l_property_value = Open 
expression:(or (= p_data_type, "DATETIME"), (= p_data_type, "DATE"))
evaluates to f 

execute function informix.equal[procid=-114] (   = Open ,    =  )
expression:(= l_property_value, "")
evaluates to f 
expression:(and (and (= p_data_type, "STRING"), (not-null l_property_value)), (not-null p_validations))
evaluates to t 
start select cursor.
select *
  from  table(p_validations) 
select cursor iteration.
select cursor returns DEFAULT 
expression:(= l_value, "MIN_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_min_length)
evaluates to f 
expression:(= l_value, "MAX_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_max_length)
evaluates to f 
select cursor iteration.
select cursor returns Open 
expression:(= l_value, "MIN_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_min_length)
evaluates to f 
expression:(= l_value, "MAX_LENGTH")
evaluates to f 
expression:(<unknown op>: 87 l_max_length)
evaluates to f 
select cursor iteration.
end cursor
expression:(in p_data_type, "NUMBER", "INTEGER", "DECIMAL", "CURRENCY")
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(and (null l_property_value), (not-null p_validations))
evaluates to f 
expression:(not-null p_enums)
evaluates to t 
expression:(<> p_data_type, "STRING")
evaluates to f 
let l_enum_matched = f 
start select cursor.
select *
  from  table(p_enums) 
select cursor iteration.
select cursor returns Open 
expression:(and (= TRIM ( BOTH ' ' FROM (<procedure> upper, l_value)), "NULL"), (null l_property_value))
evaluates to f 

execute function informix.equal[procid=-94] (   = Open ,    = Open )
expression:(= TRIM ( BOTH ' ' FROM l_value), TRIM ( BOTH ' ' FROM l_property_value))
evaluates to t 
let l_enum_matched = t 
end cursor
expression:(not (<unknown op>: 87 l_enum_matched))
evaluates to f 
expression:(not-null p_enums_map)
evaluates to f 
expression:l_property_value
evaluates to Open 
procedure sf_get_property returns Open 

exception : looking for handler
SQL error =   ISAM error = 0  error string =  = ""
exception : handler FOUND

execute function informix.sf_except[procid=9069] ( http = -1213 ,  err = 0 ,  msg =                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ,  objectname = sp_services_api ,  tran_flg = N ,  p_request_id = 0 )
default value  msg = No message supplied
default value  objectname = %not set%
default value  tran_flg = N
default value  p_request_id = 0
set_state: owner is informix - utype = 'D'trace off

expression:(<procedure> sf_except, http, err, msg, "sp_services_api", tran_flg)
evaluates to (-1213) ; Database ; 500 ; 
let http = 500 
let errcode = Database 
let msg = (-1213) 
expression:msg
evaluates to (-1213) 
expression:errcode
evaluates to Database 
expression:http
evaluates to 500 
procedure sp_services_api returns 500 , NULL. , Database , (-1213) 

